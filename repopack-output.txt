================================================================
File Summary
================================================================

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line


================================================================
Repository Structure
================================================================
src/
  app/
    (auth)/
      sign-in/
        [[...sign-in]]/
          page.tsx
      sign-up/
        [[...sign-up]]/
          page.tsx
      layout.tsx
    (dashboard)/
      calendar/
        page.tsx
      dashboard/
        page.tsx
      events/
        [eventId]/
          edit/
            page.tsx
          loading.tsx
          page.tsx
        new/
          page.tsx
        loading.tsx
        page.tsx
      layout.tsx
    api/
      activities/
        route.ts
      events/
        [eventId]/
          activities/
            route.ts
          chat/
            [messageId]/
              route.ts
            route.ts
          check-in/
            route.ts
          export/
            route.ts
          guests/
            [guestId]/
              route.ts
            route.ts
          invite/
            route.ts
          stats/
            route.ts
          waitlist/
            route.ts
          route.ts
        recurring/
          route.ts
        stats/
          charts/
            route.ts
        upcoming/
          route.ts
        route.ts
      users/
        [userId]/
          route.ts
      webhooks/
        clerk/
          route.ts
      mocks.ts
    error.tsx
    global-error.tsx
    globals.css
    layout.tsx
    not-found.tsx
    page.tsx
    sentry.client.config.ts
  components/
    activity/
      activity-feed.tsx
    ads/
      AdSense.tsx
      AdUnit.tsx
    calendar/
      event-calendar.tsx
    dashboard/
      charts.tsx
      event-stats.tsx
      metric-card.tsx
      metrics.tsx
      recent-activity.tsx
      upcoming-events.tsx
    error-boundary/
      global-error.tsx
      sentry-error-boundary.tsx
      with-error-boundary.tsx
    events/
      check-in.tsx
      event-card.tsx
      event-chat.tsx
      event-form.tsx
      guest-list.tsx
      share-event.tsx
      venue-map.tsx
    export/
      export-button.tsx
    filters/
      advanced-filter.tsx
    layout/
      event-card.tsx
      main-nav.tsx
      navbar.tsx
    providers/
      theme-provider.tsx
    mode-toggle.tsx
  emails/
    event-invitation.tsx
  hooks/
    use-error-boundary.ts
    use-toast.ts
  lib/
    actions/
      events.ts
    activity/
      notifications.ts
    api/
      error-handler.ts
    auth/
      rate-limit.ts
      rbac.ts
      roles.ts
      types.ts
    constants/
      event-categories.ts
    db/
      models/
        activity.ts
        event.ts
        guest.ts
        message.ts
        user.model.ts
        waitlist.ts
      utils/
        monitor.ts
        performance.ts
      connection.ts
    email/
      notifications.ts
    export/
      index.ts
    validation/
      event.ts
      sanitize.ts
    auth.ts
    google-calendar.ts
    logger.ts
    pusher.ts
    rate-limit.ts
    utils.ts
  mocks/
    browser.ts
    handlers.ts
    server.ts
  types/
    event.ts
  instrumentation.ts
  middleware.ts
components.json
jest.config.ts
jest.setup.ts
next.config.mjs
package.json
postcss.config.mjs
sentry.server.config.ts
service-worker.js
tailwind.config.ts
tsconfig.json

================================================================
Repository Files
================================================================

================
File: src/app/(auth)/sign-in/[[...sign-in]]/page.tsx
================
import { SignIn } from "@clerk/nextjs";

export default function SignInPage() {
  return (
    <div className="flex h-screen items-center justify-center">
      <SignIn 
        appearance={{
          elements: {
            formButtonPrimary: 'bg-primary text-primary-foreground hover:bg-primary/90',
            footerActionLink: 'text-primary hover:text-primary/90'
          }
        }}
      />
    </div>
  );
}

================
File: src/app/(auth)/sign-up/[[...sign-up]]/page.tsx
================
import { SignUp } from "@clerk/nextjs";

export default function SignUpPage() {
  return (
    <div className="flex h-screen items-center justify-center">
      <SignUp 
        appearance={{
          elements: {
            formButtonPrimary: 'bg-primary text-primary-foreground hover:bg-primary/90',
            footerActionLink: 'text-primary hover:text-primary/90'
          }
        }}
      />
    </div>
  );
}

================
File: src/app/(auth)/layout.tsx
================
import { auth } from "@clerk/nextjs/server";
import { redirect } from "next/navigation";

export default async function AuthLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  const { userId } = await auth();

  // If user is already authenticated, redirect to dashboard
  if (userId) {
    redirect("/dashboard");
  }

  return (
    <div className="flex h-screen items-center justify-center">
      {children}
    </div>
  );
}

================
File: src/app/(dashboard)/calendar/page.tsx
================
import { EventCalendar } from "@/components/calendar/event-calendar";

export default function CalendarPage() {
  return (
    <div className="space-y-4">
      <h1 className="text-3xl font-bold">Calendar</h1>
      <EventCalendar />
    </div>
  );
}

================
File: src/app/(dashboard)/dashboard/page.tsx
================
// src/app/(dashboard)/dashboard/page.tsx
import { auth } from "@clerk/nextjs/server";
import { redirect } from "next/navigation";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { DashboardCharts } from "@/components/dashboard/charts";
import { UpcomingEvents } from "@/components/dashboard/upcoming-events";
import { EventStats } from "@/components/dashboard/event-stats";
import { RecentActivity } from "@/components/dashboard/recent-activity";
import dbConnect from "@/lib/db/connection";
import { Event } from "@/lib/db/models/event";
import { Guest } from "@/lib/db/models/guest";
import AdUnit from "@/components/ads/AdUnit";

async function getEventStats(userId: string) {
  await dbConnect();

  const now = new Date();
  const thirtyDaysFromNow = new Date();
  thirtyDaysFromNow.setDate(now.getDate() + 30);

  try {
    const [
      totalEvents,
      upcomingEvents,
      totalAttendees,
      checkedInAttendees
    ] = await Promise.all([
      // Total events
      Event.countDocuments({ organizerId: userId }),
      
      // Upcoming events (next 30 days)
      Event.countDocuments({
        organizerId: userId,
        startDate: { $gte: now, $lte: thirtyDaysFromNow }
      }),
      
      // Total confirmed attendees across all events
      Guest.countDocuments({
        eventId: { 
          $in: (await Event.find({ organizerId: userId }).select('_id'))
            .map(event => event._id)
        },
        status: "confirmed"
      }),
      
      // Total checked-in attendees
      Guest.countDocuments({
        eventId: { 
          $in: (await Event.find({ organizerId: userId }).select('_id'))
            .map(event => event._id)
        },
        checkedIn: true
      })
    ]);

    const averageAttendance = totalAttendees > 0 
      ? Math.round((checkedInAttendees / totalAttendees) * 100)
      : 0;

    return {
      totalEvents,
      upcomingEvents,
      totalAttendees,
      averageAttendance
    };
  } catch (error) {
    console.error("Error fetching event stats:", error);
    return {
      totalEvents: 0,
      upcomingEvents: 0,
      totalAttendees: 0,
      averageAttendance: 0
    };
  }
}

export default async function DashboardPage() {
  const { userId } = await auth();
  if (!userId) redirect("/sign-in");

  const stats = await getEventStats(userId);

  return (
    <div className="flex gap-4">
      {/* Left Sidebar for Ad */}
      {/* <div className="hidden xl:block w-[100px] shrink-0">
        <AdUnit 
          slot="30002"
          format="vertical"
          style={{ 
            position: "sticky",
            top: "2rem",
            minHeight: "600px",
            width: "160px",
            margin: "",
            display: "flex"
          }}
        />
      </div> */}

      {/* Main Dashboard Content */}
      <div className="flex-1 space-y-8">
        <h1 className="text-3xl font-bold">Dashboard</h1>
        
        <div className="grid gap-4 md:grid-cols-2 lg:grid-cols-4">
          <EventStats stats={stats} />
        </div>

        <div className="grid gap-4 md:grid-cols-2 lg:grid-cols-7">
          <div className="md:col-span-4">
            <DashboardCharts />
          </div>
          <div className="md:col-span-3">
            <UpcomingEvents />
          </div>
        </div>

        <div className="grid gap-4 md:grid-cols-2">
          <Card>
            <CardHeader>
              <CardTitle>Recent Activity</CardTitle>
            </CardHeader>
            <CardContent>
              <RecentActivity />
            </CardContent>
          </Card>
        </div>
        <div className="xl:block item-center justify-items-center justify-center shrink-0">
            <AdUnit 
              slot="30002"
              format="vertical"
              style={{ 
                position: "sticky",
                top: "2rem",
                minHeight: "100px",
                width: "400px",
                margin: "0 auto",
                display: "flex"
              }}
            />
      </div> 
      </div>      
    </div>
  );
}

================
File: src/app/(dashboard)/events/[eventId]/edit/page.tsx
================
import { auth } from "@clerk/nextjs/server";
import { redirect } from "next/navigation";
import { Card } from "@/components/ui/card";
import { EventForm } from "@/components/events/event-form";
import { Event } from "@/lib/db/models/event";
import dbConnect from "@/lib/db/connection";

async function getEvent(eventId: string) {
  try {
    await dbConnect();
    const event = await Event.findById(eventId).toString();
    if (!event) return null;
    return event;
  } catch (error) {
    console.error("Error fetching event:", error);
    return null;
  }
}

export default async function EditEventPage({
  params,
}: {
  params: { eventId: string };
}) {
  const { userId } = await auth();
  if (!userId) {
    redirect("/sign-in");
  }

  const event = await getEvent(params.eventId);
  if (!event) {
    redirect("/events");
  }

  return (
    <div className="max-w-4xl mx-auto space-y-4">
      <div className="space-y-2">
        <h1 className="text-3xl font-bold">Edit Event</h1>
        <p className="text-muted-foreground">
          Update your event details below.
        </p>
      </div>

      <Card className="p-6">
        <EventForm event={event} isEditing />
      </Card>
    </div>
  );
}

================
File: src/app/(dashboard)/events/[eventId]/loading.tsx
================
import { Skeleton } from "@/components/ui/skeleton";

export default function EventLoading() {
  return (
    <div className="space-y-6">
      <div className="space-y-2">
        <Skeleton className="h-8 w-1/3" />
        <Skeleton className="h-4 w-2/3" />
      </div>
      <div className="grid gap-6 md:grid-cols-2">
        <Skeleton className="h-[300px]" />
        <Skeleton className="h-[300px]" />
      </div>
    </div>
  );
}

================
File: src/app/(dashboard)/events/[eventId]/page.tsx
================
import { notFound } from "next/navigation";
import { format } from "date-fns";
import { 
  Calendar, 
  Clock, 
  MapPin, 
  Users, 
  Share2, 
  Download, 
  Mail, 
  MessageCircle,
  Settings,
  AlertCircle
} from "lucide-react";
import { Button } from "@/components/ui/button";
import { Card } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { Separator } from "@/components/ui/separator";
import { ErrorBoundary } from "react-error-boundary";
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/components/ui/tooltip";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogHeader,
  DialogTitle,
  DialogTrigger,
} from "@/components/ui/dialog";
import { GuestList } from "@/components/events/guest-list";
import { EventChat } from "@/components/events/event-chat";
import { ShareEvent } from "@/components/events/share-event";
import { auth } from "@clerk/nextjs/server";
import dbConnect from "@/lib/db/connection";
import { Event as EventModel } from "@/lib/db/models/event";
import { serializeEvent } from "@/lib/utils";
import AdUnit from "@/components/ads/AdUnit";

function ErrorFallback({ error }: { error: Error }) {
  return (
    <div className="flex flex-col items-center justify-center h-[60vh] space-y-4">
      <p className="text-muted-foreground">Something went wrong</p>
      <pre className="text-sm text-red-500">{error.message}</pre>
    </div>
  );
}

async function getEvent(eventId: string) {
  try {
    await dbConnect();
    const event = await EventModel.findById(eventId).lean();
    if (!event) return null;
    return serializeEvent(event);
  } catch (error) {
    console.error("Error fetching event:", error);
    return null;
  }
}

export default async function EventPage({
  params,
}: {
  params: { eventId: string };
}) {
  const { userId } = await auth();
  const event = await getEvent(params.eventId);

  if (!event) {
    notFound();
  }

  const isOrganizer = userId === event.organizerId;
  const isCoHost = event.coHosts.includes(userId!);
  const canManageEvent = isOrganizer || isCoHost;

  return (
    <div className="space-y-6">
      {/* Header Section */}
      <div className="flex items-center justify-between">
        <div className="space-y-1">
          <div className="flex items-center space-x-2">
            <h1 className="text-3xl font-bold">{event.title}</h1>
            <Badge variant={event.status === "published" ? "default" : "secondary"}>
              {event.status}
            </Badge>
          </div>
          <p className="text-muted-foreground max-w-2xl">{event.description}</p>
        </div>
        
        {canManageEvent && (
          <DropdownMenu>
            <DropdownMenuTrigger asChild>
              <Button variant="outline" size="icon">
                <Settings className="h-4 w-4" />
              </Button>
            </DropdownMenuTrigger>
            <DropdownMenuContent align="end">
              <DropdownMenuLabel>Event Actions</DropdownMenuLabel>
              <DropdownMenuSeparator />
              <DropdownMenuItem>
                <Settings className="mr-2 h-4 w-4" /> Edit Event
              </DropdownMenuItem>
              <DropdownMenuItem>
                <Mail className="mr-2 h-4 w-4" /> Send Reminders
              </DropdownMenuItem>
              <DropdownMenuItem className="text-destructive">
                <AlertCircle className="mr-2 h-4 w-4" /> Cancel Event
              </DropdownMenuItem>
            </DropdownMenuContent>
          </DropdownMenu>
        )}
      </div>

      {/* Event Details */}
      <div className="grid gap-6 lg:grid-cols-3">
        <Card className="p-6 space-y-4 lg:col-span-2">
          <div className="flex items-center justify-between">
            <h2 className="text-xl font-semibold">Event Details</h2>
            <div className="flex space-x-2">
              <TooltipProvider>
                <Tooltip>
                  <TooltipTrigger asChild>
                    <Button variant="outline" size="icon">
                      <Share2 className="h-4 w-4" />
                    </Button>
                  </TooltipTrigger>
                  <TooltipContent>Share Event</TooltipContent>
                </Tooltip>
              </TooltipProvider>

              <TooltipProvider>
                <Tooltip>
                  <TooltipTrigger asChild>
                    <Button variant="outline" size="icon">
                      <Download className="h-4 w-4" />
                    </Button>
                  </TooltipTrigger>
                  <TooltipContent>Download iCal</TooltipContent>
                </Tooltip>
              </TooltipProvider>
            </div>
          </div>
          
          <Separator />
          
          <div className="grid gap-6 lg:grid-cols-3">
            <div className="space-y-4">
              <div className="flex items-center space-x-2">
                <Calendar className="h-5 w-5 text-muted-foreground" />
                <div className="space-y-1">
                  <p className="font-medium">Date</p>
                  <p className="text-sm text-muted-foreground">
                    {format(new Date(event.startDate), "PPP")}
                  </p>
                </div>
              </div>
              
              <div className="flex items-center space-x-2">
                <Clock className="h-5 w-5 text-muted-foreground" />
                <div className="space-y-1">
                  <p className="font-medium">Time</p>
                  <p className="text-sm text-muted-foreground">
                    {format(new Date(event.startDate), "p")} - {format(new Date(event.endDate), "p")}
                  </p>
                </div>
              </div>
            </div>

            <div className="space-y-4">
              <div className="flex items-center space-x-2">
                <MapPin className="h-5 w-5 text-muted-foreground" />
                <div className="space-y-1">
                  <p className="font-medium">Location</p>
                  <p className="text-sm text-muted-foreground">
                    {event.location.venue}<br />
                    {event.location.address}
                  </p>
                </div>
              </div>
              
              <div className="flex items-center space-x-2">
                <Users className="h-5 w-5 text-muted-foreground" />
                <div className="space-y-1">
                  <p className="font-medium">Capacity</p>
                  <p className="text-sm text-muted-foreground">
                    {event.attendees?.confirmed || 0} confirmed / {event.capacity} maximum
                  </p>
                </div>
              </div>
            </div>
          </div>
        </Card>

        {/* Guest List */}
        <Card className="p-6 h-full">
          <h2 className="text-xl font-semibold mb-4">Guest List</h2>
          <Separator className="mb-4" />
          <GuestList eventId={event.id} />
        </Card>
      </div>

      {/* Chat Section */}
      <Card className="p-6">
        <div className="flex items-center justify-between mb-4">
          <h2 className="text-xl font-semibold">Event Discussion</h2>
          <Button variant="outline" size="sm">
            <MessageCircle className="h-4 w-4 mr-2" />
            Chat Settings
          </Button>
        </div>
        <Separator className="mb-4" />
        <EventChat eventId={event.id} />
        <AdUnit 
              slot="30002"
              format="vertical"
              style={{ 
                position: "sticky",
                top: "2rem",
                minHeight: "100px",
                width: "400px",
                margin: "0 auto",
                display: "flex"
              }}
        />
      </Card>

      {/* Share Dialog */}
      <Dialog>
        <DialogTrigger asChild>
          <Button variant="outline" className="fixed bottom-4 right-4">
            <Share2 className="h-4 w-4 mr-2" />
            Share Event
          </Button>
        </DialogTrigger>
        <DialogContent>
          <DialogHeader>
            <DialogTitle>Share Event</DialogTitle>
            <DialogDescription>
              Share this event with your network
            </DialogDescription>
          </DialogHeader>
          <ShareEvent event={event} />
        </DialogContent>
      </Dialog>
    </div>
  );
}

================
File: src/app/(dashboard)/events/new/page.tsx
================
// src/app/(dashboard)/events/new/page.tsx
import { auth } from "@clerk/nextjs/server";
import { redirect } from "next/navigation";
import { Card } from "@/components/ui/card";
import { EventForm } from "@/components/events/event-form";

export default async function NewEventPage() {
  const { userId } = await auth();
  if (!userId) {
    redirect("/sign-in");
  }

  return (
    <div className="max-w-4xl mx-auto space-y-4">
      <div className="space-y-2">
        <h1 className="text-3xl font-bold">Create New Event</h1>
        <p className="text-muted-foreground">
          Fill in the details below to create your event.
        </p>
      </div>

      <Card className="p-6">
        <EventForm />
      </Card>
    </div>
  );
}

================
File: src/app/(dashboard)/events/loading.tsx
================
import { Skeleton } from "@/components/ui/skeleton";

export default function EventsLoading() {
  return (
    <div className="space-y-6">
      <div className="flex items-center justify-between">
        <Skeleton className="h-8 w-32" />
        <Skeleton className="h-10 w-28" />
      </div>
      <div className="grid gap-6 md:grid-cols-2 lg:grid-cols-3">
        {Array.from({ length: 6 }).map((_, i) => (
          <Skeleton key={i} className="h-[200px] rounded-lg" />
        ))}
      </div>
    </div>
  );
}

================
File: src/app/(dashboard)/events/page.tsx
================
import { auth } from "@clerk/nextjs/server";
import { redirect } from "next/navigation";
import Link from "next/link";
import { Plus } from "lucide-react";
import { Button } from "@/components/ui/button";
import { EventCard } from "@/components/events/event-card";
import dbConnect from "@/lib/db/connection";
import { Event as EventModel } from "@/lib/db/models/event";
import AdUnit from "@/components/ads/AdUnit";

// Define the Event interface
interface Event {
  id: string;
  title: string;
  description: string;
  startDate: Date;
  endDate: Date;
  location: {
    venue: string;
    address: string;
    coordinates?: {
      lat: number;
      lng: number;
    };
  };
  capacity: number;
  status: "draft" | "published" | "cancelled";
  visibility: "public" | "private";
  organizerId: string;
  coHosts: string[];
  createdAt: Date;
  updatedAt: Date;
}

// Define the MongoDB document interface
interface EventDocument {
  _id: any;
  title: string;
  description: string;
  startDate: Date;
  endDate: Date;
  location: {
    venue: string;
    address: string;
    coordinates?: {
      lat: number;
      lng: number;
    };
  };
  capacity: number;
  status: "draft" | "published" | "cancelled";
  visibility: "public" | "private";
  organizerId: string;
  coHosts: string[];
  createdAt: Date;
  updatedAt: Date;
}

async function getEvents(userId: string): Promise<Event[]> {
  try {
    await dbConnect();
    const events = await EventModel.find({ organizerId: userId })
      .sort({ createdAt: -1 })
      .lean() as EventDocument[];

    return events.map(event => ({
      id: event._id.toString(),
      title: event.title,
      description: event.description,
      startDate: new Date(event.startDate),
      endDate: new Date(event.endDate),
      location: event.location,
      capacity: event.capacity,
      status: event.status,
      visibility: event.visibility,
      organizerId: event.organizerId,
      coHosts: event.coHosts,
      createdAt: new Date(event.createdAt),
      updatedAt: new Date(event.updatedAt)
    }));
  } catch (error) {
    console.error("Error fetching events:", error);
    return [];
  }
}

export default async function EventsPage() {
  const { userId } = await auth();
  if (!userId) redirect("/sign-in");

  const events = await getEvents(userId);

  return (
    
    <div className="space-y-6">
      
      <div className="flex items-center justify-between">
        <h1 className="text-3xl font-bold">Events</h1>
        <Button asChild>
          <Link href="/events/new">
            <Plus className="mr-2 h-4 w-4" />
            Create Event
          </Link>
        </Button>
      </div>     

      {events.length === 0 ? (
        <div className="flex flex-col items-center justify-center h-[60vh] space-y-4">
          <p className="text-muted-foreground">No events found</p>
          <Button asChild>
            <Link href="/events/new">Create your first event</Link>
          </Button>
        </div>
      ) : (
        <div className="grid gap-6 md:grid-cols-2 lg:grid-cols-2">
          {events.map((event) => (
            <EventCard key={event.id} event={event} />
          ))}          
        </div>
              
      )}
      <div className="xl:block item-center justify-items-center justify-center shrink-0">
            <AdUnit 
              slot="30002"
              format="vertical"
              style={{ 
                position: "sticky",
                top: "2rem",
                minHeight: "100px",
                width: "400px",
                margin: "0 auto",
                display: "flex"
              }}
            />
      </div>      
    </div>
  );
}

================
File: src/app/(dashboard)/layout.tsx
================
import { Navbar } from "@/components/layout/navbar";
import { initialProfile } from "@/lib/auth";

export default async function DashboardLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  await initialProfile();

  return (
    <div className="h-full">
      <Navbar />
      <main className="container mx-auto h-full py-6">{children}</main>
    </div>
  );
}

================
File: src/app/api/activities/route.ts
================
import { NextRequest, NextResponse } from "next/server";
import { auth } from "@clerk/nextjs/server";
import { clerkClient } from "@clerk/clerk-sdk-node"; 
import dbConnect from "@/lib/db/connection";
import { Activity } from "@/lib/db/models/activity";

export async function GET(req: NextRequest) {
  try {
    const { userId } = await auth();
    if (!userId) {
      return new NextResponse("Unauthorized", { status: 401 });
    }

    await dbConnect();

    // Get query parameters
    const { searchParams } = new URL(req.url);
    const limit = parseInt(searchParams.get("limit") || "20");
    const before = searchParams.get("before");
    const eventId = searchParams.get("eventId");
    const type = searchParams.get("type");

    // Build query
    let query: any = {};
    if (before) {
      query.createdAt = { $lt: new Date(before) };
    }
    if (eventId) {
      query.eventId = eventId;
    }
    if (type) {
      query.type = type;
    }

    // Fetch activities
    const activities = await Activity
      .find(query)
      .sort({ createdAt: -1 })
      .limit(limit);

    // Fetch user details from Clerk
    const userIds = Array.from(new Set(activities.map(a => a.userId)));
    const userDetails = new Map<string, any>();

    // In a real app, you would batch fetch users from Clerk
    // This is a simplified version
    for (const id of userIds) {
      try {
        const user = await clerkClient.users.getUser(userId);
        userDetails.set(id, {
          name: `${user.firstName} ${user.lastName}`,
          email: user.emailAddresses[0]?.emailAddress,
          avatar: user.imageUrl,
        });
      } catch (error) {
        console.error(`Error fetching user ${id}:`, error);
      }
    }

    // Enrich activities with user details
    const enrichedActivities = activities.map(activity => ({
      ...activity.toObject(),
      id: activity._id.toString(),
      user: userDetails.get(activity.userId) || null,
    }));

    return NextResponse.json(enrichedActivities);
  } catch (error) {
    console.error("Error fetching activities:", error);
    return new NextResponse("Internal Error", { status: 500 });
  }
}

================
File: src/app/api/events/[eventId]/activities/route.ts
================
// src/app/api/events/[eventId]/activities/route.ts
import { NextRequest, NextResponse } from "next/server";
import { auth } from "@clerk/nextjs/server";
import dbConnect from "@/lib/db/connection";
import { Activity } from "@/lib/db/models/activity";

export async function GET(
  req: NextRequest,
  { params }: { params: { eventId: string } }
) {
  try {
    const { userId } = await auth();
    if (!userId) {
      return new NextResponse("Unauthorized", { status: 401 });
    }

    await dbConnect();
    const { searchParams } = new URL(req.url);
    const limit = parseInt(searchParams.get("limit") || "20");
    const before = searchParams.get("before");

    let query: any = { eventId: params.eventId };
    if (before) {
      query.createdAt = { $lt: new Date(before) };
    }

    const activities = await Activity
      .find(query)
      .sort({ createdAt: -1 })
      .limit(limit)
      .populate('userId', 'name avatar');

    return NextResponse.json(activities);
  } catch (error) {
    console.error("Error fetching activities:", error);
    return new NextResponse("Internal Error", { status: 500 });
  }
}

================
File: src/app/api/events/[eventId]/chat/[messageId]/route.ts
================
import { NextRequest, NextResponse } from "next/server";
import { auth } from "@clerk/nextjs/server";
import dbConnect from "@/lib/db/connection";
import { Message } from "@/lib/db/models/message";
import { Event } from "@/lib/db/models/event";
import { Guest } from "@/lib/db/models/guest";

// GET a single message
export async function GET(
  req: NextRequest,
  { params }: { params: { eventId: string; messageId: string } }
) {
  try {
    const { userId } = await auth();
    if (!userId) {
      return new NextResponse("Unauthorized", { status: 401 });
    }

    await dbConnect();

    // Check if user has access to the event
    const guest = await Guest.findOne({
      eventId: params.eventId,
      userId,
      status: { $in: ["confirmed", "checked_in"] }
    });

    if (!guest) {
      return new NextResponse("Unauthorized", { status: 401 });
    }

    const message = await Message.findById(params.messageId)
      .populate('senderId', 'name avatar')
      .lean();

    if (!message) {
      return new NextResponse("Message not found", { status: 404 });
    }

    return NextResponse.json(message);
  } catch (error) {
    console.error("Error fetching message:", error);
    return new NextResponse("Internal Error", { status: 500 });
  }
}

// PATCH update a message
export async function PATCH(
  req: NextRequest,
  { params }: { params: { eventId: string; messageId: string } }
) {
  try {
    const { userId } = await auth();
    if (!userId) {
      return new NextResponse("Unauthorized", { status: 401 });
    }

    await dbConnect();

    const message = await Message.findById(params.messageId);
    if (!message) {
      return new NextResponse("Message not found", { status: 404 });
    }

    // Check if user is the message sender
    if (message.senderId.toString() !== userId) {
      return new NextResponse("Unauthorized", { status: 401 });
    }

    const data = await req.json();
    const updatedMessage = await Message.findByIdAndUpdate(
      params.messageId,
      {
        $set: {
          content: data.content,
          edited: true,
          updatedAt: new Date()
        }
      },
      { new: true }
    ).populate('senderId', 'name avatar');

    return NextResponse.json(updatedMessage);
  } catch (error) {
    console.error("Error updating message:", error);
    return new NextResponse("Internal Error", { status: 500 });
  }
}

// DELETE a message
export async function DELETE(
  req: NextRequest,
  { params }: { params: { eventId: string; messageId: string } }
) {
  try {
    const { userId } = await auth();
    if (!userId) {
      return new NextResponse("Unauthorized", { status: 401 });
    }

    await dbConnect();

    // Check if user has permission to delete the message
    const [message, event] = await Promise.all([
      Message.findById(params.messageId),
      Event.findById(params.eventId)
    ]);

    if (!message) {
      return new NextResponse("Message not found", { status: 404 });
    }

    // Allow deletion if user is:
    // 1. The message sender
    // 2. The event organizer
    // 3. A co-host of the event
    const isMessageSender = message.senderId.toString() === userId;
    const isOrganizer = event?.organizerId === userId;
    const isCoHost = event?.coHosts?.includes(userId);

    if (!isMessageSender && !isOrganizer && !isCoHost) {
      return new NextResponse("Unauthorized", { status: 401 });
    }

    await Message.findByIdAndDelete(params.messageId);

    return new NextResponse(null, { status: 204 });
  } catch (error) {
    console.error("Error deleting message:", error);
    return new NextResponse("Internal Error", { status: 500 });
  }
}

================
File: src/app/api/events/[eventId]/chat/route.ts
================
import { NextRequest, NextResponse } from "next/server";
import { auth } from "@clerk/nextjs/server";
import dbConnect from "@/lib/db/connection";
import { Message } from "@/lib/db/models/message";
import { Event } from "@/lib/db/models/event";
import { Guest } from "@/lib/db/models/guest";
import { pusherServer } from "@/lib/pusher";

export async function GET(
  req: NextRequest,
  { params }: { params: { eventId: string } }
) {
  try {
    await dbConnect();
    const { searchParams } = new URL(req.url);
    const before = searchParams.get("before");
    const limit = parseInt(searchParams.get("limit") || "50");

    let query: any = { eventId: params.eventId };
    if (before) {
      query.createdAt = { $lt: new Date(before) };
    }

    const messages = await Message.find(query)
      .sort({ createdAt: -1 })
      .limit(limit)
      .populate('senderId', 'name avatar');

    return NextResponse.json(messages);
  } catch (error) {
    console.error("Error fetching messages:", error);
    return new NextResponse("Internal Error", { status: 500 });
  }
}

export async function POST(
  req: NextRequest,
  { params }: { params: { eventId: string } }
) {
  try {
    const { userId } = await auth();
    if (!userId) {
      return new NextResponse("Unauthorized", { status: 401 });
    }

    await dbConnect();
    const data = await req.json();

    // Check if user is part of the event
    const guest = await Guest.findOne({
      eventId: params.eventId,
      userId,
      status: { $in: ["confirmed", "checked_in"] }
    });

    if (!guest) {
      return new NextResponse("Unauthorized", { status: 401 });
    }

    const message = await Message.create({
      ...data,
      eventId: params.eventId,
      senderId: userId
    });

    // Broadcast message via Pusher
    await pusherServer.trigger(
      `event-${params.eventId}`,
      "new-message",
      {
        ...message.toJSON(),
        sender: {
          id: userId,
          name: data.senderName,
          avatar: data.senderAvatar
        }
      }
    );

    return NextResponse.json(message);
  } catch (error) {
    console.error("Error sending message:", error);
    return new NextResponse("Internal Error", { status: 500 });
  }
}

================
File: src/app/api/events/[eventId]/check-in/route.ts
================
import { NextRequest, NextResponse } from "next/server";
import { auth } from "@clerk/nextjs/server";
import dbConnect from "@/lib/db/connection";
import { Guest } from "@/lib/db/models/guest";
import { createActivity } from "@/lib/activity/notifications";

export async function POST(
  req: NextRequest,
  { params }: { params: { eventId: string } }
) {
  try {
    const { userId } = await auth();
    if (!userId) {
      return new NextResponse("Unauthorized", { status: 401 });
    }

    await dbConnect();
    const { guestId } = await req.json();

    const guest = await Guest.findOne({
      _id: guestId,
      eventId: params.eventId
    });

    if (!guest) {
      return new NextResponse("Guest not found", { status: 404 });
    }

    if (guest.checkedIn) {
      return new NextResponse("Guest already checked in", { status: 400 });
    }

    guest.checkedIn = true;
    guest.checkedInAt = new Date();
    await guest.save();

    // Create activity log
    await createActivity({
      type: "guest.checked_in",
      userId,
      eventId: params.eventId,
      metadata: {
        guestId: guest._id,
        guestName: guest.name
      }
    });

    return NextResponse.json(guest);
  } catch (error) {
    console.error("Error checking in guest:", error);
    return new NextResponse("Internal Error", { status: 500 });
  }
}

================
File: src/app/api/events/[eventId]/export/route.ts
================
import { NextRequest, NextResponse } from "next/server";
import { auth } from "@clerk/nextjs/server";
import dbConnect from "@/lib/db/connection";
import { Event } from "@/lib/db/models/event";
import { Guest } from "@/lib/db/models/guest";
import { createObjectCsvStringifier } from "csv-writer";

export async function GET(
  req: NextRequest,
  { params }: { params: { eventId: string } }
) {
  try {
    const { userId } = await auth();
    if (!userId) {
      return new NextResponse("Unauthorized", { status: 401 });
    }

    await dbConnect();
    const event = await Event.findById(params.eventId);
    
    if (!event) {
      return new NextResponse("Event not found", { status: 404 });
    }

    if (event.organizerId !== userId && !event.coHosts.includes(userId)) {
      return new NextResponse("Unauthorized", { status: 401 });
    }

    const guests = await Guest.find({ eventId: params.eventId });

    const csvStringifier = createObjectCsvStringifier({
      header: [
        { id: 'name', title: 'Name' },
        { id: 'email', title: 'Email' },
        { id: 'status', title: 'Status' },
        { id: 'checkedIn', title: 'Checked In' },
        { id: 'checkedInAt', title: 'Check-in Time' },
        { id: 'dietaryPreferences', title: 'Dietary Preferences' }
      ]
    });

    const records = guests.map(guest => ({
      name: guest.name,
      email: guest.email,
      status: guest.status,
      checkedIn: guest.checkedIn ? 'Yes' : 'No',
      checkedInAt: guest.checkedInAt ? new Date(guest.checkedInAt).toLocaleString() : '',
      dietaryPreferences: guest.dietaryPreferences?.join(', ') || ''
    }));

    const csv = csvStringifier.getHeaderString() + csvStringifier.stringifyRecords(records);

    return new NextResponse(csv, {
      headers: {
        'Content-Type': 'text/csv',
        'Content-Disposition': `attachment; filename="event-${event.title}-guests.csv"`
      }
    });
  } catch (error) {
    console.error("Error exporting event data:", error);
    return new NextResponse("Internal Error", { status: 500 });
  }
}

================
File: src/app/api/events/[eventId]/guests/[guestId]/route.ts
================
// src/app/api/events/[eventId]/guests/[guestId]/route.ts
import { NextRequest, NextResponse } from "next/server";
import { auth } from "@clerk/nextjs/server";
import dbConnect from "@/lib/db/connection";
import { Event } from "@/lib/db/models/event";  // Add this import
import { Guest } from "@/lib/db/models/guest";
import { ActivityTypes, createActivity } from "@/lib/activity/notifications";

// Type for the update request body
interface UpdateGuestRequest {
  status?: "confirmed" | "declined" | "waitlist" | "invited";
  role?: "attendee" | "coHost" | "moderator";
  checkedIn?: boolean;
  dietaryPreferences?: string[];
  notes?: string;
}

export async function PATCH(
  req: NextRequest,
  { params }: { params: { eventId: string; guestId: string } }
) {
  try {
    const { userId } = await auth();
    if (!userId) {
      return new NextResponse("Unauthorized", { status: 401 });
    }

    await dbConnect();
    const data = await req.json() as UpdateGuestRequest;

    // Validate the update data
    const allowedFields = [
      "status",
      "role",
      "checkedIn",
      "dietaryPreferences",
      "notes"
    ];
    const updateData = Object.fromEntries(
      Object.entries(data).filter(([key]) => allowedFields.includes(key))
    );

    // Find guest
    const guest = await Guest.findById(params.guestId);
    if (!guest) {
      return new NextResponse("Guest not found", { status: 404 });
    }

    // Find event
    const event = await Event.findById(params.eventId);
    if (!event) {
      return new NextResponse("Event not found", { status: 404 });
    }

    // Check permissions
    const canUpdate = 
      event.organizerId === userId || 
      event.coHosts.includes(userId) || 
      guest.userId === userId;

    if (!canUpdate) {
      return new NextResponse("Unauthorized", { status: 401 });
    }

    // Update guest with validation
    const updatedGuest = await Guest.findByIdAndUpdate(
      params.guestId,
      { 
        ...updateData,
        ...(updateData.checkedIn && { checkedInAt: new Date() })
      },
      { 
        new: true,
        runValidators: true 
      }
    );

    // Create activity log
    await createActivity({
      type: ActivityTypes.GUEST_UPDATED,
      userId,
      eventId: params.eventId,
      metadata: {
        guestId: params.guestId,
        updates: Object.keys(updateData).join(", ")
      }
    });

    return NextResponse.json(updatedGuest);
  } catch (error) {
    console.error("Error updating guest:", error);
    if (error instanceof Error) {
      return new NextResponse(error.message, { status: 400 });
    }
    return new NextResponse("Internal Error", { status: 500 });
  }
}

export async function DELETE(
  req: NextRequest,
  { params }: { params: { eventId: string; guestId: string } }
) {
  try {
    const { userId } = await auth();
    if (!userId) {
      return new NextResponse("Unauthorized", { status: 401 });
    }

    await dbConnect();

    // Find event and check permissions
    const event = await Event.findById(params.eventId);
    if (!event) {
      return new NextResponse("Event not found", { status: 404 });
    }

    // Only organizers and co-hosts can remove guests
    if (event.organizerId !== userId && !event.coHosts.includes(userId)) {
      return new NextResponse("Unauthorized", { status: 401 });
    }

    // Find and delete guest
    const guest = await Guest.findById(params.guestId);
    if (!guest) {
      return new NextResponse("Guest not found", { status: 404 });
    }

    await Guest.findByIdAndDelete(params.guestId);

    // Create activity log
    await createActivity({
      type: ActivityTypes.GUEST_REMOVED,
      userId,
      eventId: params.eventId,
      metadata: { 
        guestId: params.guestId,
        guestEmail: guest.email // Include email for reference
      }
    });

    // Return success with no content
    return new NextResponse(null, { status: 204 });
  } catch (error) {
    console.error("Error removing guest:", error);
    if (error instanceof Error) {
      return new NextResponse(error.message, { status: 400 });
    }
    return new NextResponse("Internal Error", { status: 500 });
  }
}

================
File: src/app/api/events/[eventId]/guests/route.ts
================
// src/app/api/events/[eventId]/guests/route.ts
import { NextRequest, NextResponse } from "next/server";
import { auth } from "@clerk/nextjs/server";
import dbConnect from "@/lib/db/connection";
import { Event } from "@/lib/db/models/event";
import { Guest } from "@/lib/db/models/guest";
import { sendEventInvitation } from "@/lib/email/notifications";
import { createActivity } from "@/lib/activity/notifications";
import { formatDateTime } from "@/lib/email/notifications";

export async function GET(
  req: NextRequest,
  { params }: { params: { eventId: string } }
) {
  try {
    await dbConnect();
    const { searchParams } = new URL(req.url);
    const status = searchParams.get("status");
    const search = searchParams.get("search");

    let query: any = { eventId: params.eventId };
    if (status) query.status = status;
    if (search) {
      query.$or = [
        { name: { $regex: search, $options: "i" } },
        { email: { $regex: search, $options: "i" } }
      ];
    }

    const guests = await Guest.find(query).sort({ createdAt: -1 });
    return NextResponse.json(guests);
  } catch (error) {
    console.error("Error fetching guests:", error);
    return new NextResponse("Internal Error", { status: 500 });
  }
}

export async function POST(
  req: NextRequest,
  { params }: { params: { eventId: string } }
) {
  try {
    const { userId } = await auth();
    if (!userId) {
      return new NextResponse("Unauthorized", { status: 401 });
    }

    await dbConnect();
    const data = await req.json();
    const event = await Event.findById(params.eventId);

    if (!event) {
      return new NextResponse("Event not found", { status: 404 });
    }

    // Check if user has permission to invite
    if (event.organizerId !== userId && !event.coHosts.includes(userId)) {
      return new NextResponse("Unauthorized", { status: 401 });
    }

    // Format event date and time
    const { formattedDate, formattedTime } = formatDateTime(new Date(event.startDate));

    // Handle batch invitations
    const emails = Array.isArray(data.email) ? data.email : [data.email];
    const results = await Promise.all(
      emails.map(async (email: string) => {
        // Check if guest already exists
        const existingGuest = await Guest.findOne({
          eventId: params.eventId,
          email
        });

        if (existingGuest) {
          return {
            email,
            status: "already_invited"
          };
        }

        // Create new guest
        const guest = await Guest.create({
          eventId: params.eventId,
          email,
          status: "invited",
          role: data.role || "attendee",
          invitedBy: userId
        });

        // Send invitation email with properly formatted params
        await sendEventInvitation({
          recipientEmail: email,
          eventTitle: event.title,
          eventDate: formattedDate,
          eventTime: formattedTime,
          location: `${event.location.venue}, ${event.location.address}`,
          eventUrl: `${process.env.NEXT_PUBLIC_APP_URL}/events/${event.id}`,
          personalMessage: data.message
        });

        // Create activity
        await createActivity({
          type: "guest.invited",
          userId,
          eventId: params.eventId,
          metadata: { guestEmail: email }
        });

        return {
          email,
          status: "invited",
          guestId: guest._id
        };
      })
    );

    return NextResponse.json(results);
  } catch (error) {
    console.error("Error inviting guests:", error);
    return new NextResponse("Internal Error", { status: 500 });
  }
}

================
File: src/app/api/events/[eventId]/invite/route.ts
================
// src/app/api/events/[eventId]/invite/route.ts
import { NextRequest, NextResponse } from "next/server";
import { auth } from "@clerk/nextjs/server";
import dbConnect from "@/lib/db/connection";
import { Event } from "@/lib/db/models/event";
import { Guest } from "@/lib/db/models/guest";
import { sendEventInvitation } from "@/lib/email/notifications";

interface InviteRequestBody {
  emails: string[];
  message?: string;
}

export async function POST(
  req: NextRequest,
  { params }: { params: { eventId: string } }
) {
  try {
    const { userId } = await auth();
    if (!userId) {
      return new NextResponse("Unauthorized", { status: 401 });
    }

    const { emails, message } = await req.json() as InviteRequestBody;

    // Validate request body
    if (!Array.isArray(emails) || emails.length === 0) {
      return new NextResponse("Invalid email addresses", { status: 400 });
    }

    // Connect to database
    await dbConnect();

    // Get event details
    const event = await Event.findById(params.eventId);
    if (!event) {
      return new NextResponse("Event not found", { status: 404 });
    }

    // Check if user is authorized to send invites
    if (event.organizerId !== userId && !event.coHosts.includes(userId)) {
      return new NextResponse("Unauthorized", { status: 401 });
    }

    // Create invitations and send emails
    const inviteResults = await Promise.allSettled(
      emails.map(async (email) => {
        try {
          // Check if guest already exists
          const existingGuest = await Guest.findOne({
            eventId: params.eventId,
            email: email.toLowerCase(),
          });

          if (existingGuest) {
            return {
              email,
              status: "already_invited",
            };
          }

          // Create new guest
          const guest = await Guest.create({
            eventId: params.eventId,
            email: email.toLowerCase(),
            status: "invited",
            role: "attendee",
            invitedBy: userId,
            invitedAt: new Date(),
          });

          // Format date and time for email
          const startDate = new Date(event.startDate);
          const formattedDate = startDate.toLocaleDateString('en-US', {
            weekday: 'long',
            year: 'numeric',
            month: 'long',
            day: 'numeric',
          });
          const formattedTime = startDate.toLocaleTimeString('en-US', {
            hour: 'numeric',
            minute: '2-digit',
            hour12: true,
          });

          // Send invitation email
          await sendEventInvitation({
            recipientEmail: email,
            eventTitle: event.title,
            eventDate: formattedDate,
            eventTime: formattedTime,
            location: `${event.location.venue}, ${event.location.address}`,
            eventUrl: `${process.env.NEXT_PUBLIC_APP_URL}/events/${event.id}`,
            personalMessage: message,
          });

          return {
            email,
            status: "invited",
            guestId: guest._id,
          };
        } catch (error) {
          console.error(`Error inviting ${email}:`, error);
          return {
            email,
            status: "failed",
            error: error instanceof Error ? error.message : "Unknown error",
          };
        }
      })
    );

    // Process results
    const results = inviteResults.map((result) => {
      if (result.status === "fulfilled") {
        return result.value;
      } else {
        return {
          email: "unknown",
          status: "failed",
          error: result.reason?.message || "Failed to process invitation",
        };
      }
    });

    // Check if any invitations were successful
    const successfulInvites = results.filter(
      (result) => result.status === "invited"
    );

    if (successfulInvites.length === 0) {
      return new NextResponse(
        JSON.stringify({
          message: "No invitations were sent successfully",
          results,
        }),
        { status: 400 }
      );
    }

    return new NextResponse(
      JSON.stringify({
        message: `Successfully sent ${successfulInvites.length} invitation(s)`,
        results,
      }),
      { status: 200 }
    );

  } catch (error) {
    console.error("Error sending invitations:", error);
    return new NextResponse(
      JSON.stringify({
        error: "Failed to send invitations",
        details: error instanceof Error ? error.message : "Unknown error",
      }),
      { status: 500 }
    );
  }
}

// a GET route to check invitation status
export async function GET(
  req: NextRequest,
  { params }: { params: { eventId: string } }
) {
  try {
    const { userId } = await auth();
    if (!userId) {
      return new NextResponse("Unauthorized", { status: 401 });
    }

    await dbConnect();

    const event = await Event.findById(params.eventId);
    if (!event) {
      return new NextResponse("Event not found", { status: 404 });
    }

    // Check authorization
    if (event.organizerId !== userId && !event.coHosts.includes(userId)) {
      return new NextResponse("Unauthorized", { status: 401 });
    }

    // Get all invitations for this event
    const guests = await Guest.find({ eventId: params.eventId })
      .select('email status invitedAt role checkedIn')
      .sort('-invitedAt');

    return NextResponse.json(guests);
  } catch (error) {
    console.error("Error fetching invitations:", error);
    return new NextResponse("Internal Error", { status: 500 });
  }
}

================
File: src/app/api/events/[eventId]/stats/route.ts
================
import { NextRequest, NextResponse } from "next/server";
import { auth } from "@clerk/nextjs/server";
import dbConnect from "@/lib/db/connection";
import { Event } from "@/lib/db/models/event";
import { Guest } from "@/lib/db/models/guest";

export async function GET(
  req: NextRequest,
  { params }: { params: { eventId: string } }
) {
  try {
    const { userId } = await auth();
    if (!userId) {
      return new NextResponse("Unauthorized", { status: 401 });
    }

    await dbConnect();

    const event = await Event.findById(params.eventId);
    if (!event) {
      return new NextResponse("Event not found", { status: 404 });
    }

    const [
      totalGuests,
      confirmedGuests,
      checkedInGuests,
      waitlistedGuests
    ] = await Promise.all([
      Guest.countDocuments({ eventId: params.eventId }),
      Guest.countDocuments({ eventId: params.eventId, status: "confirmed" }),
      Guest.countDocuments({ eventId: params.eventId, checkedIn: true }),
      Guest.countDocuments({ eventId: params.eventId, status: "waitlist" })
    ]);

    return NextResponse.json({
      total: totalGuests,
      confirmed: confirmedGuests,
      checkedIn: checkedInGuests,
      waitlisted: waitlistedGuests,
      capacity: event.capacity,
      fillRate: (confirmedGuests / event.capacity) * 100,
      checkInRate: (checkedInGuests / confirmedGuests) * 100
    });
  } catch (error) {
    console.error("Error fetching event stats:", error);
    return new NextResponse("Internal Error", { status: 500 });
  }
}

================
File: src/app/api/events/[eventId]/waitlist/route.ts
================
import { NextRequest, NextResponse } from "next/server";
import { auth } from "@clerk/nextjs/server";
import dbConnect from "@/lib/db/connection";
import { Event } from "@/lib/db/models/event";
import { Waitlist } from "@/lib/db/models/waitlist";
import { Guest } from "@/lib/db/models/guest";
import { ActivityTypes, createActivity } from "@/lib/activity/notifications";

export async function POST(
    req: NextRequest,
    { params }: { params: { eventId: string } }
  ) {
    try {
      const { userId } = await auth();
      if (!userId) {
        return new NextResponse("Unauthorized", { status: 401 });
      }
  
      await dbConnect();
      const event = await Event.findById(params.eventId);
  
      if (!event) {
        return new NextResponse("Event not found", { status: 404 });
      }
  
      // Check if waitlist is enabled
      if (!event.waitlist.enabled) {
        return new NextResponse("Waitlist not enabled for this event", { 
          status: 400 
        });
      }
  
      // Check if user is already registered or on waitlist
      const [existingGuest, existingWaitlist] = await Promise.all([
        Guest.findOne({ eventId: params.eventId, userId }),
        Waitlist.findOne({ eventId: params.eventId, userId })
      ]);
  
      if (existingGuest) {
        return new NextResponse("Already registered for event", { 
          status: 400 
        });
      }
  
      if (existingWaitlist) {
        return new NextResponse("Already on waitlist", { status: 400 });
      }
  
      // Get current waitlist position
      const lastPosition = await Waitlist.findOne({ 
        eventId: params.eventId 
      })
      .sort({ position: -1 })
      .select('position');
  
      const newPosition = lastPosition ? lastPosition.position + 1 : 1;
  
      // Check if waitlist is full
      if (event.waitlist.maxSize && newPosition > event.waitlist.maxSize) {
        return new NextResponse("Waitlist is full", { status: 400 });
      }
  
      // Add to waitlist
      const waitlistEntry = await Waitlist.create({
        eventId: params.eventId,
        userId,
        position: newPosition
      });
  
      // Create activity log with correct activity type
      await createActivity({
        type: ActivityTypes.GUEST_WAITLISTED,
        userId,
        eventId: params.eventId,
        metadata: { position: newPosition }
      });
  
      return NextResponse.json(waitlistEntry);
    } catch (error) {
      console.error("Error joining waitlist:", error);
      return new NextResponse("Internal Error", { status: 500 });
    }
}

// Get waitlist status
export async function GET(
  req: NextRequest,
  { params }: { params: { eventId: string } }
) {
  try {
    const { userId } = await auth();
    if (!userId) {
      return new NextResponse("Unauthorized", { status: 401 });
    }

    await dbConnect();
    const waitlistEntry = await Waitlist.findOne({
      eventId: params.eventId,
      userId
    });

    return NextResponse.json(waitlistEntry || null);
  } catch (error) {
    console.error("Error getting waitlist status:", error);
    return new NextResponse("Internal Error", { status: 500 });
  }
}

================
File: src/app/api/events/[eventId]/route.ts
================
import { NextRequest, NextResponse } from "next/server";
import dbConnect from "@/lib/db/connection";
import { Event } from "@/lib/db/models/event";
import { auth } from "@clerk/nextjs/server";
import mongoose from "mongoose";

export async function GET(
  req: NextRequest,
  { params }: { params: { eventId: string } }
) {
  try {
    await dbConnect();

    // Validate ObjectId
    if (!mongoose.Types.ObjectId.isValid(params.eventId)) {
      return new NextResponse("Invalid event ID", { status: 400 });
    }

    const event = await Event.findById(params.eventId);

    if (!event) {
      return new NextResponse("Event not found", { status: 404 });
    }

    // Convert Mongoose document to a plain JavaScript object
    const eventObject = event;

    // Create a serializable version of the event
    const serializedEvent = {
      id: eventObject._id.toString(),
      title: eventObject.title,
      description: eventObject.description,
      startDate: eventObject.startDate.toISOString(),
      endDate: eventObject.endDate.toISOString(),
      location: {
        venue: eventObject.location?.venue || '',
        address: eventObject.location?.address || '',
        coordinates: eventObject.location?.coordinates || null,
      },
      capacity: eventObject.capacity,
      status: eventObject.status,
      visibility: eventObject.visibility,
      organizerId: eventObject.organizerId,
      coHosts: eventObject.coHosts || [],
      recurring: eventObject.recurring || null,
      createdAt: eventObject.createdAt.toISOString(),
      updatedAt: eventObject.updatedAt.toISOString(),
      attendees: {
        confirmed: 0, // You'll need to fetch these counts separately
        waitlist: 0,
      },
    };

    return NextResponse.json(serializedEvent);
  } catch (error) {
    console.error("Error fetching event:", error);
    return new NextResponse("Internal Error", { status: 500 });
  }
}

export async function PATCH(
  req: NextRequest,
  { params }: { params: { eventId: string } }
) {
  try {
    const { userId } = await auth();
    if (!userId) {
      return new NextResponse("Unauthorized", { status: 401 });
    }

    await dbConnect();
    const data = await req.json();
    const event = await Event.findById(params.eventId);

    if (!event) {
      return new NextResponse("Event not found", { status: 404 });
    }

    if (event.organizerId !== userId && !event.coHosts.includes(userId)) {
      return new NextResponse("Unauthorized", { status: 401 });
    }

    const updatedEvent = await Event.findByIdAndUpdate(
      params.eventId,
      { ...data },
      { new: true }
    );

    return NextResponse.json(updatedEvent);
  } catch (error) {
    console.error("Error updating event:", error);
    return new NextResponse("Internal Error", { status: 500 });
  }
}

export async function DELETE(
  req: NextRequest,
  { params }: { params: { eventId: string } }
) {
  try {
    const { userId } = await auth();
    if (!userId) {
      return new NextResponse("Unauthorized", { status: 401 });
    }

    await dbConnect();
    const event = await Event.findById(params.eventId);

    if (!event) {
      return new NextResponse("Event not found", { status: 404 });
    }

    if (event.organizerId !== userId) {
      return new NextResponse("Unauthorized", { status: 401 });
    }

    await Event.findByIdAndDelete(params.eventId);
    return new NextResponse(null, { status: 204 });
  } catch (error) {
    console.error("Error deleting event:", error);
    return new NextResponse("Internal Error", { status: 500 });
  }
}

================
File: src/app/api/events/recurring/route.ts
================
import { NextRequest, NextResponse } from "next/server";
import { auth } from "@clerk/nextjs/server";
import { addDays, addWeeks, addMonths, setDate } from "date-fns";
import dbConnect from "@/lib/db/connection";
import { Event } from "@/lib/db/models/event";

export async function POST(req: NextRequest) {
  try {
    const { userId } = await auth();
    if (!userId) {
      return new NextResponse("Unauthorized", { status: 401 });
    }

    await dbConnect();
    const data = await req.json();

    // Create base event
    const baseEvent = await Event.create({
      ...data,
      organizerId: userId
    });

    // Generate recurring instances if recurring is enabled
    if (data.recurring && data.recurring.pattern) {
      const instances = generateRecurringInstances(baseEvent);
      await Event.insertMany(instances);
    }

    return NextResponse.json(baseEvent);
  } catch (error) {
    console.error("Error creating recurring event:", error);
    return new NextResponse("Internal Error", { status: 500 });
  }
}

function generateRecurringInstances(baseEvent: any) {
  const instances = [];
  const { pattern, interval, endDate, daysOfWeek, dayOfMonth } = baseEvent.recurring;
  let currentDate = new Date(baseEvent.startDate);
  const duration = baseEvent.endDate.getTime() - baseEvent.startDate.getTime();

  while (currentDate <= new Date(endDate)) {
    // Skip the base event date
    if (currentDate.getTime() === baseEvent.startDate.getTime()) {
      currentDate = getNextDate(currentDate, pattern, interval);
      continue;
    }

    // Skip if date is in exceptions
    if (baseEvent.recurring.exceptions?.some((d: Date) => 
      d.getTime() === currentDate.getTime()
    )) {
      currentDate = getNextDate(currentDate, pattern, interval);
      continue;
    }

    // For weekly pattern, check if day is included
    if (pattern === "weekly" && daysOfWeek) {
      const dayOfWeek = currentDate.getDay();
      if (!daysOfWeek.includes(dayOfWeek)) {
        currentDate = addDays(currentDate, 1);
        continue;
      }
    }

    // For monthly pattern, check if it's the right day
    if (pattern === "monthly" && dayOfMonth) {
      if (currentDate.getDate() !== dayOfMonth) {
        currentDate = setDate(currentDate, dayOfMonth);
        continue;
      }
    }

    const instanceEndDate = new Date(currentDate.getTime() + duration);

    instances.push({
      ...baseEvent.toObject(),
      _id: undefined,
      startDate: currentDate,
      endDate: instanceEndDate,
      recurring: {
        ...baseEvent.recurring,
        originalEventId: baseEvent._id
      }
    });

    currentDate = getNextDate(currentDate, pattern, interval);
  }

  return instances;
}

function getNextDate(date: Date, pattern: string, interval: number): Date {
  switch (pattern) {
    case "daily":
      return addDays(date, interval);
    case "weekly":
      return addWeeks(date, interval);
    case "monthly":
      return addMonths(date, interval);
    default:
      return date;
  }
}

================
File: src/app/api/events/stats/charts/route.ts
================
import { NextRequest, NextResponse } from "next/server";
import { auth } from "@clerk/nextjs/server";
import dbConnect from "@/lib/db/connection";
import { Event } from "@/lib/db/models/event";
import { Guest } from "@/lib/db/models/guest";
import { startOfMonth, subMonths, format, startOfWeek, endOfWeek, subWeeks } from "date-fns";

export async function GET(req: NextRequest) {
  try {
    const { userId } = await auth();
    if (!userId) {
      return new NextResponse("Unauthorized", { status: 401 });
    }

    await dbConnect();
    const now = new Date();

    // Get last 6 months of attendance data
    const monthlyAttendance = await Promise.all(
      Array.from({ length: 6 }).map(async (_, index) => {
        const monthStart = startOfMonth(subMonths(now, 5 - index));
        const monthName = format(monthStart, 'MMM');

        const monthEvents = await Event.find({
          organizerId: userId,
          startDate: {
            $gte: monthStart,
            $lt: startOfMonth(subMonths(now, 4 - index))
          }
        });

        const eventIds = monthEvents.map(event => event._id);
        const totalCapacity = monthEvents.reduce((sum, event) => sum + event.capacity, 0);
        
        const attendees = await Guest.countDocuments({
          eventId: { $in: eventIds },
          status: "checked_in"
        });

        return {
          name: monthName,
          attendees,
          capacity: totalCapacity || 0
        };
      })
    );

    // Get last 4 weeks of registration data
    const weeklyRegistrations = await Promise.all(
      Array.from({ length: 4 }).map(async (_, index) => {
        const weekStart = startOfWeek(subWeeks(now, 3 - index));
        const weekEnd = endOfWeek(subWeeks(now, 3 - index));

        const registrations = await Guest.countDocuments({
          createdAt: { $gte: weekStart, $lt: weekEnd },
          eventId: {
            $in: await Event.find({ organizerId: userId }).distinct('_id')
          }
        });

        return {
          name: `Week ${index + 1}`,
          registrations
        };
      })
    );

    // Get event types distribution
    const events = await Event.find({ organizerId: userId });
    const eventTypes = events.reduce((acc: { [key: string]: number }, event) => {
      const type = event.type || 'Other';
      acc[type] = (acc[type] || 0) + 1;
      return acc;
    }, {});

    const eventTypeData = Object.entries(eventTypes).map(([name, value]) => ({
      name,
      value
    }));

    return NextResponse.json({
      attendanceData: monthlyAttendance,
      registrationData: weeklyRegistrations,
      eventTypeData
    });
  } catch (error) {
    console.error("Error fetching chart data:", error);
    return new NextResponse("Internal Error", { status: 500 });
  }
}

================
File: src/app/api/events/upcoming/route.ts
================
// src/app/api/events/upcoming/route.ts
import { NextRequest, NextResponse } from "next/server";
import { auth } from "@clerk/nextjs/server";
import dbConnect from "@/lib/db/connection";
import { Event } from "@/lib/db/models/event";
import { Guest } from "@/lib/db/models/guest";

export async function GET(req: NextRequest) {
  try {
    const { userId } = await auth();
    if (!userId) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    await dbConnect();

    const now = new Date();
    const thirtyDaysFromNow = new Date();
    thirtyDaysFromNow.setDate(now.getDate() + 30);

    // Fetch upcoming events
    const events = await Event.find({
      organizerId: userId,
      startDate: { $gte: now, $lte: thirtyDaysFromNow },
      status: { $ne: "cancelled" }
    })
    .sort({ startDate: 1 })
    .limit(5)
    .lean();

    // Get attendees count for each event
    const eventsWithAttendees = await Promise.all(
      events.map(async (event) => {
        const confirmedCount = await Guest.countDocuments({
          eventId: event._id,
          status: "confirmed"
        });

        const status = event.startDate > now 
          ? "upcoming"
          : event.endDate < now 
          ? "ended" 
          : "ongoing";

        return {
          id: event._id,
          title: event.title,
          description: event.description,
          startDate: event.startDate,
          endDate: event.endDate,
          location: {
            venue: event.location?.venue || 'No venue specified',
            address: event.location?.address || 'No address specified'
          },
          attendees: {
            confirmed: confirmedCount,
            total: event.capacity
          },
          status,
          visibility: event.visibility
        };
      })
    );

    return NextResponse.json({
      events: eventsWithAttendees,
      success: true
    });
  } catch (error) {
    console.error("Error fetching upcoming events:", error);
    return NextResponse.json(
      {
        error: "Failed to fetch upcoming events",
        success: false,
        details: process.env.NODE_ENV === 'development' ? error : undefined
      },
      { status: 500 }
    );
  }
}

================
File: src/app/api/events/route.ts
================
import { NextRequest, NextResponse } from "next/server";
import dbConnect from "@/lib/db/connection";
import { Event } from "@/lib/db/models/event";
import { auth } from "@clerk/nextjs/server";
import { revalidatePath } from "next/cache";
import { handleApiError, ApiError } from '@/lib/api/error-handler';
import { analyzeQueryPerformance } from '@/lib/db/utils/performance';

export async function POST(req: NextRequest) {
  try {
    const { userId } = await auth();
    if (!userId) {
      throw new ApiError('Unauthorized', 401, 'UNAUTHORIZED');
    }

    // Analyze query performance
    const queryPerformance = await analyzeQueryPerformance(Event, {
      organizerId: userId
    });
    console.log('Query Performance:', queryPerformance);

    await dbConnect();
    const data = await req.json();

    // Create the event and ensure we get the created document back
    const event = await Event.create({
      ...data,
      organizerId: userId,
      status: "draft",
      location: {
        venue: data.venue,
        address: data.address
      }
    });   

    // Convert the Mongoose document to a plain object and ensure _id is converted to id
    const eventObject = event.toObject();
    const responseEvent = {
      ...eventObject,
      id: eventObject._id.toString(),
    };

    revalidatePath("/events");
    revalidatePath("/dashboard");
    revalidatePath("/");

    return NextResponse.json(responseEvent);
  } catch (error) {
    console.error("Error creating event:", error);
    return handleApiError(error);    
  }
}

export async function GET(req: NextRequest) {
  try {
    await dbConnect();
    const { searchParams } = new URL(req.url);
    const status = searchParams.get("status");
    const organizerId = searchParams.get("organizerId");
    const { userId } = await auth();
    if (!userId) return new NextResponse("Unauthorized", { status: 401 });

    let query = {};
    if (status) query = { ...query, status };
    if (organizerId) query = { ...query, organizerId };

    // Analyze query performance
    const queryPerformance = await analyzeQueryPerformance(Event, {
      organizerId: userId
    });

    console.log('Query Performance:', queryPerformance);

    const events = await Event.find(query).sort({ createdAt: -1 }).limit(100);

    // Serialize the events
    const serializedEvents = events.map(event => {
      const eventObj = event.toObject();
      return {
        id: eventObj._id.toString(),
        title: eventObj.title,
        description: eventObj.description,
        startDate: eventObj.startDate.toISOString(),
        endDate: eventObj.endDate.toISOString(),
        location: {
          venue: eventObj.location?.venue || '',
          address: eventObj.location?.address || '',
        },
        capacity: eventObj.capacity,
        status: eventObj.status,
        visibility: eventObj.visibility,
        organizerId: eventObj.organizerId,
        coHosts: eventObj.coHosts || [],
      };
    });

    return NextResponse.json(serializedEvents);
  } catch (error) {
    console.error("Error fetching events:", error);
    return new NextResponse("Internal Error", { status: 500 });
  }
}

================
File: src/app/api/users/[userId]/route.ts
================
// src/app/api/users/[userId]/route.ts
import { NextRequest, NextResponse } from "next/server";
import { clerkClient } from "@clerk/clerk-sdk-node"; 
import { auth } from "@clerk/nextjs/server";

export async function GET(
  req: NextRequest,
  { params }: { params: { userId: string } }
) {
  try {
    const { userId: currentUserId } = await auth();
    if (!currentUserId) {
      return new NextResponse("Unauthorized", { status: 401 });
    }

    const user = await clerkClient.users.getUser(params.userId);

    return NextResponse.json({
      id: user.id,
      name: `${user.firstName} ${user.lastName}`,
      imageUrl: user.imageUrl,
      emailAddress: user.emailAddresses[0]?.emailAddress
    });
  } catch (error) {
    console.error("Error fetching user:", error);
    return new NextResponse("Internal Error", { status: 500 });
  }
}

================
File: src/app/api/webhooks/clerk/route.ts
================
import { Webhook } from 'svix';
import { headers } from 'next/headers';
import { WebhookEvent } from '@clerk/nextjs/server';
import { NextResponse } from 'next/server';
import dbConnect from '@/lib/db/connection';

export async function POST(req: Request) {
  const WEBHOOK_SECRET = process.env.WEBHOOK_SECRET;
  
  if (!WEBHOOK_SECRET) {
    throw new Error('Please add WEBHOOK_SECRET from Clerk Dashboard to .env file');
  }

  // Get the headers
  const headerPayload = headers();
  const svix_id = headerPayload.get("svix-id");
  const svix_timestamp = headerPayload.get("svix-timestamp");
  const svix_signature = headerPayload.get("svix-signature");

  // If there are no headers, error out
  if (!svix_id || !svix_timestamp || !svix_signature) {
    return new NextResponse('Error occured -- no svix headers', {
      status: 400
    });
  }

  // Get the body
  const payload = await req.json();
  const body = JSON.stringify(payload);

  // Create a new Svix instance with your secret
  const wh = new Webhook(WEBHOOK_SECRET);

  let evt: WebhookEvent;

  try {
    evt = wh.verify(body, {
      "svix-id": svix_id,
      "svix-timestamp": svix_timestamp,
      "svix-signature": svix_signature,
    }) as WebhookEvent;
  } catch (err) {
    console.error('Error verifying webhook:', err);
    return new NextResponse('Error occured', {
      status: 400
    });
  }

  // Handle the webhook
  const eventType = evt.type;
  
  try {
    await dbConnect();
    
    switch (eventType) {
      case 'user.created':
        // Handle user creation
        break;
      case 'user.updated':
        // Handle user update
        break;
      case 'user.deleted':
        // Handle user deletion
        break;
    }

    return NextResponse.json({
      success: true,
      message: `Webhook processed successfully`
    });
    
  } catch (error) {
    console.error('Error processing webhook:', error);
    return new NextResponse('Error processing webhook', { 
      status: 500 
    });
  }
}

================
File: src/app/api/mocks.ts
================
async function initMocks() {
    if (typeof window === 'undefined') {
      const { server } = await import('../../mocks/server');
      server.listen({ onUnhandledRequest: 'bypass' });
    } else {
      const { worker } = await import('../../mocks/browser');
      worker.start({ onUnhandledRequest: 'bypass' });
    }
}
  
export default initMocks;

================
File: src/app/error.tsx
================
'use client';

import { useEffect } from 'react';
import { Button } from "@/components/ui/button";
import * as Sentry from "@sentry/nextjs";

export default function Error({
  error,
  reset,
}: {
  error: Error & { digest?: string };
  reset: () => void;
}) {
  useEffect(() => {
    Sentry.captureException(error);
  }, [error]);

  return (
    <div className="flex h-screen flex-col items-center justify-center space-y-4">
      <h1 className="text-4xl font-bold">Something went wrong!</h1>
      <p className="text-muted-foreground">We apologize for the inconvenience.</p>
      <div className="flex space-x-4">
        <Button onClick={() => reset()}>Try again</Button>
        <Button variant="outline" asChild>
          <a href="/">Go Home</a>
        </Button>
      </div>
    </div>
  );
}

================
File: src/app/global-error.tsx
================
// src/app/global-error.tsx
'use client';

import * as Sentry from "@sentry/nextjs";
import { useEffect } from "react";

export default function GlobalError({
  error,
}: {
  error: Error & { digest?: string };
}) {
  useEffect(() => {
    Sentry.captureException(error);
  }, [error]);

  return (
    <html>
      <body>
        <div className="flex min-h-screen items-center justify-center">
          <div className="text-center">
            <h1 className="text-2xl font-bold">Something went wrong!</h1>
            <button
              className="mt-4 rounded bg-primary px-4 py-2 text-white"
              onClick={() => window.location.reload()}
            >
              Try again
            </button>
          </div>
        </div>
      </body>
    </html>
  );
}

================
File: src/app/globals.css
================
@tailwind base;
@tailwind components;
@tailwind utilities;
 
@layer base {
  :root {
    --background: 0 0% 100%;
    --foreground: 222.2 84% 4.9%;

    --card: 0 0% 100%;
    --card-foreground: 222.2 84% 4.9%;
 
    --popover: 0 0% 100%;
    --popover-foreground: 222.2 84% 4.9%;
 
    --primary: 222.2 47.4% 11.2%;
    --primary-foreground: 210 40% 98%;
 
    --secondary: 210 40% 96.1%;
    --secondary-foreground: 222.2 47.4% 11.2%;
 
    --muted: 210 40% 96.1%;
    --muted-foreground: 215.4 16.3% 46.9%;
 
    --accent: 210 40% 96.1%;
    --accent-foreground: 222.2 47.4% 11.2%;
 
    --destructive: 0 84.2% 60.2%;
    --destructive-foreground: 210 40% 98%;

    --border: 214.3 31.8% 91.4%;
    --input: 214.3 31.8% 91.4%;
    --ring: 222.2 84% 4.9%;
 
    --radius: 0.5rem;
 
    --chart-1: 12 76% 61%;
 
    --chart-2: 173 58% 39%;
 
    --chart-3: 197 37% 24%;
 
    --chart-4: 43 74% 66%;
 
    --chart-5: 27 87% 67%;
  }
 
  .dark {
    --background: 222.2 84% 4.9%;
    --foreground: 210 40% 98%;
 
    --card: 222.2 84% 4.9%;
    --card-foreground: 210 40% 98%;
 
    --popover: 222.2 84% 4.9%;
    --popover-foreground: 210 40% 98%;
 
    --primary: 210 40% 98%;
    --primary-foreground: 222.2 47.4% 11.2%;
 
    --secondary: 217.2 32.6% 17.5%;
    --secondary-foreground: 210 40% 98%;
 
    --muted: 217.2 32.6% 17.5%;
    --muted-foreground: 215 20.2% 65.1%;
 
    --accent: 217.2 32.6% 17.5%;
    --accent-foreground: 210 40% 98%;
 
    --destructive: 0 62.8% 30.6%;
    --destructive-foreground: 210 40% 98%;
 
    --border: 217.2 32.6% 17.5%;
    --input: 217.2 32.6% 17.5%;
    --ring: 212.7 26.8% 83.9%;
    --chart-1: 220 70% 50%;
    --chart-2: 160 60% 45%;
    --chart-3: 30 80% 55%;
    --chart-4: 280 65% 60%;
    --chart-5: 340 75% 55%;
  }
}
 
@layer base {
  * {
    @apply border-border;
  }
  body {
    @apply bg-background text-foreground;
  }
}

================
File: src/app/layout.tsx
================
import { ClerkProvider } from '@clerk/nextjs'
import { Inter } from 'next/font/google'
import type { Metadata } from 'next'
import { ThemeProvider } from '@/components/providers/theme-provider'
import { Toaster } from '@/components/ui/toaster'
import './globals.css'
import { ErrorBoundary } from 'react-error-boundary';
import { GlobalError } from '@/components/error-boundary/global-error';
import { AdSense } from "@/components/ads/AdSense";


const inter = Inter({ subsets: ['latin'] })

export const metadata: Metadata = {
  title: {
    default: 'Feest - Event Management Platform',
    template: '%s | Feest'
  },
  description: 'Professional event management platform for organizing and managing events',
  keywords: ['events', 'management', 'organization', 'planning'],
  authors: [{ name: 'user52' }],
  creator: 'Shareflyt',
  openGraph: {
    type: 'website',
    locale: 'en_US',
    url: 'https://your-domain.com',
    title: 'Feest - Event Management Platform',
    description: 'Professional event management platform for organizing and managing events',
    siteName: 'Feest'
  },
  twitter: {
    card: 'summary_large_image',
    title: 'Feest - Event Management Platform',
    description: 'Professional event management platform for organizing and managing events',
    creator: '@ch1pset4x'
  },
  robots: {
    index: true,
    follow: true
  }
};

export default function RootLayout({
  children,
}: {
  children: React.ReactNode
}) {  
  return (
    <ClerkProvider>
      <html lang="en" suppressHydrationWarning>
        <head>
        <AdSense publisherId={process.env.NEXT_PUBLIC_GOOGLE_ADS_CLIENT_ID!} />
        </head>
        <body className={inter.className}>
          <ThemeProvider
            attribute="class"
            defaultTheme="system"
            enableSystem
            disableTransitionOnChange
          >
            <ErrorBoundary 
              FallbackComponent={GlobalError}              
            >
              {children}
            </ErrorBoundary>
            <Toaster />
          </ThemeProvider>
        </body>
      </html>
    </ClerkProvider>
  )
}

================
File: src/app/not-found.tsx
================
import Link from "next/link";
import { Button } from "@/components/ui/button";

export default function NotFound() {
  return (
    <div className="flex h-screen flex-col items-center justify-center space-y-4">
      <h1 className="text-4xl font-bold">404</h1>
      <p className="text-muted-foreground">The page you're looking for doesn't exist.</p>
      <Button asChild>
        <Link href="/">Go Home</Link>
      </Button>
    </div>
  );
}

================
File: src/app/page.tsx
================
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import { ArrowRight, Calendar, Users, BarChart3, Zap, CheckCircle, Clock } from "lucide-react";
import Link from "next/link";

export default function LandingPage() {
  return (
    <div className="flex min-h-screen flex-col">
      {/* Hero Section */}
      <div className="flex flex-col items-center justify-center space-y-8 px-4 py-24 text-center lg:py-32">
        <Badge className="mb-4" variant="secondary">
          ✨ Your events, managed perfectly
        </Badge>
        <h1 className="text-3xl font-bold tracking-tighter sm:text-5xl md:text-6xl lg:text-7xl">
          Event Management
          <span className="block bg-gradient-to-r from-primary to-primary/50 bg-clip-text text-transparent">
            Made Simple
          </span>
        </h1>
        <p className="mx-auto max-w-[700px] text-muted-foreground md:text-xl">
          Create, manage, and host remarkable events. From intimate gatherings to
          grand conferences, we've got you covered.
        </p>
        <div className="flex flex-col gap-4 min-[400px]:flex-row">
          <Button asChild size="lg" className="gap-2">
            <Link href="/sign-up">
              Get Started <ArrowRight className="h-4 w-4" />
            </Link>
          </Button>
          <Button asChild size="lg" variant="outline">
            <Link href="/sign-in">
              Sign In
            </Link>
          </Button>
        </div>
      </div>

      {/* Features Grid */}
      <div className="container mx-auto grid gap-8 px-4 py-16 md:grid-cols-2 lg:grid-cols-3">
        <div className="group relative overflow-hidden rounded-lg border bg-background p-6 shadow-md transition-all hover:-translate-y-1 hover:shadow-lg">
          <div className="absolute inset-0 bg-gradient-to-r from-primary/10 to-transparent opacity-0 transition-opacity group-hover:opacity-100" />
          <Calendar className="mb-4 h-8 w-8 text-primary" />
          <h3 className="mb-2 font-semibold">Smart Scheduling</h3>
          <p className="text-sm text-muted-foreground">
            Intelligent calendar management with conflict detection and timezone support.
          </p>
        </div>

        <div className="group relative overflow-hidden rounded-lg border bg-background p-6 shadow-md transition-all hover:-translate-y-1 hover:shadow-lg">
          <div className="absolute inset-0 bg-gradient-to-r from-primary/10 to-transparent opacity-0 transition-opacity group-hover:opacity-100" />
          <Users className="mb-4 h-8 w-8 text-primary" />
          <h3 className="mb-2 font-semibold">Attendee Management</h3>
          <p className="text-sm text-muted-foreground">
            Seamlessly manage guest lists, RSVPs, and check-ins with real-time updates.
          </p>
        </div>

        <div className="group relative overflow-hidden rounded-lg border bg-background p-6 shadow-md transition-all hover:-translate-y-1 hover:shadow-lg">
          <div className="absolute inset-0 bg-gradient-to-r from-primary/10 to-transparent opacity-0 transition-opacity group-hover:opacity-100" />
          <BarChart3 className="mb-4 h-8 w-8 text-primary" />
          <h3 className="mb-2 font-semibold">Insightful Analytics</h3>
          <p className="text-sm text-muted-foreground">
            Comprehensive analytics and reporting to track event performance.
          </p>
        </div>
      </div>

      {/* Stats Section
      <div className="border-t bg-muted/40">
        <div className="container mx-auto px-4 py-16">
          <div className="grid gap-8 md:grid-cols-3">
            <div className="text-center">
              <div className="text-4xl font-bold">10K+</div>
              <div className="mt-2 text-sm text-muted-foreground">Events Hosted</div>
            </div>
            <div className="text-center">
              <div className="text-4xl font-bold">50K+</div>
              <div className="mt-2 text-sm text-muted-foreground">Happy Users</div>
            </div>
            <div className="text-center">
              <div className="text-4xl font-bold">99%</div>
              <div className="mt-2 text-sm text-muted-foreground">Satisfaction Rate</div>
            </div>
          </div>
        </div>
      </div> */}

      {/* Feature Highlights */}
      <div className="container mx-auto px-4 py-16">
        <div className="mx-auto max-w-2xl text-center">
          <h2 className="text-3xl font-bold tracking-tight sm:text-4xl">
            Everything you need to run successful events
          </h2>
          <p className="mt-4 text-muted-foreground">
            Powerful features to help you manage events of any size
          </p>
        </div>

        <div className="mt-16 grid gap-8 md:grid-cols-2">
          <div className="flex items-start gap-4">
            <div className="rounded-lg bg-primary/10 p-2">
              <Zap className="h-6 w-6 text-primary" />
            </div>
            <div>
              <h3 className="font-semibold">Real-time Updates</h3>
              <p className="mt-1 text-sm text-muted-foreground">
                Stay informed with instant notifications and live event updates.
              </p>
            </div>
          </div>

          <div className="flex items-start gap-4">
            <div className="rounded-lg bg-primary/10 p-2">
              <CheckCircle className="h-6 w-6 text-primary" />
            </div>
            <div>
              <h3 className="font-semibold">Easy Check-ins</h3>
              <p className="mt-1 text-sm text-muted-foreground">
                Streamlined check-in process with QR codes and mobile support.
              </p>
            </div>
          </div>

          <div className="flex items-start gap-4">
            <div className="rounded-lg bg-primary/10 p-2">
              <Clock className="h-6 w-6 text-primary" />
            </div>
            <div>
              <h3 className="font-semibold">Time Management</h3>
              <p className="mt-1 text-sm text-muted-foreground">
                Schedule and coordinate multiple events with ease.
              </p>
            </div>
          </div>

          <div className="flex items-start gap-4">
            <div className="rounded-lg bg-primary/10 p-2">
              <Users className="h-6 w-6 text-primary" />
            </div>
            <div>
              <h3 className="font-semibold">Team Collaboration</h3>
              <p className="mt-1 text-sm text-muted-foreground">
                Work together with team members and coordinate responsibilities.
              </p>
            </div>
          </div>
        </div>
      </div>

      {/* CTA Section */}
      <div className="border-t">
        <div className="container mx-auto px-4 py-16">
          <div className="relative overflow-hidden rounded-3xl bg-gradient-to-r from-primary to-primary/80 px-6 py-20 text-center shadow-xl">
            <div className="relative z-10">
              <h2 className="mx-auto max-w-2xl text-3xl font-bold text-white sm:text-4xl">
                Ready to transform your events?
              </h2>
              <p className="mx-auto mt-4 max-w-xl text-lg text-white/90">
                Join thousands of event organizers who trust our platform.
              </p>
              <div className="mt-8 flex justify-center gap-4">
                <Link href="/sign-up">
                  <Button size="lg" variant="secondary" className="gap-2">
                    Get Started Now <ArrowRight className="h-4 w-4" />
                  </Button>
                </Link>
              </div>
            </div>
            {/* Decorative elements */}
            <div className="absolute left-1/2 top-0 h-[120%] w-[120%] -translate-x-1/2 -translate-y-[10%] rotate-12 bg-white/5" />
          </div>
        </div>
      </div>

      {/* Footer */}
      <footer className="mt-auto border-t">
        <div className="container mx-auto px-4 py-8">
          <div className="flex flex-col items-center justify-between gap-4 sm:flex-row">
            <div className="text-center sm:text-left">
              <p className="text-sm text-muted-foreground">
                © 2024 Event Platform. All rights reserved.
              </p>
            </div>
            <div className="flex gap-4">
              <Link href="/privacy" className="text-sm text-muted-foreground hover:text-primary">
                Privacy Policy
              </Link>
              <Link href="/terms" className="text-sm text-muted-foreground hover:text-primary">
                Terms of Service
              </Link>
              <Link href="/contact" className="text-sm text-muted-foreground hover:text-primary">
                Contact Us
              </Link>
            </div>
          </div>
        </div>
      </footer>
    </div>
  );
}

================
File: src/app/sentry.client.config.ts
================
import * as Sentry from "@sentry/nextjs";

Sentry.init({
  dsn: process.env.NEXT_PUBLIC_SENTRY_DSN,
  tracesSampleRate: 1.0,
  debug: process.env.NODE_ENV === "development",
  replaysOnErrorSampleRate: 1.0,
  replaysSessionSampleRate: 0.1,
  integrations: [
    Sentry.browserTracingIntegration(),
    Sentry.replayIntegration({
      maskAllText: true,
      blockAllMedia: true,
    }),
    Sentry.feedbackIntegration({
      colorScheme: "system",
    }),
  ],
});

================
File: src/components/activity/activity-feed.tsx
================
"use client";

import { useState, useEffect } from "react";
import { formatDistanceToNow } from "date-fns";
import { pusherClient } from "@/lib/pusher";
import { Activity, formatActivityMessage } from "@/lib/activity/notifications";
import { Avatar, AvatarFallback, AvatarImage } from "@/components/ui/avatar";
import { ScrollArea } from "@/components/ui/scroll-area";
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/components/ui/tooltip";

interface ActivityFeedProps {
  eventId?: string;
  userId?: string;
  limit?: number;
}

export function ActivityFeed({ eventId, userId, limit = 20 }: ActivityFeedProps) {
  const [activities, setActivities] = useState<Activity[]>([]);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    const fetchActivities = async () => {
      try {
        let response;
        if (eventId) {
          response = await fetch(`/api/events/${eventId}/activities?limit=${limit}`);
        } else if (userId) {
          response = await fetch(`/api/users/${userId}/activities?limit=${limit}`);
        }

        if (response?.ok) {
          const data = await response.json();
          setActivities(data);
        }
      } catch (error) {
        console.error("Error fetching activities:", error);
      } finally {
        setLoading(false);
      }
    };

    fetchActivities();
  }, [eventId, userId, limit]);

  useEffect(() => {
    if (!eventId && !userId) return;

    const channel = pusherClient.subscribe(
      eventId ? `event-${eventId}` : `user-${userId}`
    );

    channel.bind("new-activity", (data: Activity) => {
      setActivities((prev) => [data, ...prev].slice(0, limit));
    });

    return () => {
      channel.unbind_all();
      channel.unsubscribe();
    };
  }, [eventId, userId, limit]);

  if (loading) {
    return <div>Loading activities...</div>;
  }

  return (
    <ScrollArea className="h-[400px]">
      <div className="space-y-4 p-4">
        {activities.map((activity) => (
          <div
            key={activity.createdAt.toString()}
            className="flex items-start space-x-4"
          >
            <TooltipProvider>
              <Tooltip>
                <TooltipTrigger>
                  <Avatar>
                    <AvatarImage src={`https://avatar.vercel.sh/${activity.userId}`} />
                    <AvatarFallback>U</AvatarFallback>
                  </Avatar>
                </TooltipTrigger>
                <TooltipContent>
                  <p>User ID: {activity.userId}</p>
                </TooltipContent>
              </Tooltip>
            </TooltipProvider>

            <div className="flex-1 space-y-1">
              <p className="text-sm">
                <span className="font-medium">User </span>
                {formatActivityMessage(activity)}
              </p>
              {activity.metadata && Object.keys(activity.metadata).length > 0 && (
                <p className="text-xs text-muted-foreground">
                  {JSON.stringify(activity.metadata)}
                </p>
              )}
              <p className="text-xs text-muted-foreground">
                {formatDistanceToNow(new Date(activity.createdAt), {
                  addSuffix: true,
                })}
              </p>
            </div>
          </div>
        ))}
      </div>
    </ScrollArea>
  );
}

================
File: src/components/ads/AdSense.tsx
================
"use client";

import Script from "next/script";

interface AdSenseProps {
  publisherId: string;
}

export function AdSense({ publisherId }: AdSenseProps) {
  if (process.env.NODE_ENV !== "production") {
    return null;
  }

  return (
    <Script
      id="adsbygoogle-init"
      async
      src={`https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=${publisherId}`}
      crossOrigin="anonymous"
      strategy="afterInteractive"
      onError={(e) => {
        console.error("AdSense script failed to load:", e);
      }}
    />
  );
}

================
File: src/components/ads/AdUnit.tsx
================
"use client";

import { usePathname, useSearchParams } from "next/navigation";
import { useEffect, useRef } from "react";

declare global {
  interface Window {
    adsbygoogle: {
      push: (obj: unknown) => void;
    }[] | undefined;
  }
}

interface AdUnitProps {
  slot: string;
  format?: "auto" | "fluid" | "rectangle" | "horizontal" | "vertical";
  layout?: string;
  fullWidthResponsive?: boolean;
  style?: React.CSSProperties;
}

const AdUnit = ({
  slot,
  format = "vertical",
  layout,
  fullWidthResponsive = true,
  style
}: AdUnitProps) => {
  const adRef = useRef<HTMLModElement>(null);
  const pathname = usePathname();
  const searchParams = useSearchParams();

  useEffect(() => {
    const loadAd = () => {
      const intervalId = setInterval(() => {
        try {
          if (typeof window !== "undefined") {
            if (!window.adsbygoogle) {
              window.adsbygoogle = [];
            }
            window.adsbygoogle.push();
            clearInterval(intervalId);
          }
        } catch (error) {
          console.error("AdSense error:", error);
          clearInterval(intervalId);
        }
      }, 300);

      return intervalId;
    };

    // Initial ad load
    const intervalId = loadAd();

    // Cleanup on unmount or route change
    return () => {
      if (intervalId) clearInterval(intervalId);
      
      // Clean up the ad slot
      if (adRef.current) {
        adRef.current.innerHTML = '';
      }
    };
  }, [pathname, searchParams]);

  return (
    <ins
      ref={adRef}
      className="adsbygoogle"
      style={{
        display: "block",
        textAlign: "center",
        minHeight: "100px",
        backgroundColor: process.env.NODE_ENV === "development" ? "#f0f0f0" : "transparent",
        border: process.env.NODE_ENV === "development" ? "1px dashed #ccc" : "none",
        margin: "20px auto",
        maxWidth: "100%",
        overflow: "hidden",
        ...style
      }}
      data-ad-client={process.env.NEXT_PUBLIC_GOOGLE_ADS_CLIENT_ID}
      data-ad-slot={slot}
      data-ad-format={format}
      data-ad-layout={layout}
      data-full-width-responsive={fullWidthResponsive}
      data-adtest={process.env.NODE_ENV === "development" ? "on" : "off"}
    />
  );
};

export default AdUnit;

================
File: src/components/calendar/event-calendar.tsx
================
"use client";

import { useEffect, useState } from "react";
import {
  Calendar,
  Views,
  DateLocalizer,
  momentLocalizer,
} from "react-big-calendar";
import moment from "moment";
import "react-big-calendar/lib/css/react-big-calendar.css";
import { Card } from "@/components/ui/card";
import { useRouter } from "next/navigation";

const localizer = momentLocalizer(moment);

interface Event {
  id: string;
  title: string;
  start: Date;
  end: Date;
}

export function EventCalendar() {
  const [events, setEvents] = useState<Event[]>([]);
  const router = useRouter();

  useEffect(() => {
    const fetchEvents = async () => {
      try {
        const response = await fetch("/api/events");
        const data = await response.json();
        const formattedEvents = data.map((event: any) => ({
          id: event.id,
          title: event.title,
          start: new Date(event.startDate),
          end: new Date(event.endDate),
        }));
        setEvents(formattedEvents);
      } catch (error) {
        console.error("Failed to fetch events:", error);
      }
    };

    fetchEvents();
  }, []);

  const handleEventClick = (event: Event) => {
    router.push(`/events/${event.id}`);
  };

  return (
    <Card className="p-4">
      <Calendar
        localizer={localizer}
        events={events}
        startAccessor="start"
        endAccessor="end"
        style={{ height: "calc(100vh - 200px)" }}
        views={["month", "week", "day"]}
        onSelectEvent={handleEventClick}
        popup
      />
    </Card>
  );
}

================
File: src/components/dashboard/charts.tsx
================
"use client";

import { useEffect, useState } from "react";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import {
  LineChart,
  Line,
  BarChart,
  Bar,
  XAxis,
  YAxis,
  CartesianGrid,
  Tooltip,
  ResponsiveContainer,
  PieChart,
  Pie,
  Cell
} from 'recharts';
import { Skeleton } from "@/components/ui/skeleton";
import { MetricCard } from './metric-card';
import { Calendar } from "../ui/calendar";
import { Activity } from "@/lib/db/models/activity";
import { useQuery } from "@tanstack/react-query";

const COLORS = ['#0088FE', '#00C49F', '#FFBB28', '#FF8042'];

interface ChartData {
  attendanceData: {
    name: string;
    attendees: number;
    capacity: number;
  }[];
  registrationData: {
    name: string;
    registrations: number;
  }[];
  eventTypeData: {
    name: string;
    value: number;
  }[];
}

export function DashboardCharts() {
  const [data, setData] = useState<ChartData | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    const fetchChartData = async () => {
      try {
        const response = await fetch('/api/events/stats/charts');
        if (!response.ok) {
          throw new Error('Failed to fetch chart data');
        }
        const chartData = await response.json();
        setData(chartData);
      } catch (err) {
        setError(err instanceof Error ? err.message : 'An error occurred');
      } finally {
        setLoading(false);
      }
    };

    fetchChartData();
  }, []);

  if (loading) {
    return (
      <Card className="col-span-4">
        <CardHeader>
          <CardTitle>Analytics Overview</CardTitle>
        </CardHeader>
        <CardContent>
          <Skeleton className="h-[300px] w-full" />
        </CardContent>
      </Card>
    );
  }

  if (error) {
    return (
      <Card className="col-span-4">
        <CardHeader>
          <CardTitle>Analytics Overview</CardTitle>
        </CardHeader>
        <CardContent>
          <div className="flex h-[300px] items-center justify-center text-muted-foreground">
            Failed to load chart data
          </div>
        </CardContent>
      </Card>
    );
  }

  if (!data) return null;

  return (
    <Card className="col-span-4">
      <CardHeader>
        <CardTitle>Analytics Overview</CardTitle>
      </CardHeader>
      <CardContent>
        <Tabs defaultValue="attendance" className="space-y-4">
          <TabsList>
            <TabsTrigger value="attendance">Attendance</TabsTrigger>
            <TabsTrigger value="registrations">Registrations</TabsTrigger>
            <TabsTrigger value="types">Event Types</TabsTrigger>
          </TabsList>
          
          <TabsContent value="attendance" className="h-[300px]">
            <ResponsiveContainer width="100%" height="100%">
              <LineChart data={data.attendanceData}>
                <CartesianGrid strokeDasharray="3 3" />
                <XAxis dataKey="name" />
                <YAxis />
                <Tooltip />
                <Line 
                  type="monotone" 
                  dataKey="attendees" 
                  stroke="#8884d8" 
                  strokeWidth={2}
                  name="Attendees"
                />
                <Line 
                  type="monotone" 
                  dataKey="capacity" 
                  stroke="#82ca9d" 
                  strokeWidth={2}
                  strokeDasharray="5 5"
                  name="Capacity"
                />
              </LineChart>
            </ResponsiveContainer>
          </TabsContent>

          <TabsContent value="registrations" className="h-[300px]">
            <ResponsiveContainer width="100%" height="100%">
              <BarChart data={data.registrationData}>
                <CartesianGrid strokeDasharray="3 3" />
                <XAxis dataKey="name" />
                <YAxis />
                <Tooltip />
                <Bar 
                  dataKey="registrations" 
                  fill="#8884d8" 
                  radius={[4, 4, 0, 0]}
                  name="Registrations"
                />
              </BarChart>
            </ResponsiveContainer>
          </TabsContent>

          <TabsContent value="types" className="h-[300px]">
            <ResponsiveContainer width="100%" height="100%">
              <PieChart>
                <Pie
                  data={data.eventTypeData}
                  cx="50%"
                  cy="50%"
                  labelLine={false}
                  label={({ name, percent }) => `${name} (${(percent * 100).toFixed(0)}%)`}
                  outerRadius={100}
                  fill="#8884d8"
                  dataKey="value"
                >
                  {data.eventTypeData.map((_, index) => (
                    <Cell key={`cell-${index}`} fill={COLORS[index % COLORS.length]} />
                  ))}
                </Pie>
                <Tooltip />
              </PieChart>
            </ResponsiveContainer>
          </TabsContent>
        </Tabs>
      </CardContent>
    </Card>
  );
}

// export default function DashboardMetrics() {
//   const metrics = useQuery(['metrics'], async () => {
//     const response = await fetch('/api/events/stats');
//     return response.json();
//   });

//   return (
//     <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4">
//       <MetricCard
//         title="Total Events"
//         value={metrics.data.totalEvents}
//         icon={<Calendar />}
//       />
//       <MetricCard
//         title="Active Events"
//         value={metrics.data.activeEvents}
//         icon={<Activity />}
//       />
//       {/* Add more metric cards */}
//     </div>
//   );
// }

================
File: src/components/dashboard/event-stats.tsx
================
// src/components/dashboard/event-stats.tsx
"use client";

import { useEffect, useState } from "react";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { CalendarCheck2, Users, TrendingUp, Percent } from "lucide-react";

interface StatsProps {
  stats: {
    totalEvents: number;
    upcomingEvents: number;
    totalAttendees: number;
    averageAttendance: number;
  };
}

export function EventStats({ stats }: StatsProps) {
  const [error, setError] = useState<string | null>(null);

  if (error) {
    return (
      <div className="p-4 text-red-500">
        Error loading stats: {error}
      </div>
    );
  }

  return (
    <>
      <Card>
        <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
          <CardTitle className="text-sm font-medium">
            Total Events
          </CardTitle>
          <CalendarCheck2 className="h-4 w-4 text-muted-foreground" />
        </CardHeader>
        <CardContent>
          <div className="text-2xl font-bold">{stats.totalEvents}</div>
          <p className="text-xs text-muted-foreground">
            All your events
          </p>
        </CardContent>
      </Card>

      <Card>
        <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
          <CardTitle className="text-sm font-medium">
            Upcoming Events
          </CardTitle>
          <TrendingUp className="h-4 w-4 text-muted-foreground" />
        </CardHeader>
        <CardContent>
          <div className="text-2xl font-bold">{stats.upcomingEvents}</div>
          <p className="text-xs text-muted-foreground">
            Next 30 days
          </p>
        </CardContent>
      </Card>

      <Card>
        <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
          <CardTitle className="text-sm font-medium">
            Total Attendees
          </CardTitle>
          <Users className="h-4 w-4 text-muted-foreground" />
        </CardHeader>
        <CardContent>
          <div className="text-2xl font-bold">{stats.totalAttendees}</div>
          <p className="text-xs text-muted-foreground">
            Confirmed attendees
          </p>
        </CardContent>
      </Card>

      <Card>
        <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
          <CardTitle className="text-sm font-medium">
            Average Attendance
          </CardTitle>
          <Percent className="h-4 w-4 text-muted-foreground" />
        </CardHeader>
        <CardContent>
          <div className="text-2xl font-bold">
            {stats.averageAttendance}%
          </div>
          <p className="text-xs text-muted-foreground">
            Check-in rate
          </p>
        </CardContent>
      </Card>
    </>
  );
}

================
File: src/components/dashboard/metric-card.tsx
================
import { Card, CardContent } from "@/components/ui/card";
import { ReactNode } from "react";

interface MetricCardProps {
  title: string;
  value: number | string;
  icon?: ReactNode;
  description?: string;
  trend?: {
    value: number;
    isPositive: boolean;
  };
}

export function MetricCard({ title, value, icon, description, trend }: MetricCardProps) {
  return (
    <Card>
      <CardContent className="p-6">
        <div className="flex items-center justify-between space-x-4">
          <div className="flex items-center space-x-4">
            {icon && <div className="text-muted-foreground">{icon}</div>}
            <div>
              <p className="text-sm font-medium text-muted-foreground">{title}</p>
              <h3 className="text-2xl font-bold">{value}</h3>
              {description && (
                <p className="text-xs text-muted-foreground">{description}</p>
              )}
            </div>
          </div>
          {trend && (
            <div className={`text-sm ${trend.isPositive ? 'text-green-600' : 'text-red-600'}`}>
              {trend.isPositive ? '↑' : '↓'} {Math.abs(trend.value)}%
            </div>
          )}
        </div>
      </CardContent>
    </Card>
  );
}

================
File: src/components/dashboard/metrics.tsx
================
// src/components/dashboard/metrics.tsx
import { useQuery } from '@tanstack/react-query';
import { Calendar, Activity, Users, TrendingUp } from 'lucide-react';
import { MetricCard } from './metric-card';

interface MetricsData {
  totalEvents: number;
  activeEvents: number;
  totalAttendees: number;
  growthRate: number;
}

export function DashboardMetrics() {
  const { data, isLoading } = useQuery<MetricsData>({
    queryKey: ['metrics'],
    queryFn: async () => {
      const response = await fetch('/api/events/stats');
      if (!response.ok) {
        throw new Error('Failed to fetch metrics');
      }
      return response.json();
    }
  });

  if (isLoading) {
    return (
      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4">
        {[...Array(4)].map((_, i) => (
          <div key={i} className="h-32 animate-pulse bg-muted rounded-lg" />
        ))}
      </div>
    );
  }

  return (
    <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4">
      <MetricCard
        title="Total Events"
        value={data?.totalEvents || 0}
        icon={<Calendar className="h-4 w-4" />}
        description="All time events"
      />
      <MetricCard
        title="Active Events"
        value={data?.activeEvents || 0}
        icon={<Activity className="h-4 w-4" />}
        description="Currently running"
      />
      <MetricCard
        title="Total Attendees"
        value={data?.totalAttendees || 0}
        icon={<Users className="h-4 w-4" />}
        description="Across all events"
      />
      <MetricCard
        title="Growth Rate"
        value={`${data?.growthRate || 0}%`}
        icon={<TrendingUp className="h-4 w-4" />}
        trend={{
          value: data?.growthRate || 0,
          isPositive: (data?.growthRate || 0) > 0
        }}
        description="vs last month"
      />
    </div>
  );
}

================
File: src/components/dashboard/recent-activity.tsx
================
// src/components/dashboard/recent-activity.tsx
"use client";

import { useEffect, useState } from "react";
import { ScrollArea } from "@/components/ui/scroll-area";
import { Avatar, AvatarFallback, AvatarImage } from "@/components/ui/avatar";
import { Badge } from "@/components/ui/badge";
import { formatDistanceToNow } from "date-fns";
import Link from "next/link";
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/components/ui/tooltip";
import { 
  Calendar, 
  UserCheck, 
  UserMinus, 
  MessageSquare, 
  Edit,
  ExternalLink,
  Settings,
  Mail
} from "lucide-react";

interface Activity {
  id: string;
  type: string;
  userId: string;
  eventId: string;
  metadata?: {
    guestId?: string;
    guestName?: string;
    eventTitle?: string;
    changes?: string[];
    messageId?: string;
    messageContent?: string;
  };
  createdAt: string;
  user?: {
    name: string;
    avatar?: string;
    email: string;
  };
  event?: {
    title: string;
  };
}

export function RecentActivity() {
  const [activities, setActivities] = useState<Activity[]>([]);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    fetchActivities();
  }, []);

  const fetchActivities = async () => {
    try {
      const response = await fetch('/api/activities?limit=20');
      if (!response.ok) throw new Error('Failed to fetch activities');
      const data = await response.json();
      
      // Fetch user details for each activity
      const enrichedActivities = await Promise.all(
        data.map(async (activity: Activity) => {
          try {
            const userResponse = await fetch(`/api/users/${activity.userId}`);
            if (userResponse.ok) {
              const userData = await userResponse.json();
              return {
                ...activity,
                user: {
                  name: userData.name || 'Unknown User',
                  avatar: userData.imageUrl,
                  email: userData.emailAddress
                }
              };
            }
          } catch (error) {
            console.error(`Error fetching user data for ${activity.userId}:`, error);
          }
          return activity;
        })
      );

      setActivities(enrichedActivities);
    } catch (error) {
      console.error("Error fetching activities:", error);
    } finally {
      setLoading(false);
    }
  };

  const getActivityIcon = (type: string) => {
    const icons = {
      'event.created': <Calendar className="h-4 w-4" />,
      'event.updated': <Edit className="h-4 w-4" />,
      'event.cancelled': <UserMinus className="h-4 w-4" />,
      'guest.invited': <Mail className="h-4 w-4" />,
      'guest.confirmed': <UserCheck className="h-4 w-4" />,
      'guest.declined': <UserMinus className="h-4 w-4" />,
      'guest.checked_in': <UserCheck className="h-4 w-4" />,
      'guest.removed': <UserMinus className="h-4 w-4" />,
      'message.sent': <MessageSquare className="h-4 w-4" />,
      'settings.updated': <Settings className="h-4 w-4" />,
    };
    return icons[type as keyof typeof icons] || <Calendar className="h-4 w-4" />;
  };

  const getActivityColor = (type: string) => {
    const colors = {
      'event.created': "bg-green-100 text-green-800",
      'event.updated': "bg-yellow-100 text-yellow-800",
      'event.cancelled': "bg-red-100 text-red-800",
      'guest.invited': "bg-blue-100 text-blue-800",
      'guest.confirmed': "bg-green-100 text-green-800",
      'guest.declined': "bg-red-100 text-red-800",
      'guest.checked_in': "bg-green-100 text-green-800",
      'guest.removed': "bg-red-100 text-red-800",
      'message.sent': "bg-purple-100 text-purple-800",
      'settings.updated': "bg-yellow-100 text-yellow-800",
    };
    return colors[type as keyof typeof colors] || "bg-gray-100 text-gray-800";
  };

  const formatActivityMessage = (activity: Activity) => {
    switch (activity.type) {
      case 'event.created':
        return `created event "${activity.metadata?.eventTitle}"`;
      case 'event.updated':
        return `updated event details (${activity.metadata?.changes?.join(', ')})`;
      case 'event.cancelled':
        return `cancelled event "${activity.metadata?.eventTitle}"`;
      case 'guest.invited':
        return `invited ${activity.metadata?.guestName} to the event`;
      case 'guest.confirmed':
        return `confirmed attendance for ${activity.metadata?.guestName}`;
      case 'guest.declined':
        return `declined attendance for ${activity.metadata?.guestName}`;
      case 'guest.checked_in':
        return `checked in ${activity.metadata?.guestName}`;
      case 'guest.removed':
        return `removed ${activity.metadata?.guestName} from the event`;
      case 'message.sent':
        return `sent a message: "${activity.metadata?.messageContent}"`;
      case 'settings.updated':
        return `updated event settings`;
      default:
        return 'performed an action';
    }
  };

  if (loading) {
    return (
      <div className="space-y-4">
        {[1, 2, 3].map((index) => (
          <div
            key={index}
            className="flex items-start space-x-4 animate-pulse"
          >
            <div className="h-10 w-10 rounded-full bg-gray-200" />
            <div className="space-y-2 flex-1">
              <div className="h-4 w-3/4 bg-gray-200 rounded" />
              <div className="h-3 w-1/2 bg-gray-200 rounded" />
            </div>
          </div>
        ))}
      </div>
    );
  }

  return (
    <ScrollArea className="h-[400px]">
      <div className="space-y-4 pr-4">
        {activities.map((activity) => (
          <div
            key={activity.id}
            className="flex items-start space-x-4 border-b pb-4 last:border-0"
          >
            <TooltipProvider>
              <Tooltip>
                <TooltipTrigger>
                  <Avatar>
                    <AvatarImage 
                      src={activity.user?.avatar || `https://api.dicebear.com/7.x/initials/svg?seed=${activity.userId}`} 
                    />
                    <AvatarFallback>
                      {activity.user?.name?.[0] || 'U'}
                    </AvatarFallback>
                  </Avatar>
                </TooltipTrigger>
                <TooltipContent>
                  <div>{activity.user?.name || 'User'}</div>
                  <div className="text-xs text-muted-foreground">
                    {activity.user?.email || activity.userId}
                  </div>
                </TooltipContent>
              </Tooltip>
            </TooltipProvider>
            
            <div className="flex-1 space-y-1">
              <div className="flex items-center gap-2">
                <Badge className={getActivityColor(activity.type)}>
                  <span className="flex items-center gap-1">
                    {getActivityIcon(activity.type)}
                    {activity.type.split('.')[0]}
                  </span>
                </Badge>
                <span className="text-xs text-muted-foreground">
                  {formatDistanceToNow(new Date(activity.createdAt), { addSuffix: true })}
                </span>
              </div>
              
              <div className="text-sm">
                <span className="font-medium">{activity.user?.name || 'User'} </span>
                {formatActivityMessage(activity)}
              </div>
            </div>

            {activity.eventId && (
              <Link
                href={`/events/${activity.eventId}`}
                className="shrink-0 hover:text-primary"
              >
                <ExternalLink className="h-4 w-4" />
              </Link>
            )}
          </div>
        ))}
      </div>
    </ScrollArea>
  );
}

================
File: src/components/dashboard/upcoming-events.tsx
================
// src/components/dashboard/upcoming-events.tsx
"use client";

import { useEffect, useState } from "react";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import { ScrollArea } from "@/components/ui/scroll-area";
import { Calendar, Clock, MapPin, Users } from "lucide-react";
import { format } from "date-fns";
import Link from "next/link";
import { LoadingSpinner } from "@/components/ui/loading-state";

interface Event {
  id: string;
  title: string;
  startDate: string;
  endDate: string;
  location: {
    venue: string;
    address: string;
  };
  attendees: {
    confirmed: number;
    total: number;
  };
  status: "upcoming" | "ongoing" | "ended";
  visibility: "public" | "private";
}

interface ApiResponse {
  events: Event[];
  success: boolean;
  error?: string;
}

export function UpcomingEvents() {
  const [events, setEvents] = useState<Event[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    const fetchUpcomingEvents = async () => {
      try {
        const response = await fetch('/api/events/upcoming');
        if (!response.ok) {
          throw new Error('Failed to fetch upcoming events');
        }
        const data: ApiResponse = await response.json();
        
        if (!data.success) {
          throw new Error(data.error || 'Failed to fetch events');
        }

        setEvents(data.events);
      } catch (err) {
        setError(err instanceof Error ? err.message : 'An error occurred');
        console.error('Error fetching upcoming events:', err);
      } finally {
        setLoading(false);
      }
    };

    fetchUpcomingEvents();
  }, []);

  const getStatusColor = (status: string) => {
    const colors = {
      upcoming: "bg-blue-100 text-blue-800",
      ongoing: "bg-green-100 text-green-800",
      ended: "bg-gray-100 text-gray-800"
    };
    return colors[status as keyof typeof colors];
  };

  if (loading) {
    return (
      <Card>
        <CardHeader>
          <CardTitle>Upcoming Events</CardTitle>
        </CardHeader>
        <CardContent className="flex items-center justify-center h-[400px]">
          <LoadingSpinner />
        </CardContent>
      </Card>
    );
  }

  if (error) {
    return (
      <Card>
        <CardHeader>
          <CardTitle>Upcoming Events</CardTitle>
        </CardHeader>
        <CardContent className="flex items-center justify-center h-[400px] text-muted-foreground">
          {error}
        </CardContent>
      </Card>
    );
  }

  return (
    <Card>
      <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
        <CardTitle>Upcoming Events</CardTitle>
        <Link href="/events">
          <Button variant="outline" size="sm">View All</Button>
        </Link>
      </CardHeader>
      <CardContent>
        <ScrollArea className="h-[400px] pr-4">
          {events.length === 0 ? (
            <div className="flex items-center justify-center h-[300px] text-muted-foreground">
              No upcoming events
            </div>
          ) : (
            <div className="space-y-4">
              {events.map((event) => (
                <Link 
                  key={event.id} 
                  href={`/events/${event.id}`}
                  className="block"
                >
                  <div className="rounded-lg border p-3 hover:bg-accent transition-colors">
                    <div className="flex items-start justify-between">
                      <h3 className="font-medium">{event.title}</h3>
                      <Badge className={getStatusColor(event.status)}>
                        {event.status}
                      </Badge>
                    </div>
                    
                    <div className="mt-2 space-y-1">
                      <div className="flex items-center text-sm text-muted-foreground">
                        <Calendar className="mr-2 h-4 w-4" />
                        {format(new Date(event.startDate), "PPP")}
                      </div>
                      <div className="flex items-center text-sm text-muted-foreground">
                        <Clock className="mr-2 h-4 w-4" />
                        {format(new Date(event.startDate), "p")} - 
                        {format(new Date(event.endDate), "p")}
                      </div>
                      <div className="flex items-center text-sm text-muted-foreground">
                        <MapPin className="mr-2 h-4 w-4" />
                        {event.location.venue}
                      </div>
                      <div className="flex items-center text-sm text-muted-foreground">
                        <Users className="mr-2 h-4 w-4" />
                        {event.attendees.confirmed} / {event.attendees.total} attendees
                      </div>
                    </div>
                  </div>
                </Link>
              ))}
            </div>
          )}
        </ScrollArea>
      </CardContent>
    </Card>
  );
}

================
File: src/components/error-boundary/global-error.tsx
================
"use client"

import { useEffect } from 'react';
import * as Sentry from '@sentry/nextjs';
import { Button } from '@/components/ui/button';
import { FallbackProps } from 'react-error-boundary';

export function GlobalError({ error, resetErrorBoundary }: FallbackProps) {
  useEffect(() => {
    // Log to error reporting service
    Sentry.captureException(error);
  }, [error]);

  return (
    <div className="flex h-screen flex-col items-center justify-center space-y-4">
      <div className="text-center space-y-2">
        <h1 className="text-4xl font-bold text-destructive">Something went wrong!</h1>
        <p className="text-muted-foreground">
          We apologize for the inconvenience. Please try again.
        </p>
      </div>
      <div className="flex space-x-4">
        <Button onClick={() => window.location.reload()}>Refresh Page</Button>
        <Button variant="outline" onClick={resetErrorBoundary}>Try Again</Button>
      </div>
      {process.env.NODE_ENV === 'development' && (
        <div className="mt-4 max-w-xl overflow-auto rounded-md bg-muted p-4">
          <pre className="text-sm text-destructive">{error.message}</pre>
          <pre className="text-xs text-muted-foreground">{error.stack}</pre>
        </div>
      )}
    </div>
  );
}

================
File: src/components/error-boundary/sentry-error-boundary.tsx
================
'use client';

import * as Sentry from "@sentry/nextjs";
import { Component, ReactNode } from "react";

interface Props {
  children: ReactNode;
  fallback?: ReactNode;
}

interface State {
  hasError: boolean;
}

export class SentryErrorBoundary extends Component<Props, State> {
  public state: State = {
    hasError: false,
  };

  public static getDerivedStateFromError(): State {
    return { hasError: true };
  }

  public componentDidCatch(error: Error, errorInfo: React.ErrorInfo) {
    Sentry.captureException(error, {
      contexts: { react: { componentStack: errorInfo.componentStack } },
    });
  }

  public render() {
    if (this.state.hasError) {
      return this.props.fallback || (
        <div className="flex min-h-[400px] items-center justify-center">
          <div className="text-center">
            <h2 className="text-xl font-semibold">Something went wrong</h2>
            <button
              className="mt-4 rounded bg-primary px-4 py-2 text-white"
              onClick={() => this.setState({ hasError: false })}
            >
              Try again
            </button>
          </div>
        </div>
      );
    }

    return this.props.children;
  }
}

================
File: src/components/error-boundary/with-error-boundary.tsx
================
import { ErrorBoundary, FallbackProps } from 'react-error-boundary';
import { GlobalError } from './global-error';

export function withErrorBoundary<P extends object>(
  Component: React.ComponentType<P>,
  fallback: React.ComponentType<FallbackProps> = GlobalError
) {
  return function WithErrorBoundary(props: P) {
    return (
      <ErrorBoundary FallbackComponent={fallback}>
        <Component {...props} />
      </ErrorBoundary>
    );
  };
}

================
File: src/components/events/check-in.tsx
================
"use client";

import { useState } from "react";
import { QRCodeSVG } from "qrcode.react";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogTrigger,
} from "@/components/ui/dialog";
import { useToast } from "@/hooks/use-toast";
import { 
  QrCode, 
  UserCheck,
  Search,
  UserX 
} from "lucide-react";

interface CheckInProps {
  eventId: string;
  onCheckedIn?: () => void;
}

export function CheckIn({ eventId, onCheckedIn }: CheckInProps) {
  const [searchQuery, setSearchQuery] = useState("");
  const [scanning, setScanning] = useState(false);
  const { toast } = useToast();
  const checkInUrl = `${window.location.origin}/events/${eventId}/check-in`;

  const handleCheckIn = async (guestId: string) => {
    try {
      const response = await fetch(`/api/events/${eventId}/check-in`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({ guestId }),
      });

      if (!response.ok) throw new Error("Check-in failed");

      const data = await response.json();
      toast({
        title: "Checked In Successfully",
        description: `${data.guest.name} has been checked in.`,
      });

      if (onCheckedIn) onCheckedIn();
    } catch (error) {
      toast({
        variant: "destructive",
        title: "Check-in Failed",
        description: "Unable to check in guest. Please try again.",
      });
    }
  };

  const searchGuests = async () => {
    try {
      const response = await fetch(
        `/api/events/${eventId}/guests/search?q=${encodeURIComponent(searchQuery)}`
      );
      if (!response.ok) throw new Error("Search failed");
      return await response.json();
    } catch (error) {
      console.error("Error searching guests:", error);
      return [];
    }
  };

  return (
    <div className="space-y-4">
      <div className="flex items-center justify-between">
        <div className="flex gap-2">
          <Input
            placeholder="Search guests..."
            value={searchQuery}
            onChange={(e) => setSearchQuery(e.target.value)}
            className="w-64"
          />
          <Button onClick={searchGuests}>
            <Search className="h-4 w-4 mr-2" />
            Search
          </Button>
        </div>

        <Dialog>
          <DialogTrigger asChild>
            <Button variant="outline">
              <QrCode className="h-4 w-4 mr-2" />
              Show QR Code
            </Button>
          </DialogTrigger>
          <DialogContent>
            <DialogHeader>
              <DialogTitle>Event Check-in QR Code</DialogTitle>
            </DialogHeader>
            <div className="flex justify-center p-4">
              <QRCodeSVG value={checkInUrl} size={256} />
            </div>
            <p className="text-center text-sm text-muted-foreground">
              Scan this QR code to check in to the event
            </p>
          </DialogContent>
        </Dialog>
      </div>

      {/* Guest search results and check-in UI would go here */}
    </div>
  );
}

================
File: src/components/events/event-card.tsx
================
// src/components/events/event-card.tsx
import {
  Card,
  CardContent,
  CardDescription,
  CardFooter,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import { Calendar, Clock, MapPin, Users } from "lucide-react";
import { format } from "date-fns";
import Link from "next/link";

interface EventCardProps {
  event: {
    id: string;
    title: string;
    description: string;
    startDate: Date;
    endDate: Date;
    location: {
      venue: string;
    };
    capacity: number;
    status: string;
  };
}

export function EventCard({ event }: EventCardProps) {
  return (
    <Card>
      <CardHeader>
        <div className="flex items-center justify-between">
          <CardTitle className="line-clamp-1">{event.title}</CardTitle>
          <Badge variant={event.status === "published" ? "default" : "secondary"}>
            {event.status}
          </Badge>
        </div>
        <CardDescription className="line-clamp-2">
          {event.description}
        </CardDescription>
      </CardHeader>
      <CardContent className="space-y-2">
        <div className="flex items-center space-x-2 text-sm">
          <Calendar className="h-4 w-4" />
          <span>{format(new Date(event.startDate), "PPP")}</span>
        </div>
        <div className="flex items-center space-x-2 text-sm">
          <Clock className="h-4 w-4" />
          <span>{format(new Date(event.startDate), "p")}</span>
        </div>
        <div className="flex items-center space-x-2 text-sm">
          <MapPin className="h-4 w-4" />
          <span>{event.location?.venue}</span>
        </div>
        <div className="flex items-center space-x-2 text-sm">
          <Users className="h-4 w-4" />
          <span>{event.capacity} attendees</span>
        </div>
      </CardContent>
      <CardFooter className="flex justify-between">
        <Link href={`/events/${event.id}/edit`}>
          <Button variant="outline">Edit</Button>
        </Link>
        <Link href={`/events/${event.id}`}>
          <Button>View Details</Button>
        </Link>
      </CardFooter>
    </Card>
  );
}

================
File: src/components/events/event-chat.tsx
================
"use client";

import { useEffect, useRef, useState } from "react";
import { Avatar, AvatarFallback, AvatarImage } from "@/components/ui/avatar";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { ScrollArea } from "@/components/ui/scroll-area";
import { format } from "date-fns";
import { pusherClient } from "@/lib/pusher";
import { useUser } from "@clerk/nextjs";

interface Message {
  id: string;
  content: string;
  senderId: string;
  senderName: string;
  senderAvatar?: string;
  createdAt: string;
}

export function EventChat({ eventId }: { eventId: string }) {
  const [messages, setMessages] = useState<Message[]>([]);
  const [newMessage, setNewMessage] = useState("");
  const [isLoading, setIsLoading] = useState(false);
  const scrollRef = useRef<HTMLDivElement>(null);
  const { user } = useUser();

  useEffect(() => {
    fetchMessages();
    const channel = pusherClient.subscribe(`event-${eventId}`);
    
    channel.bind("new-message", (message: Message) => {
      setMessages((current) => [...current, message]);
      scrollToBottom();
    });

    return () => {
      pusherClient.unbind_all();
      pusherClient.unsubscribe(`event-${eventId}`);
    };
  }, [eventId]);

  const fetchMessages = async () => {
    try {
      const response = await fetch(`/api/events/${eventId}/chat`);
      const data = await response.json();
      setMessages(data);
      scrollToBottom();
    } catch (error) {
      console.error("Error fetching messages:", error);
    }
  };

  const scrollToBottom = () => {
    if (scrollRef.current) {
      scrollRef.current.scrollIntoView({ behavior: "smooth" });
    }
  };

  const sendMessage = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!newMessage.trim() || isLoading) return;

    setIsLoading(true);
    try {
      await fetch(`/api/events/${eventId}/chat`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          content: newMessage,
          senderName: user?.fullName,
          senderAvatar: user?.imageUrl,
        }),
      });
      setNewMessage("");
    } catch (error) {
      console.error("Error sending message:", error);
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <div className="flex flex-col h-[600px]">
      <ScrollArea className="flex-1 p-4">
        <div className="space-y-4">
          {messages.map((message) => (
            <div
              key={message.id}
              className={`flex items-start space-x-2 ${
                message.senderId === user?.id ? "justify-end" : ""
              }`}
            >
              {message.senderId !== user?.id && (
                <Avatar>
                  <AvatarImage src={message.senderAvatar} />
                  <AvatarFallback>
                    {message.senderName?.[0]?.toUpperCase()}
                  </AvatarFallback>
                </Avatar>
              )}
              <div
                className={`flex flex-col space-y-1 ${
                  message.senderId === user?.id ? "items-end" : ""
                }`}
              >
                <div
                  className={`px-4 py-2 rounded-lg ${
                    message.senderId === user?.id
                      ? "bg-primary text-primary-foreground"
                      : "bg-muted"
                  }`}
                >
                  <p>{message.content}</p>
                </div>
                <span className="text-xs text-muted-foreground">
                  {format(new Date(message.createdAt), "p")}
                </span>
              </div>
            </div>
          ))}
          <div ref={scrollRef} />
        </div>
      </ScrollArea>
      <form onSubmit={sendMessage} className="p-4 border-t">
        <div className="flex space-x-2">
          <Input
            value={newMessage}
            onChange={(e) => setNewMessage(e.target.value)}
            placeholder="Type your message..."
            disabled={isLoading}
          />
          <Button type="submit" disabled={isLoading}>
            Send
          </Button>
        </div>
      </form>
    </div>
  );
}

================
File: src/components/events/event-form.tsx
================
"use client";

import * as z from "zod";
import { zodResolver } from "@hookform/resolvers/zod";
import { useForm } from "react-hook-form";
import { Button } from "@/components/ui/button";
import {
  Form,
  FormControl,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
} from "@/components/ui/form";
import { Input } from "@/components/ui/input";
import { Textarea } from "@/components/ui/textarea";
import { Calendar } from "@/components/ui/calendar";
import {
  Popover,
  PopoverContent,
  PopoverTrigger,
} from "@/components/ui/popover";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { cn } from "@/lib/utils";
import { format } from "date-fns";
import { CalendarIcon } from "lucide-react";
import { useState } from "react";
import { useRouter } from "next/navigation";
import { useToast } from "@/hooks/use-toast";

const formSchema = z.object({
  title: z.string().min(2, "Title must be at least 2 characters").max(100),
  description: z.string().min(10, "Description must be at least 10 characters"),
  startDate: z.date({
    required_error: "Start date is required",
  }),
  endDate: z.date({
    required_error: "End date is required",
  }),
  venue: z.string().min(2, "Venue is required"),
  address: z.string().min(5, "Address is required"),
  capacity: z.string().transform(Number),
  visibility: z.enum(["public", "private"]),
  recurring: z.enum(["none", "daily", "weekly", "monthly"])
}).refine(data => {
  return data.endDate >= data.startDate;
}, {
  message: "End date must be after start date",
  path: ["endDate"],
});

interface EventFormProps {
  event?: any;
  isEditing?: boolean;
}

export function EventForm({ event, isEditing = false }: EventFormProps) {
  const router = useRouter();
  const [isLoading, setIsLoading] = useState(false);
  const { toast } = useToast();

  const form = useForm<z.infer<typeof formSchema>>({
    resolver: zodResolver(formSchema),
    defaultValues: {
      title: event?.title || "",
      description: event?.description || "",
      venue: event?.location?.venue || "",
      address: event?.location?.address || "",
      capacity: event?.capacity || "0",
      visibility: event?.visibility || "private",
      recurring: event?.recurring?.pattern || "none",
      startDate: event?.startDate ? new Date(event.startDate) : undefined,
      endDate: event?.endDate ? new Date(event.endDate) : undefined,
    },
  });

  async function onSubmit(values: z.infer<typeof formSchema>) {
    try {
      setIsLoading(true);
      const url = isEditing ? `/api/events/${event.id}` : "/api/events";
      const method = isEditing ? "PATCH" : "POST";

      const response = await fetch(url, {
        method,
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify(values),
      });

      if (!response.ok) {
        throw new Error(isEditing ? "Failed to update event" : "Failed to create event");
      }

      const data = await response.json();
      router.push(`/events/${data.id}`);
      router.refresh();
    } catch (error) {
      console.error(error);
    } finally {
      setIsLoading(false);
    }
  }

  return (
    <Form {...form}>
      <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-8">
        <FormField
          control={form.control}
          name="title"
          render={({ field }) => (
            <FormItem>
              <FormLabel>Event Title</FormLabel>
              <FormControl>
                <Input placeholder="Tech Conference 2024" {...field} />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />

        <FormField
          control={form.control}
          name="description"
          render={({ field }) => (
            <FormItem>
              <FormLabel>Description</FormLabel>
              <FormControl>
                <Textarea
                  placeholder="Enter event description"
                  className="h-32"
                  {...field}
                />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />

        <div className="grid gap-6 md:grid-cols-2">
          <FormField
            control={form.control}
            name="startDate"
            render={({ field }) => (
              <FormItem className="flex flex-col">
                <FormLabel>Start Date</FormLabel>
                <Popover>
                  <PopoverTrigger asChild>
                    <FormControl>
                      <Button
                        variant="outline"
                        className={cn(
                          "w-full pl-3 text-left font-normal",
                          !field.value && "text-muted-foreground"
                        )}
                      >
                        {field.value ? (
                          format(field.value, "PPP")
                        ) : (
                          <span>Pick a date</span>
                        )}
                        <CalendarIcon className="ml-auto h-4 w-4 opacity-50" />
                      </Button>
                    </FormControl>
                  </PopoverTrigger>
                  <PopoverContent className="w-auto p-0" align="start">
                    <Calendar
                      mode="single"
                      selected={field.value}
                      onSelect={field.onChange}
                      disabled={(date) =>
                        date < new Date() || date < new Date("1900-01-01")
                      }
                      initialFocus
                    />
                  </PopoverContent>
                </Popover>
                <FormMessage />
              </FormItem>
            )}
          />

          <FormField
            control={form.control}
            name="endDate"
            render={({ field }) => (
              <FormItem className="flex flex-col">
                <FormLabel>End Date</FormLabel>
                <Popover>
                  <PopoverTrigger asChild>
                    <FormControl>
                      <Button
                        variant="outline"
                        className={cn(
                          "w-full pl-3 text-left font-normal",
                          !field.value && "text-muted-foreground"
                        )}
                      >
                        {field.value ? (
                          format(field.value, "PPP")
                        ) : (
                          <span>Pick a date</span>
                        )}
                        <CalendarIcon className="ml-auto h-4 w-4 opacity-50" />
                      </Button>
                    </FormControl>
                  </PopoverTrigger>
                  <PopoverContent className="w-auto p-0" align="start">
                    <Calendar
                      mode="single"
                      selected={field.value}
                      onSelect={field.onChange}
                      disabled={(date) =>
                        date < new Date() || date < new Date("1900-01-01")
                      }
                      initialFocus
                    />
                  </PopoverContent>
                </Popover>
                <FormMessage />
              </FormItem>
            )}
          />
        </div>

        <div className="grid gap-6 md:grid-cols-2">
          <FormField
            control={form.control}
            name="venue"
            render={({ field }) => (
              <FormItem>
                <FormLabel>Venue Name</FormLabel>
                <FormControl>
                  <Input placeholder="Convention Center" {...field} />
                </FormControl>
                <FormMessage />
              </FormItem>
            )}
          />

          <FormField
            control={form.control}
            name="address"
            render={({ field }) => (
              <FormItem>
                <FormLabel>Address</FormLabel>
                <FormControl>
                  <Input placeholder="123 Main St, City" {...field} />
                </FormControl>
                <FormMessage />
              </FormItem>
            )}
          />
        </div>

        <div className="grid gap-6 md:grid-cols-3">
          <FormField
            control={form.control}
            name="capacity"
            render={({ field }) => (
              <FormItem>
                <FormLabel>Capacity</FormLabel>
                <FormControl>
                  <Input
                    type="number"
                    placeholder="100"
                    {...field}
                  />
                </FormControl>
                <FormMessage />
              </FormItem>
            )}
          />

          <FormField
            control={form.control}
            name="visibility"
            render={({ field }) => (
              <FormItem>
                <FormLabel>Visibility</FormLabel>
                <Select
                  onValueChange={field.onChange}
                  defaultValue={field.value}
                >
                  <FormControl>
                    <SelectTrigger>
                      <SelectValue placeholder="Select visibility" />
                    </SelectTrigger>
                  </FormControl>
                  <SelectContent>
                    <SelectItem value="public">Public</SelectItem>
                    <SelectItem value="private">Private</SelectItem>
                  </SelectContent>
                </Select>
                <FormMessage />
              </FormItem>
            )}
          />

          <FormField
            control={form.control}
            name="recurring"
            render={({ field }) => (
              <FormItem>
                <FormLabel>Recurring</FormLabel>
                <Select
                  onValueChange={field.onChange}
                  defaultValue={field.value}
                >
                  <FormControl>
                    <SelectTrigger>
                      <SelectValue placeholder="Select pattern" />
                    </SelectTrigger>
                  </FormControl>
                  <SelectContent>
                    <SelectItem value="none">None</SelectItem>
                    <SelectItem value="daily">Daily</SelectItem>
                    <SelectItem value="weekly">Weekly</SelectItem>
                    <SelectItem value="monthly">Monthly</SelectItem>
                  </SelectContent>
                </Select>
                <FormMessage />
              </FormItem>
            )}
          />
        </div>

        <Button type="submit" className="w-full" disabled={isLoading}>
        {isLoading 
            ? (isEditing ? "Updating..." : "Creating...") 
            : (isEditing ? "Update Event" : "Create Event")
          }
        </Button>
      </form>
    </Form>
  );
}

================
File: src/components/events/guest-list.tsx
================
"use client";

import { useState, useEffect } from "react";
import { Search } from "lucide-react";
import { Input } from "@/components/ui/input";
import { ScrollArea } from "@/components/ui/scroll-area";
import { Avatar, AvatarFallback, AvatarImage } from "@/components/ui/avatar";
import { Badge } from "@/components/ui/badge";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import { Button } from "@/components/ui/button";
import { useToast } from "@/hooks/use-toast";
import { pusherClient } from "@/lib/pusher";

interface Guest {
  id: string;
  name: string;
  email: string;
  status: "invited" | "confirmed" | "declined" | "waitlist";
  role: "attendee" | "coHost" | "moderator";
  checkedIn: boolean;
  checkedInAt?: string;
}

export function GuestList({ eventId }: { eventId: string }) {
  const [guests, setGuests] = useState<Guest[]>([]);
  const [searchQuery, setSearchQuery] = useState("");
  const [loading, setLoading] = useState(true);
  const { toast } = useToast();

  useEffect(() => {
    fetchGuests();

    // Initialize Pusher only if we have the required credentials
    if (process.env.NEXT_PUBLIC_PUSHER_APP_KEY && process.env.NEXT_PUBLIC_PUSHER_CLUSTER) {
      try {
        const channel = pusherClient.subscribe(`event-${eventId}`);
        
        channel.bind("guest-updated", (updatedGuest: Guest) => {
          setGuests(currentGuests =>
            currentGuests.map(guest =>
              guest.id === updatedGuest.id ? updatedGuest : guest
            )
          );
        });

        channel.bind("guest-added", (newGuest: Guest) => {
          setGuests(currentGuests => [...currentGuests, newGuest]);
        });

        channel.bind("guest-removed", (removedGuestId: string) => {
          setGuests(currentGuests =>
            currentGuests.filter(guest => guest.id !== removedGuestId)
          );
        });

        return () => {
          channel.unbind_all();
          channel.unsubscribe();
        };
      } catch (error) {
        console.error("Pusher initialization error:", error);
      }
    }
  }, [eventId]);

  const fetchGuests = async () => {
    try {
      const response = await fetch(`/api/events/${eventId}/guests`);
      if (!response.ok) throw new Error("Failed to fetch guests");
      const data = await response.json();
      setGuests(data);
    } catch (error) {
      toast({
        title: "Error",
        description: "Failed to load guest list",
        variant: "destructive",
      });
    } finally {
      setLoading(false);
    }
  };

  const updateGuestStatus = async (guestId: string, status: Guest["status"]) => {
    try {
      const response = await fetch(`/api/events/${eventId}/guests/${guestId}`, {
        method: "PATCH",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ status }),
      });

      if (!response.ok) throw new Error("Failed to update guest status");

      toast({
        title: "Success",
        description: "Guest status updated",
      });

      fetchGuests(); // Refresh the guest list
    } catch (error) {
      toast({
        title: "Error",
        description: "Failed to update guest status",
        variant: "destructive",
      });
    }
  };

  const removeGuest = async (guestId: string) => {
    try {
      const response = await fetch(`/api/events/${eventId}/guests/${guestId}`, {
        method: "DELETE",
      });

      if (!response.ok) throw new Error("Failed to remove guest");

      toast({
        title: "Success",
        description: "Guest removed successfully",
      });

      fetchGuests(); // Refresh the guest list
    } catch (error) {
      toast({
        title: "Error",
        description: "Failed to remove guest",
        variant: "destructive",
      });
    }
  };

  const filteredGuests = guests.filter(
    guest =>
      guest.name.toLowerCase().includes(searchQuery.toLowerCase()) ||
      guest.email.toLowerCase().includes(searchQuery.toLowerCase())
  );

  const getStatusColor = (status: Guest["status"]) => {
    const colors = {
      invited: "bg-blue-100 text-blue-800",
      confirmed: "bg-green-100 text-green-800",
      declined: "bg-red-100 text-red-800",
      waitlist: "bg-yellow-100 text-yellow-800",
    };
    return colors[status];
  };

  if (loading) {
    return <div>Loading guest list...</div>;
  }

  return (
    <div className="space-y-4">
      <div className="relative">
        <Search className="absolute left-2 top-2.5 h-4 w-4 text-muted-foreground" />
        <Input
          placeholder="Search guests..."
          value={searchQuery}
          onChange={(e) => setSearchQuery(e.target.value)}
          className="pl-8"
        />
      </div>

      <ScrollArea className="h-[400px] pr-4">
        <div className="space-y-2">
          {filteredGuests.map((guest) => (
            <div
              key={guest.id}
              className="flex items-center justify-between rounded-lg border p-2"
            >
              <div className="flex items-center gap-2">
                <Avatar>
                  <AvatarImage src={`https://avatar.vercel.sh/${guest.email}`} />
                  <AvatarFallback>{guest.name[0]}</AvatarFallback>
                </Avatar>
                <div>
                  <div className="font-medium">{guest.name}</div>
                  <div className="text-sm text-muted-foreground">
                    {guest.email}
                  </div>
                </div>
              </div>

              <div className="flex items-center gap-2">
                <Badge className={getStatusColor(guest.status)}>
                  {guest.status}
                </Badge>
                <DropdownMenu>
                  <DropdownMenuTrigger asChild>
                    <Button variant="ghost" size="sm">
                      •••
                    </Button>
                  </DropdownMenuTrigger>
                  <DropdownMenuContent align="end">
                    <DropdownMenuLabel>Actions</DropdownMenuLabel>
                    <DropdownMenuSeparator />
                    <DropdownMenuItem
                      onClick={() => updateGuestStatus(guest.id, "confirmed")}
                    >
                      Confirm
                    </DropdownMenuItem>
                    <DropdownMenuItem
                      onClick={() => updateGuestStatus(guest.id, "declined")}
                    >
                      Decline
                    </DropdownMenuItem>
                    <DropdownMenuItem
                      onClick={() => updateGuestStatus(guest.id, "waitlist")}
                    >
                      Move to Waitlist
                    </DropdownMenuItem>
                    <DropdownMenuSeparator />
                    <DropdownMenuItem
                      className="text-red-600"
                      onClick={() => removeGuest(guest.id)}
                    >
                      Remove
                    </DropdownMenuItem>
                  </DropdownMenuContent>
                </DropdownMenu>
              </div>
            </div>
          ))}
        </div>
      </ScrollArea>
    </div>
  );
}

================
File: src/components/events/share-event.tsx
================
"use client";

import { useState } from "react";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { 
  Facebook, 
  Twitter, 
  Linkedin, 
  Mail, 
  Link as LinkIcon,
  Check,
  Copy,
  Share2
} from "lucide-react";
import { useToast } from "@/hooks/use-toast";
import {
  Card,
  CardContent,
  CardDescription,
  CardFooter,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { Textarea } from "@/components/ui/textarea";
import { Separator } from "@/components/ui/separator";

interface ShareEventProps {
  event: {
    id: string;
    title: string;
    description: string;
    startDate: string;
    location: {
      venue: string;
      address: string;
    };
  };
}

export function ShareEvent({ event }: ShareEventProps) {
  const [copied, setCopied] = useState(false);
  const [inviteEmails, setInviteEmails] = useState("");
  const [inviteMessage, setInviteMessage] = useState("");
  const { toast } = useToast();
  const eventUrl = `${window.location.origin}/events/${event.id}`;

  const copyToClipboard = async () => {
    try {
      await navigator.clipboard.writeText(eventUrl);
      setCopied(true);
      toast({
        description: "Link copied to clipboard",
        duration: 2000,
      });
      setTimeout(() => setCopied(false), 2000);
    } catch (err) {
      console.error("Failed to copy text: ", err);
      toast({
        variant: "destructive",
        description: "Failed to copy link",
      });
    }
  };

  const shareViaEmail = () => {
    const subject = encodeURIComponent(event.title);
    const body = encodeURIComponent(
      `Check out this event: ${event.title}\n\n${event.description}\n\nDate: ${new Date(event.startDate).toLocaleDateString()}\nLocation: ${event.location.venue}, ${event.location.address}\n\nView event details: ${eventUrl}`
    );
    window.open(`mailto:?subject=${subject}&body=${body}`);
  };

  const shareToSocialMedia = (platform: 'twitter' | 'facebook' | 'linkedin') => {
    const text = encodeURIComponent(`Check out this event: ${event.title}`);
    const url = encodeURIComponent(eventUrl);
    
    const links = {
      twitter: `https://twitter.com/intent/tweet?text=${text}&url=${url}`,
      facebook: `https://www.facebook.com/sharer/sharer.php?u=${url}`,
      linkedin: `https://www.linkedin.com/sharing/share-offsite/?url=${url}`
    };

    window.open(links[platform], '_blank', 'width=600,height=400');
  };

  const sendInvites = async () => {
    const emails = inviteEmails.split(',').map(email => email.trim()).filter(Boolean);
    
    if (emails.length === 0) {
      toast({
        variant: "destructive",
        description: "Please enter at least one email address",
      });
      return;
    }

    try {
      const response = await fetch(`/api/events/${event.id}/invite`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          emails,
          message: inviteMessage,
        }),
      });

      if (!response.ok) throw new Error('Failed to send invites');

      toast({
        description: "Invitations sent successfully",
      });
      
      // Clear the form
      setInviteEmails("");
      setInviteMessage("");
    } catch (error) {
      console.error('Error sending invites:', error);
      toast({
        variant: "destructive",
        description: "Failed to send invitations",
      });
    }
  };

  return (
    <Tabs defaultValue="share" className="w-full">
      <TabsList className="grid w-full grid-cols-2">
        <TabsTrigger value="share">Share</TabsTrigger>
        <TabsTrigger value="invite">Invite</TabsTrigger>
      </TabsList>

      <TabsContent value="share" className="space-y-4">
        <Card>
          <CardHeader>
            <CardTitle>Share Link</CardTitle>
            <CardDescription>
              Copy the event link or share directly to social media
            </CardDescription>
          </CardHeader>
          <CardContent className="space-y-4">
            <div className="flex space-x-2">
              <Input
                value={eventUrl}
                readOnly
                className="flex-1"
              />
              <Button 
                variant="outline" 
                size="icon"
                onClick={copyToClipboard}
              >
                {copied ? (
                  <Check className="h-4 w-4 text-green-500" />
                ) : (
                  <Copy className="h-4 w-4" />
                )}
              </Button>
            </div>
            
            <Separator className="my-4" />
            
            <div className="flex justify-between">
              <Button
                variant="outline"
                size="lg"
                className="flex-1 mx-1"
                onClick={() => shareToSocialMedia('twitter')}
              >
                <Twitter className="h-5 w-5 mr-2" />
                Twitter
              </Button>
              <Button
                variant="outline"
                size="lg"
                className="flex-1 mx-1"
                onClick={() => shareToSocialMedia('facebook')}
              >
                <Facebook className="h-5 w-5 mr-2" />
                Facebook
              </Button>
              <Button
                variant="outline"
                size="lg"
                className="flex-1 mx-1"
                onClick={() => shareToSocialMedia('linkedin')}
              >
                <Linkedin className="h-5 w-5 mr-2" />
                LinkedIn
              </Button>
              <Button
                variant="outline"
                size="lg"
                className="flex-1 mx-1"
                onClick={shareViaEmail}
              >
                <Mail className="h-5 w-5 mr-2" />
                Email
              </Button>
            </div>
          </CardContent>
        </Card>
      </TabsContent>

      <TabsContent value="invite" className="space-y-4">
        <Card>
          <CardHeader>
            <CardTitle>Invite People</CardTitle>
            <CardDescription>
              Send email invitations to your guests
            </CardDescription>
          </CardHeader>
          <CardContent className="space-y-4">
            <div className="space-y-2">
              <label className="text-sm font-medium">
                Email Addresses
              </label>
              <Input
                placeholder="Enter email addresses (comma-separated)"
                value={inviteEmails}
                onChange={(e) => setInviteEmails(e.target.value)}
              />
              <p className="text-sm text-muted-foreground">
                Separate multiple email addresses with commas
              </p>
            </div>
            
            <div className="space-y-2">
              <label className="text-sm font-medium">
                Personal Message (Optional)
              </label>
              <Textarea
                placeholder="Add a personal message to your invitation"
                value={inviteMessage}
                onChange={(e) => setInviteMessage(e.target.value)}
                className="h-32"
              />
            </div>
          </CardContent>
          <CardFooter>
            <Button 
              className="w-full"
              onClick={sendInvites}
            >
              <Mail className="h-4 w-4 mr-2" />
              Send Invitations
            </Button>
          </CardFooter>
        </Card>
      </TabsContent>
    </Tabs>
  );
}

================
File: src/components/events/venue-map.tsx
================
"use client";

import { useEffect, useState } from "react";
import { GoogleMap, Marker, LoadScript } from "@react-google-maps/api";

interface VenueMapProps {
  address: string;
  venue: string;
  onLocationSelected?: (location: { lat: number; lng: number }) => void;
  initialLocation?: { lat: number; lng: number };
  isEditable?: boolean;
}

export function VenueMap({
  address,
  venue,
  onLocationSelected,
  initialLocation,
  isEditable = false,
}: VenueMapProps) {
  const [location, setLocation] = useState(initialLocation);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    if (!initialLocation && address) {
      geocodeAddress();
    }
  }, [address]);

  const geocodeAddress = async () => {
    try {
      const response = await fetch(
        `https://maps.googleapis.com/maps/api/geocode/json?address=${encodeURIComponent(
          address
        )}&key=${process.env.NEXT_PUBLIC_GOOGLE_MAPS_API_KEY}`
      );
      const data = await response.json();
      if (data.results[0]) {
        const { lat, lng } = data.results[0].geometry.location;
        setLocation({ lat, lng });
        if (onLocationSelected) {
          onLocationSelected({ lat, lng });
        }
      }
    } catch (error) {
      console.error("Error geocoding address:", error);
    } finally {
      setLoading(false);
    }
  };

  const handleMapClick = (e: google.maps.MapMouseEvent) => {
    if (isEditable && onLocationSelected) {
      const lat = e.latLng?.lat();
      const lng = e.latLng?.lng();
      if (lat && lng) {
        setLocation({ lat, lng });
        onLocationSelected({ lat, lng });
      }
    }
  };

  if (loading || !location) return <div>Loading map...</div>;

  return (
    <LoadScript googleMapsApiKey={process.env.NEXT_PUBLIC_GOOGLE_MAPS_API_KEY!}>
      <GoogleMap
        mapContainerStyle={{ width: "100%", height: "400px" }}
        center={location}
        zoom={15}
        onClick={handleMapClick}
      >
        <Marker
          position={location}
          title={venue}
          draggable={isEditable}
          onDragEnd={(e) => {
            if (onLocationSelected && e.latLng) {
              const newLoc = {
                lat: e.latLng.lat(),
                lng: e.latLng.lng(),
              };
              setLocation(newLoc);
              onLocationSelected(newLoc);
            }
          }}
        />
      </GoogleMap>
    </LoadScript>
  );
}

================
File: src/components/export/export-button.tsx
================
"use client";

import { useState } from "react";
import { Button } from "@/components/ui/button";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import { Download, FileSpreadsheet, Files } from "lucide-react";
import { exportToExcel, exportToCSV } from "@/lib/export";

interface ExportButtonProps {
  data: any[];
  filename: string;
  type: "guests" | "events" | "analytics";
}

export function ExportButton({ data, filename, type }: ExportButtonProps) {
  const [loading, setLoading] = useState(false);

  const handleExport = async (format: "excel" | "csv") => {
    setLoading(true);
    try {
      if (format === "excel") {
        const columns = getColumnsForType(type);
        await exportToExcel(data, filename, [{ name: "Data", columns }]);
      } else {
        exportToCSV(data, filename);
      }
    } catch (error) {
      console.error("Export failed:", error);
    } finally {
      setLoading(false);
    }
  };

  const getColumnsForType = (type: string) => {
    const columnMappings = {
      guests: [
        { header: "Name", key: "name", width: 20 },
        { header: "Email", key: "email", width: 30 },
        { header: "Status", key: "status", width: 15 },
        { header: "Role", key: "role", width: 15 },
        { header: "Invited At", key: "invitedAt", width: 20 },
        { header: "Checked In", key: "checkedIn", width: 15 },
      ],
      events: [
        { header: "Title", key: "title", width: 30 },
        { header: "Date", key: "startDate", width: 20 },
        { header: "Location", key: "location.venue", width: 25 },
        { header: "Status", key: "status", width: 15 },
        { header: "Capacity", key: "capacity", width: 15 },
      ],
      analytics: [
        { header: "Metric", key: "metric", width: 25 },
        { header: "Value", key: "value", width: 20 },
        { header: "Date", key: "date", width: 20 },
      ],
    };

    return columnMappings[type as keyof typeof columnMappings] || [];
  };

  return (
    <DropdownMenu>
      <DropdownMenuTrigger asChild>
        <Button variant="outline" disabled={loading}>
          <Download className="mr-2 h-4 w-4" />
          Export
        </Button>
      </DropdownMenuTrigger>
      <DropdownMenuContent align="end">
        <DropdownMenuLabel>Choose Format</DropdownMenuLabel>
        <DropdownMenuSeparator />
        <DropdownMenuItem onClick={() => handleExport("excel")}>
          <FileSpreadsheet className="mr-2 h-4 w-4" />
          Export to Excel
        </DropdownMenuItem>
        <DropdownMenuItem onClick={() => handleExport("csv")}>
          <Files className="mr-2 h-4 w-4" />
          Export to CSV
        </DropdownMenuItem>
      </DropdownMenuContent>
    </DropdownMenu>
  );
}

================
File: src/components/filters/advanced-filter.tsx
================
"use client";

import { useState } from "react";
import { Button } from "@/components/ui/button";
import {
  Sheet,
  SheetContent,
  SheetDescription,
  SheetHeader,
  SheetTitle,
  SheetTrigger,
} from "@/components/ui/sheet";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Switch } from "@/components/ui/switch";
import { DatePicker } from "@/components/ui/date-picker";
import { Filter, SortAsc, SortDesc } from "lucide-react";

interface FilterConfig {
  field: string;
  operator: string;
  value: any;
}

interface SortConfig {
  field: string;
  direction: "asc" | "desc";
}

interface AdvancedFilterProps {
  onFilterChange: (filters: FilterConfig[]) => void;
  onSortChange: (sort: SortConfig[]) => void;
  fields: {
    name: string;
    type: "text" | "number" | "date" | "boolean" | "select";
    options?: string[];
  }[];
}

export function AdvancedFilter({
  onFilterChange,
  onSortChange,
  fields,
}: AdvancedFilterProps) {
  const [filters, setFilters] = useState<FilterConfig[]>([]);
  const [sorts, setSorts] = useState<SortConfig[]>([]);

  const addFilter = () => {
    const newFilter = {
      field: fields[0].name,
      operator: "equals",
      value: "",
    };
    setFilters([...filters, newFilter]);
  };

  const updateFilter = (index: number, updates: Partial<FilterConfig>) => {
    const newFilters = filters.map((filter, i) =>
      i === index ? { ...filter, ...updates } : filter
    );
    setFilters(newFilters);
    onFilterChange(newFilters);
  };

  const removeFilter = (index: number) => {
    const newFilters = filters.filter((_, i) => i !== index);
    setFilters(newFilters);
    onFilterChange(newFilters);
  };

  const addSort = () => {
    const newSort = {
      field: fields[0].name,
      direction: "asc" as const,
    };
    setSorts([...sorts, newSort]);
  };

  const updateSort = (index: number, updates: Partial<SortConfig>) => {
    const newSorts = sorts.map((sort, i) =>
      i === index ? { ...sort, ...updates } : sort
    );
    setSorts(newSorts);
    onSortChange(newSorts);
  };

  const removeSort = (index: number) => {
    const newSorts = sorts.filter((_, i) => i !== index);
    setSorts(newSorts);
    onSortChange(newSorts);
  };

  return (
    <Sheet>
      <SheetTrigger asChild>
        <Button variant="outline">
          <Filter className="mr-2 h-4 w-4" />
          Advanced Filters
        </Button>
      </SheetTrigger>
      <SheetContent className="w-[400px]">
        <SheetHeader>
          <SheetTitle>Advanced Filters</SheetTitle>
          <SheetDescription>
            Configure filters and sorting options
          </SheetDescription>
        </SheetHeader>

        <div className="py-4 space-y-4">
          <div className="space-y-4">
            <div className="flex items-center justify-between">
              <h3 className="font-medium">Filters</h3>
              <Button onClick={addFilter} variant="outline" size="sm">
                Add Filter
              </Button>
            </div>
            {filters.map((filter, index) => (
              <div key={index} className="space-y-2 p-2 border rounded-md">
                <Select
                  value={filter.field}
                  onValueChange={(value) =>
                    updateFilter(index, { field: value })
                  }
                >
                  <SelectTrigger>
                    <SelectValue placeholder="Select field" />
                  </SelectTrigger>
                  <SelectContent>
                    {fields.map((field) => (
                      <SelectItem key={field.name} value={field.name}>
                        {field.name}
                      </SelectItem>
                    ))}
                  </SelectContent>
                </Select>

                <Select
                  value={filter.operator}
                  onValueChange={(value) =>
                    updateFilter(index, { operator: value })
                  }
                >
                  <SelectTrigger>
                    <SelectValue placeholder="Select operator" />
                  </SelectTrigger>
                  <SelectContent>
                    <SelectItem value="equals">Equals</SelectItem>
                    <SelectItem value="contains">Contains</SelectItem>
                    <SelectItem value="greaterThan">Greater Than</SelectItem>
                    <SelectItem value="lessThan">Less Than</SelectItem>
                  </SelectContent>
                </Select>

                <Input
                  placeholder="Value"
                  value={filter.value}
                  onChange={(e) =>
                    updateFilter(index, { value: e.target.value })
                  }
                />

                <Button
                  variant="destructive"
                  size="sm"
                  onClick={() => removeFilter(index)}
                >
                  Remove
                </Button>
              </div>
            ))}
          </div>

          <div className="space-y-4">
            <div className="flex items-center justify-between">
              <h3 className="font-medium">Sorting</h3>
              <Button onClick={addSort} variant="outline" size="sm">
                Add Sort
              </Button>
            </div>
            {sorts.map((sort, index) => (
              <div key={index} className="space-y-2 p-2 border rounded-md">
                <Select
                  value={sort.field}
                  onValueChange={(value) =>
                    updateSort(index, { field: value })
                  }
                >
                  <SelectTrigger>
                    <SelectValue placeholder="Select field" />
                  </SelectTrigger>
                  <SelectContent>
                    {fields.map((field) => (
                      <SelectItem key={field.name} value={field.name}>
                        {field.name}
                      </SelectItem>
                    ))}
                  </SelectContent>
                </Select>

                <div className="flex items-center space-x-2">
                  <Button
                    variant="outline"
                    size="sm"
                    onClick={() =>
                      updateSort(index, {
                        direction: sort.direction === "asc" ? "desc" : "asc",
                      })
                    }
                  >
                    {sort.direction === "asc" ? (
                      <SortAsc className="h-4 w-4" />
                    ) : (
                      <SortDesc className="h-4 w-4" />
                    )}
                  </Button>
                  <Button
                    variant="destructive"
                    size="sm"
                    onClick={() => removeSort(index)}
                  >
                    Remove
                  </Button>
                </div>
              </div>
            ))}
          </div>
        </div>

        <div className="mt-4">
          <Button
            className="w-full"
            onClick={() => {
              onFilterChange(filters);
              onSortChange(sorts);
            }}
          >
            Apply Filters & Sorting
          </Button>
        </div>
      </SheetContent>
    </Sheet>
  );
}

================
File: src/components/layout/event-card.tsx
================
import {
    Card,
    CardContent,
    CardDescription,
    CardFooter,
    CardHeader,
    CardTitle,
  } from "@/components/ui/card";
  import { Badge } from "@/components/ui/badge";
  import { Button } from "@/components/ui/button";
  import { Calendar, Clock, MapPin, Users } from "lucide-react";
  import { format } from "date-fns";
  
  interface EventCardProps {
    event: {
      title: string;
      description: string;
      startDate: Date;
      endDate: Date;
      location: {
        venue: string;
      };
      capacity: number;
      status: string;
    };
  }
  
  export function EventCard({ event }: EventCardProps) {
    return (
      <Card>
        <CardHeader>
          <div className="flex items-center justify-between">
            <CardTitle className="line-clamp-1">{event.title}</CardTitle>
            <Badge variant={event.status === "published" ? "default" : "secondary"}>
              {event.status}
            </Badge>
          </div>
          <CardDescription className="line-clamp-2">
            {event.description}
          </CardDescription>
        </CardHeader>
        <CardContent className="space-y-2">
          <div className="flex items-center space-x-2 text-sm">
            <Calendar className="h-4 w-4" />
            <span>{format(new Date(event.startDate), "PPP")}</span>
          </div>
          <div className="flex items-center space-x-2 text-sm">
            <Clock className="h-4 w-4" />
            <span>{format(new Date(event.startDate), "p")}</span>
          </div>
          <div className="flex items-center space-x-2 text-sm">
            <MapPin className="h-4 w-4" />
            <span>{event.location.venue}</span>
          </div>
          <div className="flex items-center space-x-2 text-sm">
            <Users className="h-4 w-4" />
            <span>{event.capacity} attendees</span>
          </div>
        </CardContent>
        <CardFooter className="flex justify-between">
          <Button variant="outline">Edit</Button>
          <Button>View Details</Button>
        </CardFooter>
      </Card>
    );
  }

================
File: src/components/layout/main-nav.tsx
================
"use client";

import Link from "next/link";
import { usePathname } from "next/navigation";
import { cn } from "@/lib/utils";

export function MainNav() {
  const pathname = usePathname();

  const routes = [
    {
      href: "/dashboard",
      label: "Dashboard",
      active: pathname === "/dashboard",
    },
    {
      href: "/events",
      label: "Events",
      active: pathname === "/events",
    },
    {
      href: "/calendar",
      label: "Calendar",
      active: pathname === "/calendar",
    },
  ];

  return (
    <nav className="flex items-center space-x-4 lg:space-x-6">
      {routes.map((route) => (
        <Link
          key={route.href}
          href={route.href}
          className={cn(
            "text-sm font-medium transition-colors hover:text-primary",
            route.active ? "text-primary" : "text-muted-foreground"
          )}
        >
          {route.label}
        </Link>
      ))}
    </nav>
  );
}

================
File: src/components/layout/navbar.tsx
================
import { UserButton } from "@clerk/nextjs";
import { ModeToggle } from "../../components/mode-toggle";
import { MainNav } from "../../components/layout/main-nav";
import { Button } from "@/components/ui/button";
import Link from "next/link";
import { Plus } from "lucide-react";

export function Navbar() {
  return (
    <div className="border-b">
      <div className="flex h-16 items-center px-4">
        <div className="flex items-center space-x-4">
          <Link href="/" className="font-bold">
            Feest
          </Link>
          <MainNav />
        </div>
        <div className="ml-auto flex items-center space-x-4">
          <Button asChild variant="outline" size="sm">
            <Link href="/events/new">
              <Plus className="mr-2 h-4 w-4" />
              Create Event
            </Link>
          </Button>
          <ModeToggle />
          <UserButton />
        </div>
      </div>
    </div>
  );
}

================
File: src/components/providers/theme-provider.tsx
================
"use client"

import * as React from "react"
import { ThemeProvider as NextThemesProvider } from "next-themes"
import { type ThemeProviderProps } from "next-themes/dist/types"

export function ThemeProvider({ children, ...props }: ThemeProviderProps) {
  return <NextThemesProvider {...props}>{children}</NextThemesProvider>
}

================
File: src/components/mode-toggle.tsx
================
"use client"

import { Moon, Sun } from "lucide-react"
import { useTheme } from "next-themes"

import { Button } from "@/components/ui/button"
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu"

export function ModeToggle() {
  const { setTheme } = useTheme()

  return (
    <DropdownMenu>
      <DropdownMenuTrigger asChild>
        <Button variant="outline" size="icon">
          <Sun className="h-[1.2rem] w-[1.2rem] rotate-0 scale-100 transition-all dark:-rotate-90 dark:scale-0" />
          <Moon className="absolute h-[1.2rem] w-[1.2rem] rotate-90 scale-0 transition-all dark:rotate-0 dark:scale-100" />
          <span className="sr-only">Toggle theme</span>
        </Button>
      </DropdownMenuTrigger>
      <DropdownMenuContent align="end">
        <DropdownMenuItem onClick={() => setTheme("light")}>
          Light
        </DropdownMenuItem>
        <DropdownMenuItem onClick={() => setTheme("dark")}>
          Dark
        </DropdownMenuItem>
        <DropdownMenuItem onClick={() => setTheme("system")}>
          System
        </DropdownMenuItem>
      </DropdownMenuContent>
    </DropdownMenu>
  )
}

================
File: src/emails/event-invitation.tsx
================
// src/emails/event-invitation.tsx
import {
  Body,
  Button,
  Container,
  Head,
  Heading,
  Hr,
  Html,
  Preview,
  Section,
  Text,
} from "@react-email/components";
import * as React from "react";

interface EventInvitationProps {
  eventTitle: string;
  eventDate: string;
  eventTime: string;
  location: string;
  eventUrl: string;
  personalMessage?: string;
}

const EventInvitationEmail: React.FC<EventInvitationProps> = ({
  eventTitle,
  eventDate,
  eventTime,
  location,
  eventUrl,
  personalMessage,
}) => {
  const previewText = `You're invited to ${eventTitle}!`;

  return (
    <Html>
      <Head />
      <Preview>{previewText}</Preview>
      <Body style={main}>
        <Container style={container}>
          <Heading style={h1}>{eventTitle}</Heading>
          
          <Section style={section}>
            <Text style={text}>You've been invited to join this event!</Text>
            
            {personalMessage && (
              <>
                <Text style={messageBox}>{personalMessage}</Text>
                <Hr style={hr} />
              </>
            )}
            
            <Text style={detailsTitle}>Event Details:</Text>
            <Text style={details}>
              🗓️ Date: {eventDate}<br />
              ⏰ Time: {eventTime}<br />
              📍 Location: {location}
            </Text>

            <Button
              href={eventUrl}
              style={button}
            >
              View Event Details
            </Button>
          </Section>
        </Container>
      </Body>
    </Html>
  );
};

// Styles
const main = {
  backgroundColor: "#f6f9fc",
  fontFamily: '-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Ubuntu,sans-serif',
};

const container = {
  backgroundColor: "#ffffff",
  margin: "0 auto",
  padding: "20px 0 48px",
  marginBottom: "64px",
};

const section = {
  padding: "0 48px",
};

const h1 = {
  color: "#333",
  fontSize: "24px",
  fontWeight: "bold",
  margin: "40px 0",
  padding: "0",
  textAlign: "center" as const,
};

const text = {
  color: "#333",
  fontSize: "16px",
  margin: "24px 0",
};

const messageBox = {
  backgroundColor: "#f9f9f9",
  border: "1px solid #ddd",
  borderRadius: "5px",
  color: "#555",
  fontSize: "16px",
  margin: "24px 0",
  padding: "16px",
};

const detailsTitle = {
  color: "#333",
  fontSize: "18px",
  fontWeight: "bold",
  margin: "24px 0 8px",
};

const details = {
  color: "#555",
  fontSize: "16px",
  lineHeight: "24px",
  margin: "0 0 24px",
};

const button = {
  backgroundColor: "#000",
  borderRadius: "5px",
  color: "#fff",
  display: "block",
  fontSize: "16px",
  fontWeight: "bold",
  textAlign: "center" as const,
  textDecoration: "none",
  padding: "12px 20px",
  margin: "32px auto",
};

const hr = {
  borderColor: "#e6ebf1",
  margin: "20px 0",
};

export default EventInvitationEmail;

================
File: src/hooks/use-error-boundary.ts
================
import { useCallback, useState } from 'react';

export function useErrorBoundary() {
  const [hasError, setHasError] = useState(false);

  const handleError = useCallback((error: Error) => {
    setHasError(true);
    // Log to your error reporting service
    console.error('Error caught by boundary:', error);
  }, []);

  const resetError = useCallback(() => {
    setHasError(false);
  }, []);

  return {
    hasError,
    handleError,
    resetError,
  };
}

================
File: src/hooks/use-toast.ts
================
"use client"

// Inspired by react-hot-toast library
import * as React from "react"

import type {
  ToastActionElement,
  ToastProps,
} from "@/components/ui/toast"

const TOAST_LIMIT = 1
const TOAST_REMOVE_DELAY = 1000000

type ToasterToast = ToastProps & {
  id: string
  title?: React.ReactNode
  description?: React.ReactNode
  action?: ToastActionElement
}

const actionTypes = {
  ADD_TOAST: "ADD_TOAST",
  UPDATE_TOAST: "UPDATE_TOAST",
  DISMISS_TOAST: "DISMISS_TOAST",
  REMOVE_TOAST: "REMOVE_TOAST",
} as const

let count = 0

function genId() {
  count = (count + 1) % Number.MAX_SAFE_INTEGER
  return count.toString()
}

type ActionType = typeof actionTypes

type Action =
  | {
      type: ActionType["ADD_TOAST"]
      toast: ToasterToast
    }
  | {
      type: ActionType["UPDATE_TOAST"]
      toast: Partial<ToasterToast>
    }
  | {
      type: ActionType["DISMISS_TOAST"]
      toastId?: ToasterToast["id"]
    }
  | {
      type: ActionType["REMOVE_TOAST"]
      toastId?: ToasterToast["id"]
    }

interface State {
  toasts: ToasterToast[]
}

const toastTimeouts = new Map<string, ReturnType<typeof setTimeout>>()

const addToRemoveQueue = (toastId: string) => {
  if (toastTimeouts.has(toastId)) {
    return
  }

  const timeout = setTimeout(() => {
    toastTimeouts.delete(toastId)
    dispatch({
      type: "REMOVE_TOAST",
      toastId: toastId,
    })
  }, TOAST_REMOVE_DELAY)

  toastTimeouts.set(toastId, timeout)
}

export const reducer = (state: State, action: Action): State => {
  switch (action.type) {
    case "ADD_TOAST":
      return {
        ...state,
        toasts: [action.toast, ...state.toasts].slice(0, TOAST_LIMIT),
      }

    case "UPDATE_TOAST":
      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === action.toast.id ? { ...t, ...action.toast } : t
        ),
      }

    case "DISMISS_TOAST": {
      const { toastId } = action

      // ! Side effects ! - This could be extracted into a dismissToast() action,
      // but I'll keep it here for simplicity
      if (toastId) {
        addToRemoveQueue(toastId)
      } else {
        state.toasts.forEach((toast) => {
          addToRemoveQueue(toast.id)
        })
      }

      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === toastId || toastId === undefined
            ? {
                ...t,
                open: false,
              }
            : t
        ),
      }
    }
    case "REMOVE_TOAST":
      if (action.toastId === undefined) {
        return {
          ...state,
          toasts: [],
        }
      }
      return {
        ...state,
        toasts: state.toasts.filter((t) => t.id !== action.toastId),
      }
  }
}

const listeners: Array<(state: State) => void> = []

let memoryState: State = { toasts: [] }

function dispatch(action: Action) {
  memoryState = reducer(memoryState, action)
  listeners.forEach((listener) => {
    listener(memoryState)
  })
}

type Toast = Omit<ToasterToast, "id">

function toast({ ...props }: Toast) {
  const id = genId()

  const update = (props: ToasterToast) =>
    dispatch({
      type: "UPDATE_TOAST",
      toast: { ...props, id },
    })
  const dismiss = () => dispatch({ type: "DISMISS_TOAST", toastId: id })

  dispatch({
    type: "ADD_TOAST",
    toast: {
      ...props,
      id,
      open: true,
      onOpenChange: (open) => {
        if (!open) dismiss()
      },
    },
  })

  return {
    id: id,
    dismiss,
    update,
  }
}

function useToast() {
  const [state, setState] = React.useState<State>(memoryState)

  React.useEffect(() => {
    listeners.push(setState)
    return () => {
      const index = listeners.indexOf(setState)
      if (index > -1) {
        listeners.splice(index, 1)
      }
    }
  }, [state])

  return {
    ...state,
    toast,
    dismiss: (toastId?: string) => dispatch({ type: "DISMISS_TOAST", toastId }),
  }
}

export { useToast, toast }

================
File: src/lib/actions/events.ts
================
'use server'

import { auth } from "@clerk/nextjs/server";
import { revalidatePath } from "next/cache";
import dbConnect from "@/lib/db/connection";
import { Event } from "@/lib/db/models/event";
import { redirect } from "next/navigation";
import { z } from "zod";

const eventSchema = z.object({
  title: z.string().min(1),
  description: z.string(),
  startDate: z.string(),
  endDate: z.string(),
  venue: z.string(),
  address: z.string(),
  capacity: z.number().min(1)
});

export async function createEvent(formData: FormData) {
  const { userId } = await auth();
  
  if (!userId) {
    throw new Error("Unauthorized");
  }

  try {
    await dbConnect();
    
    const validatedFields = eventSchema.safeParse({
      title: formData.get('title'),
      description: formData.get('description'),
      startDate: formData.get('startDate'),
      endDate: formData.get('endDate'),
      venue: formData.get('venue'),
      address: formData.get('address'),
      capacity: Number(formData.get('capacity'))
    });

    if (!validatedFields.success) {
      return {
        error: "Invalid form data"
      };
    }

    const event = await Event.create({
      ...validatedFields.data,
      location: {
        venue: validatedFields.data.venue,
        address: validatedFields.data.address,
      },
      organizerId: userId,
      status: 'draft',
      visibility: 'private'
    });

    revalidatePath('/events');
    redirect(`/events/${event._id}`);
  } catch (error) {
    return {
      error: "Failed to create event"
    };
  }
}

================
File: src/lib/activity/notifications.ts
================
// src/lib/activity/notifications.ts

import mongoose from 'mongoose';
import { pusherServer } from "@/lib/pusher";

// Define specific activity types as constants
export const ActivityTypes = {
  // Event activities
  EVENT_CREATED: 'event.created',
  EVENT_UPDATED: 'event.updated',
  EVENT_CANCELLED: 'event.cancelled',
  
  // Guest activities
  GUEST_INVITED: 'guest.invited',
  GUEST_UPDATED: 'guest.updated',
  GUEST_REGISTERED: 'guest.registered',
  GUEST_CANCELLED: 'guest.cancelled',
  GUEST_CHECKED_IN: 'guest.checked_in',
  GUEST_REMOVED: 'guest.removed',
  GUEST_WAITLISTED: 'guest.waitlisted',
  GUEST_PROMOTED: 'guest.promoted', // When moved from waitlist to attendee
  
  // Communication activities
  COMMENT_ADDED: 'comment.added',
  MESSAGE_SENT: 'message.sent',
} as const;

// Create type from constants
export type ActivityType = typeof ActivityTypes[keyof typeof ActivityTypes];

// Activity interface
export interface Activity {
  type: ActivityType;
  userId: string;
  eventId: string;
  metadata?: Record<string, any>;
  createdAt: Date;
}

// Create Mongoose Schema for activities
const activitySchema = new mongoose.Schema({
  type: {
    type: String,
    required: true,
    enum: Object.values(ActivityTypes)
  },
  userId: {
    type: String,
    required: true,
  },
  eventId: {
    type: String,
    required: true,
  },
  metadata: {
    type: Map,
    of: mongoose.Schema.Types.Mixed,
    default: {},
  },
  createdAt: {
    type: Date,
    default: Date.now,
  },
}, {
  timestamps: true,
});

// Add indexes
activitySchema.index({ type: 1, eventId: 1 });
activitySchema.index({ userId: 1, createdAt: -1 });

// Create the model
const Activity = mongoose.models.Activity || mongoose.model('Activity', activitySchema);

export async function createActivity({
  type,
  userId,
  eventId,
  metadata = {}
}: Omit<Activity, 'createdAt'>) {
  try {
    // Create activity in database
    const activity = await Activity.create({
      type,
      userId,
      eventId,
      metadata,
    });

    // Trigger real-time update via Pusher
    await pusherServer.trigger(
      `event-${eventId}`,
      'new-activity',
      {
        type,
        userId,
        metadata,
        createdAt: activity.createdAt,
      }
    );

    // Also trigger user-specific activity
    await pusherServer.trigger(
      `user-${userId}`,
      'new-activity',
      {
        type,
        eventId,
        metadata,
        createdAt: activity.createdAt,
      }
    );

    return activity;
  } catch (error) {
    console.error('Error creating activity:', error);
    throw error;
  }
}

// Helper function to format activity messages
export function formatActivityMessage(activity: Activity): string {
  const messages: Record<ActivityType, string> = {
    [ActivityTypes.EVENT_CREATED]: "created a new event",
    [ActivityTypes.EVENT_UPDATED]: "updated event details",
    [ActivityTypes.EVENT_CANCELLED]: "cancelled the event",
    [ActivityTypes.GUEST_INVITED]: "invited a new guest",
    [ActivityTypes.GUEST_UPDATED]: "updated guest details",
    [ActivityTypes.GUEST_REGISTERED]: "registered for the event",
    [ActivityTypes.GUEST_CANCELLED]: "cancelled their registration",
    [ActivityTypes.GUEST_CHECKED_IN]: "checked in to the event",
    [ActivityTypes.GUEST_REMOVED]: "removed a guest",
    [ActivityTypes.GUEST_WAITLISTED]: "joined the waitlist",
    [ActivityTypes.GUEST_PROMOTED]: "was promoted from the waitlist",
    [ActivityTypes.COMMENT_ADDED]: "added a comment",
    [ActivityTypes.MESSAGE_SENT]: "sent a message"
  };

  return messages[activity.type] || "performed an action";
}

// Export activity types for use in other files
export { Activity as ActivityModel };

================
File: src/lib/api/error-handler.ts
================
import { NextResponse } from 'next/server';
import * as Sentry from '@sentry/nextjs';

export interface ApiError extends Error {
  code?: string;
  statusCode?: number;
  data?: any;
}

export class ApiError extends Error {
  constructor(message: string, statusCode: number = 500, code?: string, data?: any) {
    super(message);
    this.name = 'ApiError';
    this.statusCode = statusCode;
    this.code = code;
    this.data = data;
  }
}

export function handleApiError(error: unknown) {
  console.error('API Error:', error);

  // Log to Sentry
  Sentry.captureException(error);

  if (error instanceof ApiError) {
    return NextResponse.json(
      {
        error: {
          message: error.message,
          code: error.code,
          data: error.data,
        },
      },
      { status: error.statusCode }
    );
  }

  // Handle unknown errors
  return NextResponse.json(
    {
      error: {
        message: 'Internal Server Error',
        code: 'INTERNAL_SERVER_ERROR',
      },
    },
    { status: 500 }
  );
}

================
File: src/lib/auth/rate-limit.ts
================
import { Redis } from 'ioredis';
import { NextResponse } from 'next/server';

const redis = new Redis(process.env.REDIS_URL || '');

interface RateLimitConfig {
  limit: number;
  window: number; // in seconds
}

const defaultConfig: RateLimitConfig = {
  limit: 100,
  window: 60
};

export async function rateLimit(
  ip: string,
  endpoint: string,
  config: RateLimitConfig = defaultConfig
) {
  const key = `rate-limit:${ip}:${endpoint}`;
  
  const requests = await redis.incr(key);
  
  if (requests === 1) {
    await redis.expire(key, config.window);
  }

  if (requests > config.limit) {
    return new NextResponse('Too Many Requests', {
      status: 429,
      headers: {
        'Retry-After': config.window.toString()
      }
    });
  }

  return null;
}

================
File: src/lib/auth/rbac.ts
================
// src/lib/auth/rbac.ts
import { auth } from "@clerk/nextjs/server";
import { User } from "@/lib/db/models/user.model";
import { UserRole, Permission, PERMISSIONS } from "./types";
import { Redis } from '@upstash/redis';

const redis = new Redis({
  url: process.env.UPSTASH_REDIS_REST_URL!,
  token: process.env.UPSTASH_REDIS_REST_TOKEN!
});

export const rolePermissions: Record<UserRole, Permission[]> = {
  ADMIN: [{ action: '*', resource: '*' }],
  ORGANIZER: [
    { action: PERMISSIONS.EVENTS.CREATE, resource: 'event' },
    { action: PERMISSIONS.EVENTS.UPDATE, resource: 'event' },
    { action: PERMISSIONS.EVENTS.DELETE, resource: 'event' },
    { action: PERMISSIONS.EVENTS.MANAGE_GUESTS, resource: 'guests' }
  ],
  CO_HOST: [
    { action: PERMISSIONS.EVENTS.UPDATE, resource: 'event' },
    { action: PERMISSIONS.EVENTS.MANAGE_GUESTS, resource: 'guests' }
  ],
  ATTENDEE: [
    { action: PERMISSIONS.EVENTS.READ, resource: 'event' }
  ]
};

export async function getUserRole(): Promise<UserRole> {
  const { userId } = await auth();
  if (!userId) throw new Error('Unauthorized');

  // Try cache first
  const cachedRole = await redis.get(`user_role:${userId}`);
  if (cachedRole) return cachedRole as UserRole;

  // If not in cache, check database
  const user = await User.findOne({ clerkId: userId }).select('role');
  if (!user) {
    // Create user if doesn't exist
    const newUser = await User.create({
      clerkId: userId,
      role: UserRole.ATTENDEE
    });
    return newUser.role;
  }

  // Cache the role for 1 hour
  await redis.setex(`user_role:${userId}`, 3600, user.role);
  return user.role;
}

export async function hasPermission(permission: Permission): Promise<boolean> {
  try {
    const role = await getUserRole();
    const permissions = rolePermissions[role];

    return permissions.some(p => 
      (p.action === '*' && p.resource === '*') ||
      (p.action === permission.action && p.resource === permission.resource)
    );
  } catch {
    return false;
  }
}

================
File: src/lib/auth/roles.ts
================
export enum UserRole {
    ADMIN = 'ADMIN',
    ORGANIZER = 'ORGANIZER',
    CO_HOST = 'CO_HOST',
    ATTENDEE = 'ATTENDEE'
}
  
export interface Permission {
    action: string;
    resource: string;
}
  
export const rolePermissions: Record<UserRole, Permission[]> = {
    ADMIN: [
      { action: '*', resource: '*' }
    ],
    ORGANIZER: [
      { action: 'create', resource: 'event' },
      { action: 'update', resource: 'event' },
      { action: 'delete', resource: 'event' },
      { action: 'manage', resource: 'guests' },
      { action: 'export', resource: 'data' }
    ],
    CO_HOST: [
      { action: 'update', resource: 'event' },
      { action: 'manage', resource: 'guests' }
    ],
    ATTENDEE: [
      { action: 'view', resource: 'event' },
      { action: 'chat', resource: 'event' }
    ]
}

================
File: src/lib/auth/types.ts
================
export enum UserRole {
    ADMIN = 'ADMIN',
    ORGANIZER = 'ORGANIZER',
    CO_HOST = 'CO_HOST',
    ATTENDEE = 'ATTENDEE'
}
  
export interface Permission {
    action: string;
    resource: string;
}
  
export const PERMISSIONS = {
    EVENTS: {
      CREATE: 'events:create',
      READ: 'events:read',
      UPDATE: 'events:update',
      DELETE: 'events:delete',
      MANAGE_GUESTS: 'events:manage_guests'
    },
    ADMIN: {
      MANAGE_USERS: 'admin:manage_users',
      MANAGE_ROLES: 'admin:manage_roles'
    }
} as const;

================
File: src/lib/constants/event-categories.ts
================
export const EVENT_CATEGORIES = [
    "Conference",
    "Workshop",
    "Webinar",
    "Meetup",
    "Training",
    "Social",
    "Networking",
    "Other"
] as const;
  
export const EVENT_TAGS = [
    "Technology",
    "Business",
    "Education",
    "Entertainment",
    "Health",
    "Sports",
    "Art",
    "Music",
    "Science",
    "Professional Development"
] as const;
  
export type EventCategory = typeof EVENT_CATEGORIES[number];
export type EventTag = typeof EVENT_TAGS[number];

================
File: src/lib/db/models/activity.ts
================
// src/lib/db/models/activity.ts
import mongoose, { Schema, Document, Types } from "mongoose";

export interface IActivity extends Document {
  type: string;
  userId: string;
  eventId: string;
  metadata?: Record<string, any>;
  createdAt: Date;
  updatedAt: Date;
}

const ActivitySchema = new Schema({
  type: {
    type: String,
    required: true,
    enum: [
      'event.created',
      'event.updated',
      'event.cancelled',
      'event.deleted',
      'guest.invited',
      'guest.confirmed',
      'guest.declined',
      'guest.checked_in',
      'guest.removed',
      'message.sent',
      'cohost.added',
      'cohost.removed',
      'settings.updated',
      'export.generated'
    ]
  },
  userId: {
    type: String,
    required: true,
    index: true
  },
  eventId: {
    type: String,
    required: true,
    index: true
  },
  metadata: {
    type: Schema.Types.Mixed,
    default: {}
  }
}, {
  timestamps: true,
  toJSON: {
    virtuals: true,
    transform: function(doc, ret) {
      ret.id = ret._id;
      delete ret._id;
      delete ret.__v;
      return ret;
    }
  }
});

// Compound indexes for efficient querying
ActivitySchema.index({ eventId: 1, createdAt: -1 });
ActivitySchema.index({ userId: 1, createdAt: -1 });
ActivitySchema.index({ type: 1, eventId: 1 });

// Add text index for search functionality
ActivitySchema.index({
  'metadata.guestName': 'text',
  'metadata.changes': 'text'
});

// Middleware to validate metadata based on activity type
ActivitySchema.pre('save', function(next) {
  const activity = this as IActivity;
  
  // Validate metadata based on activity type
  switch (activity.type) {
    case 'event.updated':
      if (!activity.metadata?.changes) {
        return next(new Error('Event update activity requires changes in metadata'));
      }
      break;
      
    case 'guest.invited':
    case 'guest.confirmed':
    case 'guest.declined':
    case 'guest.checked_in':
    case 'guest.removed':
      if (!activity.metadata?.guestId) {
        return next(new Error('Guest-related activity requires guestId in metadata'));
      }
      break;
      
    case 'message.sent':
      if (!activity.metadata?.messageId) {
        return next(new Error('Message activity requires messageId in metadata'));
      }
      break;
  }
  
  next();
});

// Static methods
ActivitySchema.statics = {
  /**
   * Get recent activities for an event
   */
  async getRecentEventActivities(eventId: string, limit = 20) {
    return this.find({ eventId })
      .sort({ createdAt: -1 })
      .limit(limit)
      .exec();
  },

  /**
   * Get recent activities for a user
   */
  async getUserActivities(userId: string, limit = 20) {
    return this.find({ userId })
      .sort({ createdAt: -1 })
      .limit(limit)
      .exec();
  },

  /**
   * Get activities by type
   */
  async getActivitiesByType(type: string, eventId?: string) {
    const query = eventId ? { type, eventId } : { type };
    return this.find(query)
      .sort({ createdAt: -1 })
      .exec();
  },

  /**
   * Search activities
   */
  async searchActivities(searchTerm: string, eventId?: string) {
    const query = eventId 
      ? { eventId, $text: { $search: searchTerm } }
      : { $text: { $search: searchTerm } };
      
    return this.find(query)
      .sort({ score: { $meta: "textScore" } })
      .exec();
  }
};

// Instance methods
ActivitySchema.methods = {
  /**
   * Format activity message
   */
  formatMessage() {
    const messages: Record<string, string> = {
      'event.created': 'created a new event',
      'event.updated': 'updated event details',
      'event.cancelled': 'cancelled the event',
      'event.deleted': 'deleted the event',
      'guest.invited': 'invited a new guest',
      'guest.confirmed': 'confirmed attendance',
      'guest.declined': 'declined attendance',
      'guest.checked_in': 'checked in to the event',
      'guest.removed': 'removed a guest',
      'message.sent': 'sent a message',
      'cohost.added': 'added a co-host',
      'cohost.removed': 'removed a co-host',
      'settings.updated': 'updated event settings',
      'export.generated': 'generated an export'
    };

    return messages[this.type] || 'performed an action';
  }
};

// Create model
const Activity = mongoose.models.Activity || mongoose.model<IActivity>('Activity', ActivitySchema);

export { Activity };

================
File: src/lib/db/models/event.ts
================
// src/lib/db/models/event.ts
import mongoose, { Schema, Document } from "mongoose";

export interface IEvent extends Document {
  title: string;
  description: string;
  startDate: Date;
  endDate: Date;
  location: {
    venue: string;
    address: string;
    coordinates?: {
      lat: number;
      lng: number;
    };
  };
  capacity: number;
  status: "draft" | "published" | "cancelled";
  visibility: "public" | "private";
  organizerId: string;
  coHosts: string[];
  recurring?: {
    pattern: "daily" | "weekly" | "monthly";
    interval: number;
    endDate: Date;
  };
}

const EventSchema = new Schema({
  title: { type: String, required: true },
  description: { type: String, required: true },
  startDate: { type: Date, required: true },
  endDate: { type: Date, required: true },
  location: {
    venue: { type: String, required: true, default: 'No venue specified' },
    address: { type: String, required: true, default: 'No address specified' },
    coordinates: {
      lat: Number,
      lng: Number
    }
  },
  capacity: { type: Number, required: true },
  status: {
    type: String,
    enum: ["draft", "published", "cancelled"],
    default: "draft"
  },
  visibility: {
    type: String,
    enum: ["public", "private"],
    default: "private"
  },
  organizerId: { type: String, required: true },
  coHosts: [{ type: String }],
  recurring: {
    pattern: {
      type: String,
      enum: ["daily", "weekly", "monthly"]
    },
    interval: Number,
    endDate: Date
  }
}, {
  timestamps: true,
  toJSON: {
    virtuals: true,
    transform: function(doc, ret) {
      ret.id = ret._id.toString();
      delete ret._id;
      delete ret.__v;
      return ret;
    }
  }
});

// Create indexes
EventSchema.index({ organizerId: 1, startDate: -1 });
EventSchema.index({ status: 1 });
EventSchema.index({ "location?.venue": 1 });
EventSchema.index({ title: "text", description: "text" });

const Event = mongoose.models.Event || mongoose.model<IEvent>("Event", EventSchema);

export { Event };

================
File: src/lib/db/models/guest.ts
================
import mongoose from 'mongoose';

const guestSchema = new mongoose.Schema({
  eventId: { 
    type: String, 
    required: true 
  },
  userId: { 
    type: String, 
    required: true 
  },
  name: { 
    type: String, 
    required: true 
  },
  email: { 
    type: String, 
    required: true 
  },
  status: { 
    type: String, 
    enum: ['invited', 'confirmed', 'declined', 'waitlist'],
    default: 'invited' 
  },
  role: {
    type: String,
    enum: ['attendee', 'coHost', 'moderator'],
    default: 'attendee'
  },
  dietaryPreferences: [String],
  plusOne: {
    name: String,
    dietaryPreferences: [String]
  },
  checkedIn: {
    type: Boolean,
    default: false
  },
  checkedInAt: Date,
  invitedBy: String,
  invitedAt: {
    type: Date,
    default: Date.now
  },
  responseDate: Date,
  notes: String
}, {
  timestamps: true
});

// Add compound index to prevent duplicate registrations
guestSchema.index({ eventId: 1, status: 1 });
guestSchema.index({ userId: 1, eventId: 1 }, { unique: true });
guestSchema.index({ email: 1 });

export const Guest = mongoose.models.Guest || mongoose.model('Guest', guestSchema);

================
File: src/lib/db/models/message.ts
================
import mongoose from 'mongoose';

const messageSchema = new mongoose.Schema({
  eventId: {
    type: String,
    required: true
  },
  senderId: {
    type: String,
    required: true
  },
  senderName: {
    type: String,
    required: true
  },
  senderAvatar: String,
  content: {
    type: String,
    required: true
  },
  type: {
    type: String,
    enum: ['text', 'announcement', 'system'],
    default: 'text'
  },
  replyTo: {
    messageId: String,
    content: String
  },
  attachments: [{
    name: String,
    url: String,
    type: String
  }],
  readBy: [{
    userId: String,
    readAt: Date
  }]
}, {
  timestamps: true
});

messageSchema.index({ eventId: 1, createdAt: -1 });
messageSchema.index({ senderId: 1 });

export const Message = mongoose.models.Message || mongoose.model('Message', messageSchema);

================
File: src/lib/db/models/user.model.ts
================
import mongoose from 'mongoose';
import { UserRole } from '@/lib/auth/types';

const userSchema = new mongoose.Schema({
  clerkId: {
    type: String,
    required: true,
    unique: true
  },
  email: {
    type: String,
    required: true,
    unique: true
  },
  role: {
    type: String,
    enum: Object.values(UserRole),
    default: UserRole.ATTENDEE
  },
  permissions: [{
    type: String
  }],
  lastLogin: Date,
  apiKey: String,
  apiKeyLastUsed: Date
}, { timestamps: true });

export const User = mongoose.models.User || mongoose.model('User', userSchema);

================
File: src/lib/db/models/waitlist.ts
================
import mongoose, { Schema, Document } from "mongoose";

export interface IWaitlist extends Document {
  eventId: string;
  userId: string;
  position: number;
  joinedAt: Date;
  status: "waiting" | "promoted" | "expired";
  notificationsSent: {
    promoted?: Date;
    reminder?: Date;
  };
}

const WaitlistSchema = new Schema({
  eventId: { type: String, required: true },
  userId: { type: String, required: true },
  position: { type: Number, required: true },
  joinedAt: { type: Date, default: Date.now },
  status: {
    type: String,
    enum: ["waiting", "promoted", "expired"],
    default: "waiting"
  },
  notificationsSent: {
    promoted: Date,
    reminder: Date
  }
}, {
  timestamps: true
});

// Create compound index for unique waitlist entries
WaitlistSchema.index({ eventId: 1, userId: 1 }, { unique: true });
WaitlistSchema.index({ eventId: 1, position: 1 });

export const Waitlist = mongoose.models.Waitlist || mongoose.model<IWaitlist>("Waitlist", WaitlistSchema);

================
File: src/lib/db/utils/monitor.ts
================
import mongoose from 'mongoose';
import { analyzeQueryPerformance } from './performance';

export async function monitorDatabasePerformance(
    model: mongoose.Model<any>,
    operation: string,
    query: object
) {
    if (process.env.NODE_ENV === 'development') {
      const startTime = Date.now();
      const stats = await analyzeQueryPerformance(model, query);
      const duration = Date.now() - startTime;
  
      console.log(`
        Operation: ${operation}
        Duration: ${duration}ms
        Docs Examined: ${stats.totalDocsExamined}
        Docs Returned: ${stats.nReturned}
        Indexes Used: ${stats.indexesUsed.join(', ') || 'None'}
      `);
    }
}

================
File: src/lib/db/utils/performance.ts
================
import mongoose from 'mongoose';

interface ExecutionStats {
  executionTimeMillis: number;
  totalDocsExamined: number;
  nReturned: number;
  indexesUsed: string[];
}

export async function analyzeQueryPerformance(
  model: mongoose.Model<any>,
  query: object,
  options: object = {}
): Promise<ExecutionStats> {
  try {
    const explanation = await model.find(query, null, options)
      .explain("executionStats") as any;

    return {
      executionTimeMillis: explanation.executionStats.executionTimeMillis,
      totalDocsExamined: explanation.executionStats.totalDocsExamined,
      nReturned: explanation.executionStats.nReturned,
      indexesUsed: explanation.queryPlanner.winningPlan.inputStage?.indexName 
        ? [explanation.queryPlanner.winningPlan.inputStage.indexName]
        : []
    };
  } catch (error) {
    console.error('Query performance analysis failed:', error);
    throw error;
  }
}

================
File: src/lib/db/connection.ts
================
import mongoose from 'mongoose';

const MONGODB_URI = process.env.DATABASE_URL as string;

if (!MONGODB_URI) {
  throw new Error('Please define the DATABASE_URL environment variable inside .env');
}

interface MongooseCache {
  conn: typeof mongoose | null;
  promise: Promise<typeof mongoose> | null;
}

// Declare the type for the global mongoose property
declare global {
  var mongoose: MongooseCache | undefined;
}

let cached = global.mongoose || { conn: null, promise: null };

if (!global.mongoose) {
  global.mongoose = cached;
}

mongoose.set('autoIndex', false); // Disable in production
mongoose.set('maxTimeMS', 30000); // Set operation timeout

async function dbConnect() {
  if (cached.conn) {
    return cached.conn;
  }

  if (!cached.promise) {
    const opts = {
      bufferCommands: false,
    };

    cached.promise = mongoose.connect(MONGODB_URI, opts).then((mongoose) => {
      return mongoose;
    });
  }

  try {
    cached.conn = await cached.promise;
  } catch (e) {
    cached.promise = null;
    throw e;
  }

  return cached.conn;
}

export default dbConnect;

================
File: src/lib/email/notifications.ts
================
// src/lib/email/notifications.ts
import { Resend } from 'resend';
import EventInvitation  from '@/emails/event-invitation';
import { render } from '@react-email/render';
import React from 'react';

const resend = new Resend(process.env.RESEND_API_KEY);

export interface InvitationParams {
    recipientEmail: string;
    eventTitle: string;
    eventDate: string;
    eventTime: string;
    location: string;
    eventUrl: string;
    personalMessage?: string;
}

export async function sendEventInvitation({
    recipientEmail,
    eventTitle,
    eventDate,
    eventTime,
    location,
    eventUrl,
    personalMessage,
  }: InvitationParams) {
    try {
      // Create the email component
      const emailComponent = React.createElement(EventInvitation, {
        eventTitle,
        eventDate,
        eventTime,
        location,
        eventUrl,
        personalMessage,
      });
  
      // Render the email
      const emailHtml = render(emailComponent);
  
      const { data, error } = await resend.emails.send({
        from: 'Event Platform <events@yourdomain.com>',
        to: recipientEmail,
        subject: `You're invited to ${eventTitle}!`,
        html: (await emailHtml).toString(),
      });
  
      if (error) {
        console.error('Error sending invitation email:', error);
        throw new Error('Failed to send invitation email');
      }
  
      return data;
    } catch (error) {
      console.error('Error in sendEventInvitation:', error);
      throw error;
    }
  }

// Utility function to format date and time
export function formatDateTime(date: Date) {
  const formattedDate = date.toLocaleDateString('en-US', {
    weekday: 'long',
    year: 'numeric',
    month: 'long',
    day: 'numeric',
  });

  const formattedTime = date.toLocaleTimeString('en-US', {
    hour: 'numeric',
    minute: '2-digit',
    hour12: true,
  });

  return { formattedDate, formattedTime };
}

// Updated interfaces for other email functions
interface ReminderParams {
  recipientEmail: string;
  eventId: string;
  eventTitle: string;
  startDate: Date;
  location: string;
}

interface UpdateParams {
  recipientEmail: string;
  eventId: string;
  eventTitle: string;
  changes: string[];
}

export async function sendEventReminder({
  recipientEmail,
  eventId,
  eventTitle,
  startDate,
  location,
}: ReminderParams) {
  const { formattedDate, formattedTime } = formatDateTime(startDate);
  const eventUrl = `${process.env.NEXT_PUBLIC_APP_URL}/events/${eventId}`;

  try {
    const emailHtml = `
      <h1>Reminder: ${eventTitle} is coming up!</h1>
      <p>This is a reminder that you have an upcoming event:</p>
      <ul>
        <li>Event: ${eventTitle}</li>
        <li>Date: ${formattedDate}</li>
        <li>Time: ${formattedTime}</li>
        <li>Location: ${location}</li>
      </ul>
      <p>View event details: <a href="${eventUrl}">${eventUrl}</a></p>
    `;

    const { data, error } = await resend.emails.send({
      from: 'Event Platform <events@yourdomain.com>',
      to: recipientEmail,
      subject: `Reminder: ${eventTitle}`,
      html: emailHtml,
    });

    if (error) throw error;
    return data;
  } catch (error) {
    console.error('Error in sendEventReminder:', error);
    throw error;
  }
}

export async function sendEventUpdate({
  recipientEmail,
  eventId,
  eventTitle,
  changes,
}: UpdateParams) {
  const eventUrl = `${process.env.NEXT_PUBLIC_APP_URL}/events/${eventId}`;

  try {
    const emailHtml = `
      <h1>Event Update: ${eventTitle}</h1>
      <p>The following changes have been made to the event:</p>
      <ul>
        ${changes.map(change => `<li>${change}</li>`).join('')}
      </ul>
      <p>View updated event details: <a href="${eventUrl}">${eventUrl}</a></p>
    `;

    const { data, error } = await resend.emails.send({
      from: 'Event Platform <events@yourdomain.com>',
      to: recipientEmail,
      subject: `Event Update: ${eventTitle}`,
      html: emailHtml,
    });

    if (error) throw error;
    return data;
  } catch (error) {
    console.error('Error in sendEventUpdate:', error);
    throw error;
  }
}

================
File: src/lib/export/index.ts
================
import ExcelJS from 'exceljs';
import { saveAs } from 'file-saver';
import Papa from 'papaparse';

export async function exportToExcel(data: any[], filename: string, sheets: { name: string; columns: any[] }[]) {
  const workbook = new ExcelJS.Workbook();

  sheets.forEach(({ name, columns }) => {
    const worksheet = workbook.addWorksheet(name);
    worksheet.columns = columns;
    worksheet.addRows(data);
  });

  const buffer = await workbook.xlsx.writeBuffer();
  const blob = new Blob([buffer], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
  saveAs(blob, `${filename}.xlsx`);
}

export function exportToCSV(data: any[], filename: string) {
  const csv = Papa.unparse(data);
  const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
  saveAs(blob, `${filename}.csv`);
}

================
File: src/lib/validation/event.ts
================
import * as z from "zod";
import { EVENT_CATEGORIES, EVENT_TAGS } from "@/lib/constants/event-categories";

export const eventFormSchema = z.object({
  title: z.string().min(2).max(100),
  description: z.string().min(10),
  startDate: z.date(),
  endDate: z.date(),
  registrationDeadline: z.date(),
  categories: z.array(z.string()).min(1, "Select at least one category"),
  tags: z.array(z.string()),
  venue: z.string().min(2),
  address: z.string().min(5),
  isVirtual: z.boolean().default(false),
  virtualLink: z.string().url().optional().nullable(),
  isHybrid: z.boolean().default(false),
  capacity: z.string().transform(Number),
  visibility: z.enum(["public", "private"]),
  recurring: z.object({
    enabled: z.boolean().default(false),
    pattern: z.enum(["daily", "weekly", "monthly"]).optional().nullable(),
    interval: z.number().optional().nullable(),
    endDate: z.date().optional().nullable(),
    daysOfWeek: z.array(z.number()).optional().nullable(),
    dayOfMonth: z.number().optional().nullable(),
  }),
  waitlist: z.object({
    enabled: z.boolean().default(false),
    maxSize: z.number().min(0).default(0),
  }),
}).refine(data => data.endDate > data.startDate, {
  message: "End date must be after start date",
  path: ["endDate"],
}).refine(data => data.registrationDeadline <= data.startDate, {
  message: "Registration deadline must be before or on the event start date",
  path: ["registrationDeadline"],
});

================
File: src/lib/validation/sanitize.ts
================
import DOMPurify from 'isomorphic-dompurify';
import { z } from 'zod';

export function sanitizeInput(input: string): string {
  return DOMPurify.sanitize(input.trim(), {
    ALLOWED_TAGS: [], // Strip all HTML tags
    ALLOWED_ATTR: [] // Strip all attributes
  });
}

// Common validation schemas
export const eventSchema = z.object({
  title: z.string()
    .min(3, 'Title must be at least 3 characters')
    .max(100, 'Title must be less than 100 characters')
    .transform(sanitizeInput),
  
  description: z.string()
    .min(10, 'Description must be at least 10 characters')
    .max(1000, 'Description must be less than 1000 characters')
    .transform(sanitizeInput),
  
  startDate: z.date()
    .min(new Date(), 'Start date must be in the future'),
  
  endDate: z.date(),
  
  location: z.object({
    venue: z.string().min(3).transform(sanitizeInput),
    address: z.string().min(5).transform(sanitizeInput),
    coordinates: z.object({
      lat: z.number(),
      lng: z.number()
    }).optional()
  }),
  
  capacity: z.number()
    .min(1, 'Capacity must be at least 1')
    .max(100000, 'Capacity must be less than 100,000'),
  
  visibility: z.enum(['public', 'private'])
}).refine(data => data.endDate > data.startDate, {
  message: "End date must be after start date",
  path: ["endDate"]
});

================
File: src/lib/auth.ts
================
import { auth } from "@clerk/nextjs/server";
import { redirect } from "next/navigation";

export const initialProfile = async () => {
  const { userId } = await auth();

  if (!userId) {
    redirect("/sign-in");
  }

  return userId;
};

================
File: src/lib/google-calendar.ts
================
import { google } from 'googleapis';
import { OAuth2Client } from 'google-auth-library';

const oauth2Client = new OAuth2Client(
  process.env.GOOGLE_CLIENT_ID,
  process.env.GOOGLE_CLIENT_SECRET,
  process.env.GOOGLE_REDIRECT_URI
);

export async function addToGoogleCalendar(event: any, accessToken: string) {
  try {
    oauth2Client.setCredentials({ access_token: accessToken });
    const calendar = google.calendar({ version: 'v3', auth: oauth2Client });

    const calendarEvent = {
      summary: event.title,
      description: event.description,
      start: {
        dateTime: event.startDate,
        timeZone: 'UTC',
      },
      end: {
        dateTime: event.endDate,
        timeZone: 'UTC',
      },
      location: `${event.location.venue}, ${event.location.address}`,
      attendees: event.guests.map((guest: any) => ({
        email: guest.email,
      })),
      reminders: {
        useDefault: false,
        overrides: [
          { method: 'email', minutes: 24 * 60 },
          { method: 'popup', minutes: 30 },
        ],
      },
    };

    const response = await calendar.events.insert({
      calendarId: 'primary',
      requestBody: calendarEvent,
      sendUpdates: 'all',
    });

    return response.data;
  } catch (error) {
    console.error('Error adding event to Google Calendar:', error);
    throw error;
  }
}

================
File: src/lib/logger.ts
================
// src/lib/logger.ts
import * as Sentry from '@sentry/nextjs';

type LogLevel = 'info' | 'warn' | 'error' | 'debug';

interface LogData {
  message: string;
  [key: string]: any;
}

class Logger {
  private context?: string;

  constructor(context?: string) {
    this.context = context;
  }

  private log(level: LogLevel, data: LogData) {
    const timestamp = new Date().toISOString();
    const logData = {
      timestamp,
      level,
      context: this.context,
      ...data,
    };

    // Console logging
    const logMessage = `[${timestamp}] [${level.toUpperCase()}] ${
      this.context ? `[${this.context}] ` : ''
    }${data.message}`;

    switch (level) {
      case 'error':
        console.error(logMessage, data);
        Sentry.captureException(data.error || new Error(data.message), {
          extra: data,
        });
        break;
      case 'warn':
        console.warn(logMessage, data);
        Sentry.captureMessage(data.message, {
          level: 'warning',
          extra: data,
        });
        break;
      case 'info':
        console.info(logMessage, data);
        break;
      case 'debug':
        if (process.env.NODE_ENV === 'development') {
          console.debug(logMessage, data);
        }
        break;
    }
  }

  info(message: string, data: Record<string, any> = {}) {
    this.log('info', { message, ...data });
  }

  warn(message: string, data: Record<string, any> = {}) {
    this.log('warn', { message, ...data });
  }

  error(message: string, error?: Error, data: Record<string, any> = {}) {
    this.log('error', { message, error, ...data });
  }

  debug(message: string, data: Record<string, any> = {}) {
    this.log('debug', { message, ...data });
  }
}

export const logWebhookError = async (error: any, eventType: string) => {
  console.error(`Webhook Error (${eventType}):`, error);
  // Add your production logging service here (e.g., Sentry, LogRocket)
};

export const logger = new Logger();

================
File: src/lib/pusher.ts
================
import PusherServer from "pusher";
import PusherClient from "pusher-js";

export const pusherServer = new PusherServer({
  appId: process.env.PUSHER_APP_ID!,
  key: process.env.NEXT_PUBLIC_PUSHER_APP_KEY!,
  secret: process.env.PUSHER_SECRET!,
  cluster: process.env.NEXT_PUBLIC_PUSHER_CLUSTER!,
  useTLS: true,
});

export const pusherClient = new PusherClient(
  process.env.NEXT_PUBLIC_PUSHER_APP_KEY!,
  {
    cluster: process.env.NEXT_PUBLIC_PUSHER_CLUSTER!,
  }
);

================
File: src/lib/rate-limit.ts
================
import { Redis } from '@upstash/redis';
import { Ratelimit } from '@upstash/ratelimit';

const redis = new Redis({
  url: process.env.UPSTASH_REDIS_REST_URL!,
  token: process.env.UPSTASH_REDIS_REST_TOKEN!
});

const limiter = new Ratelimit({
  redis,
  limiter: Ratelimit.slidingWindow(10, '10 s'),
});

export async function rateLimit(identifier: string, endpoint: string) {
  const { success, limit, reset, remaining } = await limiter.limit(
    `${identifier}:${endpoint}`
  );
  
  return { success, limit, reset, remaining };
}

================
File: src/lib/utils.ts
================
import { type ClassValue, clsx } from "clsx";
import { twMerge } from "tailwind-merge";

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs));
}

export function serializeEvent(event: any) {
  if (!event) return null;
  
  const eventObj = event.toObject ? event.toObject() : event;
  
  return {
    id: eventObj._id.toString(),
    title: eventObj.title,
    description: eventObj.description,
    startDate: new Date(eventObj.startDate).toISOString(),
    endDate: new Date(eventObj.endDate).toISOString(),
    location: {
      venue: eventObj.location?.venue || '',
      address: eventObj.location?.address || '',
      coordinates: eventObj.location?.coordinates || null,
    },
    capacity: eventObj.capacity,
    status: eventObj.status,
    visibility: eventObj.visibility,
    organizerId: eventObj.organizerId,
    coHosts: eventObj.coHosts || [],
    recurring: eventObj.recurring || null,
    createdAt: new Date(eventObj.createdAt).toISOString(),
    updatedAt: new Date(eventObj.updatedAt).toISOString(),
    attendees: {
      confirmed: 0,
      waitlist: 0,
    },
  };
}

================
File: src/mocks/browser.ts
================
import { setupWorker } from 'msw/browser';
import { handlers } from './handlers';

export const worker = setupWorker(...handlers);

================
File: src/mocks/handlers.ts
================
import { http, HttpResponse } from 'msw';

export const handlers = [
  // Events endpoints
  http.get('/api/events', async () => {
    return HttpResponse.json([
      {
        id: '1',
        title: 'Mock Conference 2024',
        description: 'A mock event for testing',
        startDate: new Date('2024-12-01'),
        endDate: new Date('2024-12-02'),
        location: {
          venue: 'Mock Venue',
          address: '123 Test Street',
        },
        capacity: 100,
        status: 'published',
        visibility: 'public',
        organizerId: 'user_123',
        coHosts: []
      }
    ]);
  }),

  // Event stats endpoint
  http.get('/api/events/stats', async () => {
    return HttpResponse.json({
      totalEvents: 10,
      upcomingEvents: 5,
      totalAttendees: 150,
      averageAttendance: 85
    });
  }),

  // Event activities endpoint
  http.get('/api/activities', async () => {
    return HttpResponse.json([
      {
        id: '1',
        type: 'event_created',
        eventId: '1',
        userId: 'user_123',
        createdAt: new Date().toISOString()
      }
    ]);
  }),

  // Guest management endpoints
  http.get('/api/events/:eventId/guests', async () => {
    return HttpResponse.json([
      {
        id: '1',
        eventId: '1',
        userId: 'guest_123',
        status: 'confirmed',
        checkedIn: false
      }
    ]);
  })
];

================
File: src/mocks/server.ts
================
import { setupServer } from 'msw/node';
import { handlers } from './handlers';

export const server = setupServer(...handlers);

================
File: src/types/event.ts
================
interface Event {
    id: string;
    title: string;
    description: string;
    startDate: Date;
    endDate: Date;
    location: {
      address: string;
      coordinates: {
        lat: number;
        lng: number;
      };
      venue: string;
    };
    capacity: number;
    status: 'draft' | 'published' | 'cancelled';
    visibility: 'public' | 'private';
    organizerId: string;
    coHosts: string[];
    moderators: string[];
    recurring?: {
      pattern: 'daily' | 'weekly' | 'monthly';
      interval: number;
      endDate: Date;
    };
    createdAt: Date;
    updatedAt: Date;
  }

================
File: src/instrumentation.ts
================
import * as Sentry from "@sentry/nextjs";

export async function register() {
  if (process.env.NEXT_RUNTIME === "nodejs") {
    Sentry.init({
      dsn: process.env.NEXT_PUBLIC_SENTRY_DSN,
      tracesSampleRate: 1.0,
      debug: process.env.NODE_ENV === "development",
      integrations: [
        // Add Node.js specific integrations
        Sentry.httpIntegration(),
        Sentry.nodeContextIntegration(),
      ],
    });
  }

  if (process.env.NEXT_RUNTIME === "edge") {
    Sentry.init({
      dsn: process.env.NEXT_PUBLIC_SENTRY_DSN,
      tracesSampleRate: 1.0,
      debug: process.env.NODE_ENV === "development",
    });
  }
}

================
File: src/middleware.ts
================
import { clerkMiddleware, createRouteMatcher } from '@clerk/nextjs/server';
import { NextResponse, type NextRequest } from "next/server";
import { Redis } from '@upstash/redis';
import { Ratelimit } from '@upstash/ratelimit';

// Constants
const RATE_LIMIT = 100;
const RATE_LIMIT_WINDOW = '15 m';

// Route matchers
const protectedRoutes = createRouteMatcher([
  '/dashboard(.*)', 
  '/forum(.*)',
  '/events(.*)'
]);

const authRoutes = createRouteMatcher([
  '/sign-in(.*)',
  '/sign-up(.*)'
]);

// Initialize Redis
const redis = new Redis({
  url: process.env.UPSTASH_REDIS_REST_URL!,
  token: process.env.UPSTASH_REDIS_REST_TOKEN!
});

// Initialize rate limiter
const rateLimiter = new Ratelimit({
  redis,
  limiter: Ratelimit.slidingWindow(RATE_LIMIT, RATE_LIMIT_WINDOW),
  analytics: true,
});


// Security headers
const securityHeaders = {
  'X-Content-Type-Options': 'nosniff',
  'X-Frame-Options': 'DENY',
  'X-XSS-Protection': '1; mode=block',
  'Referrer-Policy': 'strict-origin-when-cross-origin',
  'Permissions-Policy': 'camera=(), microphone=(), geolocation=()'
};

// Helper functions
async function handleRateLimit(req: NextRequest) {
  const ip = req.headers.get('x-forwarded-for') ?? '127.0.0.1';
  const { success, remaining, reset } = await rateLimiter.limit(`${ip}:${req.nextUrl.pathname}`);

  if (!success) {
    return new NextResponse('Too Many Requests', {
      status: 429,
      headers: {
        'X-RateLimit-Limit': RATE_LIMIT.toString(),
        'X-RateLimit-Remaining': remaining.toString(),
        'X-RateLimit-Reset': reset.toString(),
      },
    });
  }
  return null;
}

async function getUserRole(userId: string) {
  const cachedRole = await redis.get(`user_role:${userId}`);
  return cachedRole || 'ATTENDEE';
}

async function createSecureResponse(req: NextRequest, userId: string) {
  const requestHeaders = new Headers(req.headers);
  requestHeaders.set('x-user-id', userId);
  
  const userRole = await getUserRole(userId);
  requestHeaders.set('x-user-role', userRole.toString());

  const response = NextResponse.next({
    request: { headers: requestHeaders },
  });

  // Add security headers
  Object.entries(securityHeaders).forEach(([header, value]) => {
    response.headers.set(header, value);
  });

  return response;
}

// Main middleware
export default clerkMiddleware(async (auth, req) => {
  try {
    const { userId, redirectToSignIn } = await auth();

    // Check rate limit
    const rateLimitResponse = await handleRateLimit(req);
    if (rateLimitResponse) return rateLimitResponse;

    
    // Handle authentication
    if (!userId && protectedRoutes(req)) {
      return redirectToSignIn({
        returnBackUrl: new URL(req.url).pathname,
      });
    }

    if (userId && authRoutes(req)) {
      return Response.redirect(new URL('/dashboard', req.url));
    }

    // Add security headers and user info for authenticated requests
    if (userId) {
      return createSecureResponse(req, userId);
    }

    return NextResponse.next();
  } catch (error) {
    console.error('Middleware Error:', error);
    return new NextResponse('Internal Server Error', { status: 500 });
  }
});

export const config = {
  matcher: [
    '/((?!_next/static|_next/image|favicon.ico).*)',
    '/api/:path*',
    '/(.*)',
  ],
};


================
File: components.json
================
{
  "$schema": "https://ui.shadcn.com/schema.json",
  "style": "default",
  "rsc": true,
  "tsx": true,
  "tailwind": {
    "config": "tailwind.config.ts",
    "css": "src/app/globals.css",
    "baseColor": "slate",
    "cssVariables": true,
    "prefix": ""
  },
  "aliases": {
    "components": "@/components",
    "utils": "@/lib/utils",
    "ui": "@/components/ui",
    "lib": "@/lib",
    "hooks": "@/hooks"
  }
}

================
File: jest.config.ts
================
import type { Config } from 'jest';
import nextJest from 'next/jest';

const createJestConfig = nextJest({
  dir: './',
});

const config: Config = {
  setupFilesAfterEnv: ['<rootDir>/jest.setup.ts'],
  testEnvironment: 'jest-environment-jsdom',
  moduleNameMapper: {
    '^@/components/(.*)$': '<rootDir>/src/components/$1',
    '^@/lib/(.*)$': '<rootDir>/src/lib/$1',
  },
  collectCoverageFrom: [
    'src/**/*.{js,jsx,ts,tsx}',
    '!src/**/*.d.ts',
    '!src/**/*.stories.{js,jsx,ts,tsx}',
  ],
  testMatch: [
    '<rootDir>/src/**/__tests__/**/*.{js,jsx,ts,tsx}',
    '<rootDir>/src/**/*.{spec,test}.{js,jsx,ts,tsx}',
  ],
};

export default createJestConfig(config);

================
File: jest.setup.ts
================
// jest.setup.ts
import '@testing-library/jest-dom';
import 'whatwg-fetch';
import { server } from './src/mocks/server';

beforeAll(() => server.listen());
afterEach(() => server.resetHandlers());
afterAll(() => server.close());

================
File: next.config.mjs
================
/** @type {import('next').NextConfig} */

import { withSentryConfig } from "@sentry/nextjs";

const nextConfig = {
  // Image optimization configuration
  images: {
    domains: ['res.cloudinary.com', 'uploadthing.com'],
    unoptimized: process.env.NODE_ENV === 'development',
    deviceSizes: [640, 750, 828, 1080, 1200, 1920, 2048],
    imageSizes: [16, 32, 48, 64, 96, 128, 256, 384],
  },

  // Environment variables
  env: {
    NEXT_PUBLIC_API_URL: process.env.NEXT_PUBLIC_API_URL,
  },

  // Security headers
  async headers() {
    return [
      {
        source: '/:path*',
        headers: [
          {
            key: 'X-DNS-Prefetch-Control',
            value: 'on'
          },
          {
            key: 'Strict-Transport-Security',
            value: 'max-age=31536000; includeSubDomains'
          },
          {
            key: 'X-Frame-Options',
            value: 'SAMEORIGIN'
          },
          {
            key: 'X-Content-Type-Options',
            value: 'nosniff'
          },
          {
            key: 'X-XSS-Protection',
            value: '1; mode=block'
          },
          {
            key: 'Referrer-Policy',
            value: 'origin-when-cross-origin'
          },
          {
            key: 'Permissions-Policy',
            value: 'camera=(), microphone=(), geolocation=(), interest-cohort=()'
          }
        ]
      }
    ];
  },

  // Webpack configuration
  webpack: (config, { isServer, dev }) => {
    // Handle OpenTelemetry instrumentation warnings
    config.ignoreWarnings = [
      // Ignore warnings about critical dependency
      /Critical dependency: the request of a dependency is an expression/,
    ];

    // Handle external packages that need special treatment
    if (isServer) {
      config.externals = [...config.externals,
        'utf-8-validate',
        'bufferutil',
      ];
    }

    // Handle OpenTelemetry instrumentation packages
    if (!isServer) {
      config.resolve.fallback = {
        ...config.resolve.fallback,
        'perf_hooks': false,
        'diagnostics_channel': false,
      };
    }

    // Enable source maps in production
    if (!dev && !isServer) {
      config.devtool = 'source-map';
    }

    return config;
  },

  // Performance optimizations
  swcMinify: true,
  reactStrictMode: true,
  poweredByHeader: false,
  compress: true,
  generateEtags: true,

  // Cache optimization
  onDemandEntries: {
    maxInactiveAge: 25 * 1000,
    pagesBufferLength: 2,
  },

  // Experimental features
  experimental: {
    serverComponentsExternalPackages: ['mongoose'],
    instrumentationHook: true,    
  },

  // Redirects
  async redirects() {
    return [
      {
        source: '/home',
        destination: '/',
        permanent: true,
      }
    ];
  }
};

export default withSentryConfig(
  nextConfig,
  {
    org: "feest",
    project: "Shareflyt",
    authToken: process.env.SENTRY_AUTH_TOKEN,
    widenClientFileUpload: true,
    transpileClientSDK: true,
    tunnelRoute: "/monitoring",
    hideSourceMaps: true,
    disableLogger: true,
  }
);

================
File: package.json
================
{
  "name": "feest-2",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint"
  },
  "dependencies": {
    "@clerk/clerk-sdk-node": "^5.0.54",
    "@clerk/nextjs": "^6.0.2",
    "@hookform/resolvers": "^3.9.1",
    "@radix-ui/react-avatar": "^1.1.1",
    "@radix-ui/react-dialog": "^1.1.2",
    "@radix-ui/react-dropdown-menu": "^2.1.2",
    "@radix-ui/react-label": "^2.1.0",
    "@radix-ui/react-popover": "^1.1.2",
    "@radix-ui/react-radio-group": "^1.2.1",
    "@radix-ui/react-scroll-area": "^1.2.0",
    "@radix-ui/react-select": "^2.1.2",
    "@radix-ui/react-separator": "^1.1.0",
    "@radix-ui/react-slot": "^1.1.0",
    "@radix-ui/react-switch": "^1.1.1",
    "@radix-ui/react-tabs": "^1.1.1",
    "@radix-ui/react-toast": "^1.2.2",
    "@radix-ui/react-tooltip": "^1.1.3",
    "@react-email/components": "^0.0.25",
    "@react-google-maps/api": "^2.20.3",
    "@sentry/nextjs": "^8.36.0",
    "@tanstack/react-query": "^5.59.16",
    "@uploadthing/react": "^7.1.0",
    "@upstash/ratelimit": "^2.0.4",
    "@upstash/redis": "^1.34.3",
    "axios": "^1.7.7",
    "class-variance-authority": "^0.7.0",
    "clsx": "^2.1.1",
    "csv-writer": "^1.6.0",
    "date-fns": "^2.30.0",
    "exceljs": "^4.4.0",
    "express-rate-limit": "^7.4.1",
    "file-saver": "^2.0.5",
    "google-auth-library": "^9.14.2",
    "googleapis": "^144.0.0",
    "ioredis": "^5.4.1",
    "isomorphic-dompurify": "^2.16.0",
    "jest": "^29.7.0",
    "lucide-react": "^0.454.0",
    "moment": "^2.30.1",
    "mongoose": "^8.7.3",
    "next": "14.2.16",
    "next-themes": "^0.3.0",
    "papaparse": "^5.4.1",
    "pusher": "^5.2.0",
    "pusher-js": "^8.4.0-rc2",
    "qrcode.react": "^4.1.0",
    "react": "^18",
    "react-big-calendar": "^1.15.0",
    "react-day-picker": "^8.10.1",
    "react-dom": "^18",
    "react-error-boundary": "^4.1.2",
    "react-hook-form": "^7.53.1",
    "recharts": "^2.13.2",
    "resend": "^4.0.1-alpha.0",
    "socket.io-client": "^4.8.1",
    "svix": "^1.37.0",
    "tailwind-merge": "^2.5.4",
    "tailwindcss-animate": "^1.0.7",
    "uploadthing": "^7.2.0",
    "zod": "^3.23.8"
  },
  "devDependencies": {
    "@types/file-saver": "^2.0.7",
    "@types/node": "^20.17.4",
    "@types/papaparse": "^5.3.15",
    "@types/react": "^18.3.12",
    "@types/react-big-calendar": "^1.15.0",
    "@types/react-dom": "^18.3.1",
    "msw": "^2.6.0",
    "postcss": "^8",
    "prettier": "^3.3.3",
    "prettier-plugin-tailwindcss": "^0.6.8",
    "tailwindcss": "^3.4.1",
    "typescript": "^5"
  }
}

================
File: postcss.config.mjs
================
/** @type {import('postcss-load-config').Config} */
const config = {
  plugins: {
    tailwindcss: {},
  },
};

export default config;

================
File: sentry.server.config.ts
================
import * as Sentry from "@sentry/nextjs";

Sentry.init({
  dsn: process.env.NEXT_PUBLIC_SENTRY_DSN,
  tracesSampleRate: 1.0,
  debug: process.env.NODE_ENV === 'development',
  environment: process.env.NODE_ENV,
});

================
File: service-worker.js
================
importScripts("https://js.pusher.com/beams/service-worker.js");

================
File: tailwind.config.ts
================
import type { Config } from "tailwindcss";

const config: Config = {
    darkMode: ["class"],
    content: [
    "./src/pages/**/*.{js,ts,jsx,tsx,mdx}",
    "./src/components/**/*.{js,ts,jsx,tsx,mdx}",
    "./src/app/**/*.{js,ts,jsx,tsx,mdx}",
  ],
  theme: {
  	extend: {
  		colors: {
  			background: 'hsl(var(--background))',
  			foreground: 'hsl(var(--foreground))',
  			card: {
  				DEFAULT: 'hsl(var(--card))',
  				foreground: 'hsl(var(--card-foreground))'
  			},
  			popover: {
  				DEFAULT: 'hsl(var(--popover))',
  				foreground: 'hsl(var(--popover-foreground))'
  			},
  			primary: {
  				DEFAULT: 'hsl(var(--primary))',
  				foreground: 'hsl(var(--primary-foreground))'
  			},
  			secondary: {
  				DEFAULT: 'hsl(var(--secondary))',
  				foreground: 'hsl(var(--secondary-foreground))'
  			},
  			muted: {
  				DEFAULT: 'hsl(var(--muted))',
  				foreground: 'hsl(var(--muted-foreground))'
  			},
  			accent: {
  				DEFAULT: 'hsl(var(--accent))',
  				foreground: 'hsl(var(--accent-foreground))'
  			},
  			destructive: {
  				DEFAULT: 'hsl(var(--destructive))',
  				foreground: 'hsl(var(--destructive-foreground))'
  			},
  			border: 'hsl(var(--border))',
  			input: 'hsl(var(--input))',
  			ring: 'hsl(var(--ring))',
  			chart: {
  				'1': 'hsl(var(--chart-1))',
  				'2': 'hsl(var(--chart-2))',
  				'3': 'hsl(var(--chart-3))',
  				'4': 'hsl(var(--chart-4))',
  				'5': 'hsl(var(--chart-5))'
  			}
  		},
  		borderRadius: {
  			lg: 'var(--radius)',
  			md: 'calc(var(--radius) - 2px)',
  			sm: 'calc(var(--radius) - 4px)'
  		}
  	}
  },
  plugins: [require("tailwindcss-animate")],
};
export default config;

================
File: tsconfig.json
================
{
  "compilerOptions": {
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}
