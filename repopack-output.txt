================================================================
File Summary
================================================================

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line


================================================================
Repository Structure
================================================================
src/
  app/
    (auth)/
      sign-in/
        [[...sign-in]]/
          page.tsx
      sign-up/
        [[...sign-up]]/
          page.tsx
    (dashboard)/
      calendar/
        page.tsx
      dashboard/
        page.tsx
      events/
        [eventId]/
          edit/
            page.tsx
          loading.tsx
          page.tsx
        new/
          page.tsx
        page.tsx
      layout.tsx
    api/
      activities/
        route.ts
      events/
        [eventId]/
          activities/
            route.ts
          chat/
            route.ts
          check-in/
            route.ts
          export/
            route.ts
          guests/
            [guestId]/
              route.ts
            route.ts
          invite/
            route.ts
          stats/
            route.ts
          route.ts
        route.ts
      users/
        [userId]/
          route.ts
    globals.css
    layout.tsx
    page.tsx
  components/
    activity/
      activity-feed.tsx
    calendar/
      event-calendar.tsx
    dashboard/
      charts.tsx
      event-stats.tsx
      recent-activity.tsx
      upcoming-events.tsx
    events/
      check-in.tsx
      event-card.tsx
      event-chat.tsx
      event-form.tsx
      guest-list.tsx
      share-event.tsx
      venue-map.tsx
    export/
      export-button.tsx
    filters/
      advanced-filter.tsx
    layout/
      event-card.tsx
      main-nav.tsx
      navbar.tsx
    providers/
      theme-provider.tsx
    ui/
      avatar.tsx
      badge.tsx
      button.tsx
      calendar.tsx
      card.tsx
      date-picker.tsx
      dialog.tsx
      dropdown-menu.tsx
      form.tsx
      input.tsx
      label.tsx
      popover.tsx
      scroll-area.tsx
      select.tsx
      separator.tsx
      sheet.tsx
      skeleton.tsx
      switch.tsx
      table.tsx
      tabs.tsx
      textarea.tsx
      toast.tsx
      toaster.tsx
      tooltip.tsx
    mode-toggle.tsx
  emails/
    event-invitation.tsx
  hooks/
    use-toast.ts
  lib/
    activity/
      notifications.ts
    db/
      models/
        activity.ts
        event.ts
        guest.ts
        message.ts
      connection.ts
    email/
      notifications.ts
    export/
      index.ts
    auth.ts
    google-calendar.ts
    pusher.ts
    utils.ts
  types/
    event.ts
  middleware.ts

components.json
next.config.mjs
package.json
postcss.config.mjs
tailwind.config.ts
tsconfig.json

================================================================
Repository Files
================================================================

================
File: src/app/(auth)/sign-in/[[...sign-in]]/page.tsx
================
import { SignIn } from "@clerk/nextjs";

export default function SignInPage() {
  return (
    <div className="flex h-screen items-center justify-center">
      <SignIn 
        appearance={{
          elements: {
            formButtonPrimary: 'bg-primary text-primary-foreground hover:bg-primary/90',
            footerActionLink: 'text-primary hover:text-primary/90'
          }
        }}
      />
    </div>
  );
}

================
File: src/app/(auth)/sign-up/[[...sign-up]]/page.tsx
================
import { SignUp } from "@clerk/nextjs";

export default function SignUpPage() {
  return (
    <div className="flex h-screen items-center justify-center">
      <SignUp 
        appearance={{
          elements: {
            formButtonPrimary: 'bg-primary text-primary-foreground hover:bg-primary/90',
            footerActionLink: 'text-primary hover:text-primary/90'
          }
        }}
      />
    </div>
  );
}

================
File: src/app/(dashboard)/calendar/page.tsx
================
import { EventCalendar } from "@/components/calendar/event-calendar";

export default function CalendarPage() {
  return (
    <div className="space-y-4">
      <h1 className="text-3xl font-bold">Calendar</h1>
      <EventCalendar />
    </div>
  );
}

================
File: src/app/(dashboard)/dashboard/page.tsx
================
// src/app/(dashboard)/dashboard/page.tsx
import { auth } from "@clerk/nextjs/server";
import { redirect } from "next/navigation";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { DashboardCharts } from "@/components/dashboard/charts";
import { UpcomingEvents } from "@/components/dashboard/upcoming-events";
import { EventStats } from "@/components/dashboard/event-stats";
import { RecentActivity } from "@/components/dashboard/recent-activity";
import dbConnect from "@/lib/db/connection";
import { Event } from "@/lib/db/models/event";
import { Guest } from "@/lib/db/models/guest";

async function getEventStats(userId: string) {
  await dbConnect();

  const now = new Date();
  const thirtyDaysFromNow = new Date();
  thirtyDaysFromNow.setDate(now.getDate() + 30);

  try {
    const [
      totalEvents,
      upcomingEvents,
      totalAttendees,
      checkedInAttendees
    ] = await Promise.all([
      // Total events
      Event.countDocuments({ organizerId: userId }),
      
      // Upcoming events (next 30 days)
      Event.countDocuments({
        organizerId: userId,
        startDate: { $gte: now, $lte: thirtyDaysFromNow }
      }),
      
      // Total confirmed attendees across all events
      Guest.countDocuments({
        eventId: { 
          $in: (await Event.find({ organizerId: userId }).select('_id'))
            .map(event => event._id)
        },
        status: "confirmed"
      }),
      
      // Total checked-in attendees
      Guest.countDocuments({
        eventId: { 
          $in: (await Event.find({ organizerId: userId }).select('_id'))
            .map(event => event._id)
        },
        checkedIn: true
      })
    ]);

    const averageAttendance = totalAttendees > 0 
      ? Math.round((checkedInAttendees / totalAttendees) * 100)
      : 0;

    return {
      totalEvents,
      upcomingEvents,
      totalAttendees,
      averageAttendance
    };
  } catch (error) {
    console.error("Error fetching event stats:", error);
    return {
      totalEvents: 0,
      upcomingEvents: 0,
      totalAttendees: 0,
      averageAttendance: 0
    };
  }
}

export default async function DashboardPage() {
  const { userId } = await auth();
  if (!userId) redirect("/sign-in");

  const stats = await getEventStats(userId);

  return (
    <div className="space-y-8">
      <h1 className="text-3xl font-bold">Dashboard</h1>
      
      <div className="grid gap-4 md:grid-cols-2 lg:grid-cols-4">
        <EventStats stats={stats} />
      </div>

      <div className="grid gap-4 md:grid-cols-2 lg:grid-cols-7">
        <div className="md:col-span-4">
          <DashboardCharts />
        </div>
        <div className="md:col-span-3">
          <UpcomingEvents />
        </div>
      </div>

      <div className="grid gap-4 md:grid-cols-2">
        <Card>
          <CardHeader>
            <CardTitle>Recent Activity</CardTitle>
          </CardHeader>
          <CardContent>
            <RecentActivity />
          </CardContent>
        </Card>
      </div>
    </div>
  );
}

================
File: src/app/(dashboard)/events/[eventId]/edit/page.tsx
================
import { auth } from "@clerk/nextjs/server";
import { redirect } from "next/navigation";
import { Card } from "@/components/ui/card";
import { EventForm } from "@/components/events/event-form";
import { Event } from "@/lib/db/models/event";
import dbConnect from "@/lib/db/connection";

async function getEvent(eventId: string) {
  try {
    await dbConnect();
    const event = await Event.findById(eventId);
    if (!event) return null;
    return event.toObject();
  } catch (error) {
    console.error("Error fetching event:", error);
    return null;
  }
}

export default async function EditEventPage({
  params,
}: {
  params: { eventId: string };
}) {
  const { userId } = await auth();
  if (!userId) {
    redirect("/sign-in");
  }

  const event = await getEvent(params.eventId);
  if (!event) {
    redirect("/events");
  }

  return (
    <div className="max-w-4xl mx-auto space-y-4">
      <div className="space-y-2">
        <h1 className="text-3xl font-bold">Edit Event</h1>
        <p className="text-muted-foreground">
          Update your event details below.
        </p>
      </div>

      <Card className="p-6">
        <EventForm event={event} isEditing />
      </Card>
    </div>
  );
}

================
File: src/app/(dashboard)/events/[eventId]/loading.tsx
================
import { Skeleton } from "@/components/ui/skeleton";

export default function EventLoading() {
  return (
    <div className="space-y-6">
      <div className="space-y-2">
        <Skeleton className="h-8 w-1/3" />
        <Skeleton className="h-4 w-2/3" />
      </div>
      <div className="grid gap-6 md:grid-cols-2">
        <Skeleton className="h-[300px]" />
        <Skeleton className="h-[300px]" />
      </div>
    </div>
  );
}

================
File: src/app/(dashboard)/events/[eventId]/page.tsx
================
import { notFound } from "next/navigation";
import { format } from "date-fns";
import { 
  Calendar, 
  Clock, 
  MapPin, 
  Users, 
  Share2, 
  Download, 
  Mail, 
  MessageCircle,
  Settings,
  AlertCircle
} from "lucide-react";
import { Button } from "@/components/ui/button";
import { Card } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { Separator } from "@/components/ui/separator";
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/components/ui/tooltip";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogHeader,
  DialogTitle,
  DialogTrigger,
} from "@/components/ui/dialog";
import { GuestList } from "@/components/events/guest-list";
import { EventChat } from "@/components/events/event-chat";
import { ShareEvent } from "@/components/events/share-event";
import { auth } from "@clerk/nextjs/server";
import dbConnect from "@/lib/db/connection";
import { serializeEvent } from "@/lib/utils";

interface Event {
  id: string;
  title: string;
  description: string;
  startDate: string;
  endDate: string;
  location: {
    venue: string;
    address: string;
    coordinates?: {
      lat: number;
      lng: number;
    };
  };
  capacity: number;
  status: "draft" | "published" | "cancelled";
  visibility: "public" | "private";
  organizerId: string;
  coHosts: string[];
  attendees: {
    confirmed: number;
    waitlist: number;
  };
  recurring?: {
    pattern: "daily" | "weekly" | "monthly";
    interval: number;
    endDate: string;
  };
}

async function getEvent(eventId: string): Promise<Event | null> {
  try {
    await dbConnect();
    const event = await Event.findById(eventId);
    if (!event) return null;

    // Use the serialization utility
    return serializeEvent(event);
  } catch (error) {
    console.error("Error fetching event:", error);
    return null;
  }
}

export default async function EventPage({
  params,
}: {
  params: { eventId: string };
}) {
  const { userId } = await auth();
  const event = await getEvent(params.eventId);

  if (!event) {
    notFound();
  }

  const isOrganizer = userId === event.organizerId;
  const isCoHost = event.coHosts.includes(userId!);
  const canManageEvent = isOrganizer || isCoHost;

  const generateICalFile = async () => {
    // Implementation for generating iCal file
  };

  const sendReminders = async () => {
    // Implementation for sending reminders
  };

  return (
    <div className="space-y-6">
      {/* Header Section */}
      <div className="flex items-center justify-between">
        <div className="space-y-1">
          <div className="flex items-center space-x-2">
            <h1 className="text-3xl font-bold">{event.title}</h1>
            <Badge variant={event.status === "published" ? "default" : "secondary"}>
              {event.status}
            </Badge>
          </div>
          <p className="text-muted-foreground max-w-2xl">{event.description}</p>
        </div>
        
        {canManageEvent && (
          <DropdownMenu>
            <DropdownMenuTrigger asChild>
              <Button variant="outline" size="icon">
                <Settings className="h-4 w-4" />
              </Button>
            </DropdownMenuTrigger>
            <DropdownMenuContent align="end">
              <DropdownMenuLabel>Event Actions</DropdownMenuLabel>
              <DropdownMenuSeparator />
              <DropdownMenuItem>
                <Settings className="mr-2 h-4 w-4" /> Edit Event
              </DropdownMenuItem>
              <DropdownMenuItem>
                <Mail className="mr-2 h-4 w-4" /> Send Reminders
              </DropdownMenuItem>
              <DropdownMenuItem className="text-destructive">
                <AlertCircle className="mr-2 h-4 w-4" /> Cancel Event
              </DropdownMenuItem>
            </DropdownMenuContent>
          </DropdownMenu>
        )}
      </div>

      <div className="grid gap-6 md:grid-cols-3">
        {/* Event Details Card */}
        <Card className="p-6 space-y-4 md:col-span-2">
          <div className="flex items-center justify-between">
            <h2 className="text-xl font-semibold">Event Details</h2>
            <div className="flex space-x-2">
              <TooltipProvider>
                <Tooltip>
                  <TooltipTrigger asChild>
                    <Button variant="outline" size="icon">
                      <Share2 className="h-4 w-4" />
                    </Button>
                  </TooltipTrigger>
                  <TooltipContent>Share Event</TooltipContent>
                </Tooltip>
              </TooltipProvider>

              <TooltipProvider>
                <Tooltip>
                  <TooltipTrigger asChild>
                    <Button variant="outline" size="icon">
                      <Download className="h-4 w-4" />
                    </Button>
                  </TooltipTrigger>
                  <TooltipContent>Download iCal</TooltipContent>
                </Tooltip>
              </TooltipProvider>
            </div>
          </div>
          
          <Separator />
          
          <div className="grid gap-6 md:grid-cols-2">
            <div className="space-y-4">
              <div className="flex items-center space-x-2">
                <Calendar className="h-5 w-5 text-muted-foreground" />
                <div className="space-y-1">
                  <p className="font-medium">Date</p>
                  <p className="text-sm text-muted-foreground">
                    {format(new Date(event.startDate), "PPP")}
                  </p>
                </div>
              </div>
              
              <div className="flex items-center space-x-2">
                <Clock className="h-5 w-5 text-muted-foreground" />
                <div className="space-y-1">
                  <p className="font-medium">Time</p>
                  <p className="text-sm text-muted-foreground">
                    {format(new Date(event.startDate), "p")} - {format(new Date(event.endDate), "p")}
                  </p>
                </div>
              </div>
              
              {event.recurring && (
                <div className="flex items-center space-x-2">
                  <Calendar className="h-5 w-5 text-muted-foreground" />
                  <div className="space-y-1">
                    <p className="font-medium">Recurring</p>
                    <p className="text-sm text-muted-foreground capitalize">
                      {event.recurring.pattern}, every {event.recurring.interval} {event.recurring.pattern}(s)
                    </p>
                  </div>
                </div>
              )}
            </div>

            <div className="space-y-4">
              <div className="flex items-center space-x-2">
                <MapPin className="h-5 w-5 text-muted-foreground" />
                <div className="space-y-1">
                  <p className="font-medium">Location</p>
                  <p className="text-sm text-muted-foreground">
                    {event.location.venue}<br />
                    {event.location.address}
                  </p>
                </div>
              </div>
              
              <div className="flex items-center space-x-2">
                <Users className="h-5 w-5 text-muted-foreground" />
                <div className="space-y-1">
                  <p className="font-medium">Capacity</p>
                  <p className="text-sm text-muted-foreground">
                    {event.attendees?.confirmed || 0} confirmed / {event.capacity} maximum
                    {event.attendees?.waitlist > 0 && (
                      <span className="text-muted-foreground">
                        {" "}({event.attendees.waitlist} on waitlist)
                      </span>
                    )}
                  </p>
                </div>
              </div>
                          </div>
          </div>

          {/* Location Map */}
          {event.location.coordinates && (
            <div className="mt-6">
              <h3 className="text-lg font-semibold mb-2">Map</h3>
              <div className="h-[300px] rounded-lg overflow-hidden">
                {/* Add Google Maps Component Here */}
              </div>
            </div>
          )}
        </Card>

        {/* Guest List Card */}
        <Card className="p-6">
          <h2 className="text-xl font-semibold mb-4">Guest List</h2>
          <Separator className="mb-4" />
          <GuestList eventId={event.id} />
        </Card>
      </div>

      {/* Chat Section */}
      <Card className="p-6">
        <div className="flex items-center justify-between mb-4">
          <h2 className="text-xl font-semibold">Event Discussion</h2>
          <Button variant="outline" size="sm">
            <MessageCircle className="h-4 w-4 mr-2" />
            Chat Settings
          </Button>
        </div>
        <Separator className="mb-4" />
        <EventChat eventId={event.id} />
      </Card>

      {/* Share Dialog */}
      <Dialog>
        <DialogTrigger asChild>
          <Button variant="outline" className="fixed bottom-4 right-4">
            <Share2 className="h-4 w-4 mr-2" />
            Share Event
          </Button>
        </DialogTrigger>
        <DialogContent>
          <DialogHeader>
            <DialogTitle>Share Event</DialogTitle>
            <DialogDescription>
              Share this event with your network
            </DialogDescription>
          </DialogHeader>
          <ShareEvent event={event} />
        </DialogContent>
      </Dialog>
    </div>
  );
}

================
File: src/app/(dashboard)/events/new/page.tsx
================
// src/app/(dashboard)/events/new/page.tsx
import { auth } from "@clerk/nextjs/server";
import { redirect } from "next/navigation";
import { Card } from "@/components/ui/card";
import { EventForm } from "@/components/events/event-form";

export default async function NewEventPage() {
  const { userId } = await auth();
  if (!userId) {
    redirect("/sign-in");
  }

  return (
    <div className="max-w-4xl mx-auto space-y-4">
      <div className="space-y-2">
        <h1 className="text-3xl font-bold">Create New Event</h1>
        <p className="text-muted-foreground">
          Fill in the details below to create your event.
        </p>
      </div>

      <Card className="p-6">
        <EventForm />
      </Card>
    </div>
  );
}

================
File: src/app/(dashboard)/events/page.tsx
================
// src/app/(dashboard)/events/page.tsx
import { auth } from "@clerk/nextjs/server";
import { redirect } from "next/navigation";
import Link from "next/link";
import { Plus } from "lucide-react";
import { Button } from "@/components/ui/button";
import { EventCard } from "@/components/events/event-card";
import dbConnect from "@/lib/db/connection";

import { Event } from "../../../lib/db/models/event"; 

async function getEvents(userId: string) {
    try {
      await dbConnect();
      const events = await Event.find({ organizerId: userId })
        .sort({ createdAt: -1 })
        .lean();
  
      return events.map(event => ({
        ...event,
        id: event.id.toString(),
        _id: undefined
      }));
    } catch (error) {
      console.error("Error fetching events:", error);
      return [];
    }
}

export default async function EventsPage() {
  const { userId } = await auth();
  if (!userId) redirect("/sign-in");

  const events = await getEvents(userId);

  return (
    <div className="space-y-6">
      <div className="flex items-center justify-between">
        <h1 className="text-3xl font-bold">Events</h1>
        <Button asChild>
          <Link href="/events/new">
            <Plus className="mr-2 h-4 w-4" />
            Create Event
          </Link>
        </Button>
      </div>

      {events.length === 0 ? (
        <div className="flex flex-col items-center justify-center h-[60vh] space-y-4">
          <p className="text-muted-foreground">No events found</p>
          <Button asChild>
            <Link href="/events/new">Create your first event</Link>
          </Button>
        </div>
      ) : (
        <div className="grid gap-6 md:grid-cols-2 lg:grid-cols-3">
          {events.map((event) => (
            <EventCard key={event.id} event={event} />
          ))}
        </div>
      )}
    </div>
  );
}

================
File: src/app/(dashboard)/layout.tsx
================
import { Navbar } from "@/components/layout/navbar";
import { initialProfile } from "@/lib/auth";

export default async function DashboardLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  await initialProfile();

  return (
    <div className="h-full">
      <Navbar />
      <main className="container mx-auto h-full py-6">{children}</main>
    </div>
  );
}

================
File: src/app/api/activities/route.ts
================
import { NextRequest, NextResponse } from "next/server";
import { auth } from "@clerk/nextjs/server";
import { clerkClient } from "@clerk/clerk-sdk-node"; 
import dbConnect from "@/lib/db/connection";
import { Activity } from "@/lib/db/models/activity";

export async function GET(req: NextRequest) {
  try {
    const { userId } = await auth();
    if (!userId) {
      return new NextResponse("Unauthorized", { status: 401 });
    }

    await dbConnect();

    // Get query parameters
    const { searchParams } = new URL(req.url);
    const limit = parseInt(searchParams.get("limit") || "20");
    const before = searchParams.get("before");
    const eventId = searchParams.get("eventId");
    const type = searchParams.get("type");

    // Build query
    let query: any = {};
    if (before) {
      query.createdAt = { $lt: new Date(before) };
    }
    if (eventId) {
      query.eventId = eventId;
    }
    if (type) {
      query.type = type;
    }

    // Fetch activities
    const activities = await Activity
      .find(query)
      .sort({ createdAt: -1 })
      .limit(limit);

    // Fetch user details from Clerk
    const userIds = Array.from(new Set(activities.map(a => a.userId)));
    const userDetails = new Map<string, any>();

    // In a real app, you would batch fetch users from Clerk
    // This is a simplified version
    for (const id of userIds) {
      try {
        const user = await clerkClient.users.getUser(userId);
        userDetails.set(id, {
          name: `${user.firstName} ${user.lastName}`,
          email: user.emailAddresses[0]?.emailAddress,
          avatar: user.imageUrl,
        });
      } catch (error) {
        console.error(`Error fetching user ${id}:`, error);
      }
    }

    // Enrich activities with user details
    const enrichedActivities = activities.map(activity => ({
      ...activity.toObject(),
      id: activity._id.toString(),
      user: userDetails.get(activity.userId) || null,
    }));

    return NextResponse.json(enrichedActivities);
  } catch (error) {
    console.error("Error fetching activities:", error);
    return new NextResponse("Internal Error", { status: 500 });
  }
}

================
File: src/app/api/events/[eventId]/activities/route.ts
================
// src/app/api/events/[eventId]/activities/route.ts
import { NextRequest, NextResponse } from "next/server";
import { auth } from "@clerk/nextjs/server";
import dbConnect from "@/lib/db/connection";
import { Activity } from "@/lib/db/models/activity";

export async function GET(
  req: NextRequest,
  { params }: { params: { eventId: string } }
) {
  try {
    const { userId } = await auth();
    if (!userId) {
      return new NextResponse("Unauthorized", { status: 401 });
    }

    await dbConnect();
    const { searchParams } = new URL(req.url);
    const limit = parseInt(searchParams.get("limit") || "20");
    const before = searchParams.get("before");

    let query: any = { eventId: params.eventId };
    if (before) {
      query.createdAt = { $lt: new Date(before) };
    }

    const activities = await Activity
      .find(query)
      .sort({ createdAt: -1 })
      .limit(limit)
      .populate('userId', 'name avatar');

    return NextResponse.json(activities);
  } catch (error) {
    console.error("Error fetching activities:", error);
    return new NextResponse("Internal Error", { status: 500 });
  }
}

================
File: src/app/api/events/[eventId]/chat/route.ts
================
import { NextRequest, NextResponse } from "next/server";
import { auth } from "@clerk/nextjs/server";
import dbConnect from "@/lib/db/connection";
import { Message } from "@/lib/db/models/message";
import { Event } from "@/lib/db/models/event";
import { Guest } from "@/lib/db/models/guest";
import { pusherServer } from "@/lib/pusher";

export async function GET(
  req: NextRequest,
  { params }: { params: { eventId: string } }
) {
  try {
    await dbConnect();
    const { searchParams } = new URL(req.url);
    const before = searchParams.get("before");
    const limit = parseInt(searchParams.get("limit") || "50");

    let query: any = { eventId: params.eventId };
    if (before) {
      query.createdAt = { $lt: new Date(before) };
    }

    const messages = await Message.find(query)
      .sort({ createdAt: -1 })
      .limit(limit)
      .populate('senderId', 'name avatar');

    return NextResponse.json(messages);
  } catch (error) {
    console.error("Error fetching messages:", error);
    return new NextResponse("Internal Error", { status: 500 });
  }
}

export async function POST(
  req: NextRequest,
  { params }: { params: { eventId: string } }
) {
  try {
    const { userId } = await auth();
    if (!userId) {
      return new NextResponse("Unauthorized", { status: 401 });
    }

    await dbConnect();
    const data = await req.json();

    // Check if user is part of the event
    const guest = await Guest.findOne({
      eventId: params.eventId,
      userId,
      status: { $in: ["confirmed", "checked_in"] }
    });

    if (!guest) {
      return new NextResponse("Unauthorized", { status: 401 });
    }

    const message = await Message.create({
      ...data,
      eventId: params.eventId,
      senderId: userId
    });

    // Broadcast message via Pusher
    await pusherServer.trigger(
      `event-${params.eventId}`,
      "new-message",
      {
        ...message.toJSON(),
        sender: {
          id: userId,
          name: data.senderName,
          avatar: data.senderAvatar
        }
      }
    );

    return NextResponse.json(message);
  } catch (error) {
    console.error("Error sending message:", error);
    return new NextResponse("Internal Error", { status: 500 });
  }
}

================
File: src/app/api/events/[eventId]/check-in/route.ts
================
import { NextRequest, NextResponse } from "next/server";
import { auth } from "@clerk/nextjs/server";
import dbConnect from "@/lib/db/connection";
import { Guest } from "@/lib/db/models/guest";
import { createActivity } from "@/lib/activity/notifications";

export async function POST(
  req: NextRequest,
  { params }: { params: { eventId: string } }
) {
  try {
    const { userId } = await auth();
    if (!userId) {
      return new NextResponse("Unauthorized", { status: 401 });
    }

    await dbConnect();
    const { guestId } = await req.json();

    const guest = await Guest.findOne({
      _id: guestId,
      eventId: params.eventId
    });

    if (!guest) {
      return new NextResponse("Guest not found", { status: 404 });
    }

    if (guest.checkedIn) {
      return new NextResponse("Guest already checked in", { status: 400 });
    }

    guest.checkedIn = true;
    guest.checkedInAt = new Date();
    await guest.save();

    // Create activity log
    await createActivity({
      type: "guest.checked_in",
      userId,
      eventId: params.eventId,
      metadata: {
        guestId: guest._id,
        guestName: guest.name
      }
    });

    return NextResponse.json(guest);
  } catch (error) {
    console.error("Error checking in guest:", error);
    return new NextResponse("Internal Error", { status: 500 });
  }
}

================
File: src/app/api/events/[eventId]/export/route.ts
================
import { NextRequest, NextResponse } from "next/server";
import { auth } from "@clerk/nextjs/server";
import dbConnect from "@/lib/db/connection";
import { Event } from "@/lib/db/models/event";
import { Guest } from "@/lib/db/models/guest";
import { createObjectCsvStringifier } from "csv-writer";

export async function GET(
  req: NextRequest,
  { params }: { params: { eventId: string } }
) {
  try {
    const { userId } = await auth();
    if (!userId) {
      return new NextResponse("Unauthorized", { status: 401 });
    }

    await dbConnect();
    const event = await Event.findById(params.eventId);
    
    if (!event) {
      return new NextResponse("Event not found", { status: 404 });
    }

    if (event.organizerId !== userId && !event.coHosts.includes(userId)) {
      return new NextResponse("Unauthorized", { status: 401 });
    }

    const guests = await Guest.find({ eventId: params.eventId });

    const csvStringifier = createObjectCsvStringifier({
      header: [
        { id: 'name', title: 'Name' },
        { id: 'email', title: 'Email' },
        { id: 'status', title: 'Status' },
        { id: 'checkedIn', title: 'Checked In' },
        { id: 'checkedInAt', title: 'Check-in Time' },
        { id: 'dietaryPreferences', title: 'Dietary Preferences' }
      ]
    });

    const records = guests.map(guest => ({
      name: guest.name,
      email: guest.email,
      status: guest.status,
      checkedIn: guest.checkedIn ? 'Yes' : 'No',
      checkedInAt: guest.checkedInAt ? new Date(guest.checkedInAt).toLocaleString() : '',
      dietaryPreferences: guest.dietaryPreferences?.join(', ') || ''
    }));

    const csv = csvStringifier.getHeaderString() + csvStringifier.stringifyRecords(records);

    return new NextResponse(csv, {
      headers: {
        'Content-Type': 'text/csv',
        'Content-Disposition': `attachment; filename="event-${event.title}-guests.csv"`
      }
    });
  } catch (error) {
    console.error("Error exporting event data:", error);
    return new NextResponse("Internal Error", { status: 500 });
  }
}

================
File: src/app/api/events/[eventId]/guests/[guestId]/route.ts
================
// src/app/api/events/[eventId]/guests/[guestId]/route.ts
import { NextRequest, NextResponse } from "next/server";
import { auth } from "@clerk/nextjs/server";
import dbConnect from "@/lib/db/connection";
import { Event } from "@/lib/db/models/event";  // Add this import
import { Guest } from "@/lib/db/models/guest";
import { ActivityTypes, createActivity } from "@/lib/activity/notifications";

// Type for the update request body
interface UpdateGuestRequest {
  status?: "confirmed" | "declined" | "waitlist" | "invited";
  role?: "attendee" | "coHost" | "moderator";
  checkedIn?: boolean;
  dietaryPreferences?: string[];
  notes?: string;
}

export async function PATCH(
  req: NextRequest,
  { params }: { params: { eventId: string; guestId: string } }
) {
  try {
    const { userId } = await auth();
    if (!userId) {
      return new NextResponse("Unauthorized", { status: 401 });
    }

    await dbConnect();
    const data = await req.json() as UpdateGuestRequest;

    // Validate the update data
    const allowedFields = [
      "status",
      "role",
      "checkedIn",
      "dietaryPreferences",
      "notes"
    ];
    const updateData = Object.fromEntries(
      Object.entries(data).filter(([key]) => allowedFields.includes(key))
    );

    // Find guest
    const guest = await Guest.findById(params.guestId);
    if (!guest) {
      return new NextResponse("Guest not found", { status: 404 });
    }

    // Find event
    const event = await Event.findById(params.eventId);
    if (!event) {
      return new NextResponse("Event not found", { status: 404 });
    }

    // Check permissions
    const canUpdate = 
      event.organizerId === userId || 
      event.coHosts.includes(userId) || 
      guest.userId === userId;

    if (!canUpdate) {
      return new NextResponse("Unauthorized", { status: 401 });
    }

    // Update guest with validation
    const updatedGuest = await Guest.findByIdAndUpdate(
      params.guestId,
      { 
        ...updateData,
        ...(updateData.checkedIn && { checkedInAt: new Date() })
      },
      { 
        new: true,
        runValidators: true 
      }
    );

    // Create activity log
    await createActivity({
      type: ActivityTypes.GUEST_UPDATED,
      userId,
      eventId: params.eventId,
      metadata: {
        guestId: params.guestId,
        updates: Object.keys(updateData).join(", ")
      }
    });

    return NextResponse.json(updatedGuest);
  } catch (error) {
    console.error("Error updating guest:", error);
    if (error instanceof Error) {
      return new NextResponse(error.message, { status: 400 });
    }
    return new NextResponse("Internal Error", { status: 500 });
  }
}

export async function DELETE(
  req: NextRequest,
  { params }: { params: { eventId: string; guestId: string } }
) {
  try {
    const { userId } = await auth();
    if (!userId) {
      return new NextResponse("Unauthorized", { status: 401 });
    }

    await dbConnect();

    // Find event and check permissions
    const event = await Event.findById(params.eventId);
    if (!event) {
      return new NextResponse("Event not found", { status: 404 });
    }

    // Only organizers and co-hosts can remove guests
    if (event.organizerId !== userId && !event.coHosts.includes(userId)) {
      return new NextResponse("Unauthorized", { status: 401 });
    }

    // Find and delete guest
    const guest = await Guest.findById(params.guestId);
    if (!guest) {
      return new NextResponse("Guest not found", { status: 404 });
    }

    await Guest.findByIdAndDelete(params.guestId);

    // Create activity log
    await createActivity({
      type: ActivityTypes.GUEST_REMOVED,
      userId,
      eventId: params.eventId,
      metadata: { 
        guestId: params.guestId,
        guestEmail: guest.email // Include email for reference
      }
    });

    // Return success with no content
    return new NextResponse(null, { status: 204 });
  } catch (error) {
    console.error("Error removing guest:", error);
    if (error instanceof Error) {
      return new NextResponse(error.message, { status: 400 });
    }
    return new NextResponse("Internal Error", { status: 500 });
  }
}

================
File: src/app/api/events/[eventId]/guests/route.ts
================
// src/app/api/events/[eventId]/guests/route.ts
import { NextRequest, NextResponse } from "next/server";
import { auth } from "@clerk/nextjs/server";
import dbConnect from "@/lib/db/connection";
import { Event } from "@/lib/db/models/event";
import { Guest } from "@/lib/db/models/guest";
import { sendEventInvitation } from "@/lib/email/notifications";
import { createActivity } from "@/lib/activity/notifications";
import { formatDateTime } from "@/lib/email/notifications";

export async function GET(
  req: NextRequest,
  { params }: { params: { eventId: string } }
) {
  try {
    await dbConnect();
    const { searchParams } = new URL(req.url);
    const status = searchParams.get("status");
    const search = searchParams.get("search");

    let query: any = { eventId: params.eventId };
    if (status) query.status = status;
    if (search) {
      query.$or = [
        { name: { $regex: search, $options: "i" } },
        { email: { $regex: search, $options: "i" } }
      ];
    }

    const guests = await Guest.find(query).sort({ createdAt: -1 });
    return NextResponse.json(guests);
  } catch (error) {
    console.error("Error fetching guests:", error);
    return new NextResponse("Internal Error", { status: 500 });
  }
}

export async function POST(
  req: NextRequest,
  { params }: { params: { eventId: string } }
) {
  try {
    const { userId } = await auth();
    if (!userId) {
      return new NextResponse("Unauthorized", { status: 401 });
    }

    await dbConnect();
    const data = await req.json();
    const event = await Event.findById(params.eventId);

    if (!event) {
      return new NextResponse("Event not found", { status: 404 });
    }

    // Check if user has permission to invite
    if (event.organizerId !== userId && !event.coHosts.includes(userId)) {
      return new NextResponse("Unauthorized", { status: 401 });
    }

    // Format event date and time
    const { formattedDate, formattedTime } = formatDateTime(new Date(event.startDate));

    // Handle batch invitations
    const emails = Array.isArray(data.email) ? data.email : [data.email];
    const results = await Promise.all(
      emails.map(async (email: string) => {
        // Check if guest already exists
        const existingGuest = await Guest.findOne({
          eventId: params.eventId,
          email
        });

        if (existingGuest) {
          return {
            email,
            status: "already_invited"
          };
        }

        // Create new guest
        const guest = await Guest.create({
          eventId: params.eventId,
          email,
          status: "invited",
          role: data.role || "attendee",
          invitedBy: userId
        });

        // Send invitation email with properly formatted params
        await sendEventInvitation({
          recipientEmail: email,
          eventTitle: event.title,
          eventDate: formattedDate,
          eventTime: formattedTime,
          location: `${event.location.venue}, ${event.location.address}`,
          eventUrl: `${process.env.NEXT_PUBLIC_APP_URL}/events/${event.id}`,
          personalMessage: data.message
        });

        // Create activity
        await createActivity({
          type: "guest.invited",
          userId,
          eventId: params.eventId,
          metadata: { guestEmail: email }
        });

        return {
          email,
          status: "invited",
          guestId: guest._id
        };
      })
    );

    return NextResponse.json(results);
  } catch (error) {
    console.error("Error inviting guests:", error);
    return new NextResponse("Internal Error", { status: 500 });
  }
}

================
File: src/app/api/events/[eventId]/invite/route.ts
================
// src/app/api/events/[eventId]/invite/route.ts
import { NextRequest, NextResponse } from "next/server";
import { auth } from "@clerk/nextjs/server";
import dbConnect from "@/lib/db/connection";
import { Event } from "@/lib/db/models/event";
import { Guest } from "@/lib/db/models/guest";
import { sendEventInvitation } from "@/lib/email/notifications";

interface InviteRequestBody {
  emails: string[];
  message?: string;
}

export async function POST(
  req: NextRequest,
  { params }: { params: { eventId: string } }
) {
  try {
    const { userId } = await auth();
    if (!userId) {
      return new NextResponse("Unauthorized", { status: 401 });
    }

    const { emails, message } = await req.json() as InviteRequestBody;

    // Validate request body
    if (!Array.isArray(emails) || emails.length === 0) {
      return new NextResponse("Invalid email addresses", { status: 400 });
    }

    // Connect to database
    await dbConnect();

    // Get event details
    const event = await Event.findById(params.eventId);
    if (!event) {
      return new NextResponse("Event not found", { status: 404 });
    }

    // Check if user is authorized to send invites
    if (event.organizerId !== userId && !event.coHosts.includes(userId)) {
      return new NextResponse("Unauthorized", { status: 401 });
    }

    // Create invitations and send emails
    const inviteResults = await Promise.allSettled(
      emails.map(async (email) => {
        try {
          // Check if guest already exists
          const existingGuest = await Guest.findOne({
            eventId: params.eventId,
            email: email.toLowerCase(),
          });

          if (existingGuest) {
            return {
              email,
              status: "already_invited",
            };
          }

          // Create new guest
          const guest = await Guest.create({
            eventId: params.eventId,
            email: email.toLowerCase(),
            status: "invited",
            role: "attendee",
            invitedBy: userId,
            invitedAt: new Date(),
          });

          // Format date and time for email
          const startDate = new Date(event.startDate);
          const formattedDate = startDate.toLocaleDateString('en-US', {
            weekday: 'long',
            year: 'numeric',
            month: 'long',
            day: 'numeric',
          });
          const formattedTime = startDate.toLocaleTimeString('en-US', {
            hour: 'numeric',
            minute: '2-digit',
            hour12: true,
          });

          // Send invitation email
          await sendEventInvitation({
            recipientEmail: email,
            eventTitle: event.title,
            eventDate: formattedDate,
            eventTime: formattedTime,
            location: `${event.location.venue}, ${event.location.address}`,
            eventUrl: `${process.env.NEXT_PUBLIC_APP_URL}/events/${event.id}`,
            personalMessage: message,
          });

          return {
            email,
            status: "invited",
            guestId: guest._id,
          };
        } catch (error) {
          console.error(`Error inviting ${email}:`, error);
          return {
            email,
            status: "failed",
            error: error instanceof Error ? error.message : "Unknown error",
          };
        }
      })
    );

    // Process results
    const results = inviteResults.map((result) => {
      if (result.status === "fulfilled") {
        return result.value;
      } else {
        return {
          email: "unknown",
          status: "failed",
          error: result.reason?.message || "Failed to process invitation",
        };
      }
    });

    // Check if any invitations were successful
    const successfulInvites = results.filter(
      (result) => result.status === "invited"
    );

    if (successfulInvites.length === 0) {
      return new NextResponse(
        JSON.stringify({
          message: "No invitations were sent successfully",
          results,
        }),
        { status: 400 }
      );
    }

    return new NextResponse(
      JSON.stringify({
        message: `Successfully sent ${successfulInvites.length} invitation(s)`,
        results,
      }),
      { status: 200 }
    );

  } catch (error) {
    console.error("Error sending invitations:", error);
    return new NextResponse(
      JSON.stringify({
        error: "Failed to send invitations",
        details: error instanceof Error ? error.message : "Unknown error",
      }),
      { status: 500 }
    );
  }
}

// a GET route to check invitation status
export async function GET(
  req: NextRequest,
  { params }: { params: { eventId: string } }
) {
  try {
    const { userId } = await auth();
    if (!userId) {
      return new NextResponse("Unauthorized", { status: 401 });
    }

    await dbConnect();

    const event = await Event.findById(params.eventId);
    if (!event) {
      return new NextResponse("Event not found", { status: 404 });
    }

    // Check authorization
    if (event.organizerId !== userId && !event.coHosts.includes(userId)) {
      return new NextResponse("Unauthorized", { status: 401 });
    }

    // Get all invitations for this event
    const guests = await Guest.find({ eventId: params.eventId })
      .select('email status invitedAt role checkedIn')
      .sort('-invitedAt');

    return NextResponse.json(guests);
  } catch (error) {
    console.error("Error fetching invitations:", error);
    return new NextResponse("Internal Error", { status: 500 });
  }
}

================
File: src/app/api/events/[eventId]/stats/route.ts
================
import { NextRequest, NextResponse } from "next/server";
import { auth } from "@clerk/nextjs/server";
import dbConnect from "@/lib/db/connection";
import { Event } from "@/lib/db/models/event";
import { Guest } from "@/lib/db/models/guest";

export async function GET(
  req: NextRequest,
  { params }: { params: { eventId: string } }
) {
  try {
    const { userId } = await auth();
    if (!userId) {
      return new NextResponse("Unauthorized", { status: 401 });
    }

    await dbConnect();

    const event = await Event.findById(params.eventId);
    if (!event) {
      return new NextResponse("Event not found", { status: 404 });
    }

    const [
      totalGuests,
      confirmedGuests,
      checkedInGuests,
      waitlistedGuests
    ] = await Promise.all([
      Guest.countDocuments({ eventId: params.eventId }),
      Guest.countDocuments({ eventId: params.eventId, status: "confirmed" }),
      Guest.countDocuments({ eventId: params.eventId, checkedIn: true }),
      Guest.countDocuments({ eventId: params.eventId, status: "waitlist" })
    ]);

    return NextResponse.json({
      total: totalGuests,
      confirmed: confirmedGuests,
      checkedIn: checkedInGuests,
      waitlisted: waitlistedGuests,
      capacity: event.capacity,
      fillRate: (confirmedGuests / event.capacity) * 100,
      checkInRate: (checkedInGuests / confirmedGuests) * 100
    });
  } catch (error) {
    console.error("Error fetching event stats:", error);
    return new NextResponse("Internal Error", { status: 500 });
  }
}

================
File: src/app/api/events/[eventId]/route.ts
================
import { NextRequest, NextResponse } from "next/server";
import dbConnect from "@/lib/db/connection";
import { Event } from "@/lib/db/models/event";
import { auth } from "@clerk/nextjs/server";
import { Guest } from "@/lib/db/models/guest";
import mongoose from "mongoose";

export async function GET(
  req: NextRequest,
  { params }: { params: { eventId: string } }
) {
  try {
    await dbConnect();

    // Validate ObjectId
    if (!mongoose.Types.ObjectId.isValid(params.eventId)) {
      return new NextResponse("Invalid event ID", { status: 400 });
    }

    const event = await Event.findById(params.eventId);

    if (!event) {
      return new NextResponse("Event not found", { status: 404 });
    }

    // Convert Mongoose document to a plain JavaScript object
    const eventObject = event.toObject();

    // Create a serializable version of the event
    const serializedEvent = {
      id: eventObject._id.toString(),
      title: eventObject.title,
      description: eventObject.description,
      startDate: eventObject.startDate.toISOString(),
      endDate: eventObject.endDate.toISOString(),
      location: {
        venue: eventObject.location?.venue || '',
        address: eventObject.location?.address || '',
        coordinates: eventObject.location?.coordinates || null,
      },
      capacity: eventObject.capacity,
      status: eventObject.status,
      visibility: eventObject.visibility,
      organizerId: eventObject.organizerId,
      coHosts: eventObject.coHosts || [],
      recurring: eventObject.recurring || null,
      createdAt: eventObject.createdAt.toISOString(),
      updatedAt: eventObject.updatedAt.toISOString(),
      attendees: {
        confirmed: 0, // You'll need to fetch these counts separately
        waitlist: 0,
      },
    };

    return NextResponse.json(serializedEvent);
  } catch (error) {
    console.error("Error fetching event:", error);
    return new NextResponse("Internal Error", { status: 500 });
  }
}

export async function PATCH(
  req: NextRequest,
  { params }: { params: { eventId: string } }
) {
  try {
    const { userId } = await auth();
    if (!userId) {
      return new NextResponse("Unauthorized", { status: 401 });
    }

    await dbConnect();
    const data = await req.json();
    const event = await Event.findById(params.eventId);

    if (!event) {
      return new NextResponse("Event not found", { status: 404 });
    }

    if (event.organizerId !== userId && !event.coHosts.includes(userId)) {
      return new NextResponse("Unauthorized", { status: 401 });
    }

    const updatedEvent = await Event.findByIdAndUpdate(
      params.eventId,
      { ...data },
      { new: true }
    );

    return NextResponse.json(updatedEvent);
  } catch (error) {
    console.error("Error updating event:", error);
    return new NextResponse("Internal Error", { status: 500 });
  }
}

export async function DELETE(
  req: NextRequest,
  { params }: { params: { eventId: string } }
) {
  try {
    const { userId } = await auth();
    if (!userId) {
      return new NextResponse("Unauthorized", { status: 401 });
    }

    await dbConnect();
    const event = await Event.findById(params.eventId);

    if (!event) {
      return new NextResponse("Event not found", { status: 404 });
    }

    if (event.organizerId !== userId) {
      return new NextResponse("Unauthorized", { status: 401 });
    }

    await Event.findByIdAndDelete(params.eventId);
    return new NextResponse(null, { status: 204 });
  } catch (error) {
    console.error("Error deleting event:", error);
    return new NextResponse("Internal Error", { status: 500 });
  }
}

================
File: src/app/api/events/route.ts
================
import { NextRequest, NextResponse } from "next/server";
import dbConnect from "@/lib/db/connection";
import { Event } from "@/lib/db/models/event";
import { auth } from "@clerk/nextjs/server";
import { revalidatePath } from "next/cache";

export async function POST(req: NextRequest) {
  try {
    const { userId } = await auth();
    if (!userId) {
      return new NextResponse("Unauthorized", { status: 401 });
    }

    await dbConnect();
    const data = await req.json();

    // Create the event and ensure we get the created document back
    const event = await Event.create({
      ...data,
      organizerId: userId,
      status: "draft",
      location: {
        venue: data.venue,
        address: data.address
      }
    });

    

    // Convert the Mongoose document to a plain object and ensure _id is converted to id
    const eventObject = event.toObject();
    const responseEvent = {
      ...eventObject,
      id: eventObject._id.toString(),
    };

    revalidatePath("/events");
    revalidatePath("/dashboard");
    revalidatePath("/");

    return NextResponse.json(responseEvent);
  } catch (error) {
    console.error("Error creating event:", error);
    return new NextResponse(
      JSON.stringify({ 
        error: "Failed to create event", 
        details: error instanceof Error ? error.message : "Unknown error" 
      }), 
      { 
        status: 500,
        headers: {
          'Content-Type': 'application/json',
        },
      }
    );
  }
}

export async function GET(req: NextRequest) {
  try {
    await dbConnect();
    const { searchParams } = new URL(req.url);
    const status = searchParams.get("status");
    const organizerId = searchParams.get("organizerId");

    let query = {};
    if (status) query = { ...query, status };
    if (organizerId) query = { ...query, organizerId };

    const events = await Event.find(query).sort({ createdAt: -1 }).limit(100);

    // Serialize the events
    const serializedEvents = events.map(event => {
      const eventObj = event.toObject();
      return {
        id: eventObj._id.toString(),
        title: eventObj.title,
        description: eventObj.description,
        startDate: eventObj.startDate.toISOString(),
        endDate: eventObj.endDate.toISOString(),
        location: {
          venue: eventObj.location?.venue || '',
          address: eventObj.location?.address || '',
        },
        capacity: eventObj.capacity,
        status: eventObj.status,
        visibility: eventObj.visibility,
        organizerId: eventObj.organizerId,
        coHosts: eventObj.coHosts || [],
      };
    });

    return NextResponse.json(serializedEvents);
  } catch (error) {
    console.error("Error fetching events:", error);
    return new NextResponse("Internal Error", { status: 500 });
  }
}

================
File: src/app/api/users/[userId]/route.ts
================
// src/app/api/users/[userId]/route.ts
import { NextRequest, NextResponse } from "next/server";
import { clerkClient } from "@clerk/clerk-sdk-node"; 
import { auth } from "@clerk/nextjs/server";

export async function GET(
  req: NextRequest,
  { params }: { params: { userId: string } }
) {
  try {
    const { userId: currentUserId } = await auth();
    if (!currentUserId) {
      return new NextResponse("Unauthorized", { status: 401 });
    }

    const user = await clerkClient.users.getUser(params.userId);

    return NextResponse.json({
      id: user.id,
      name: `${user.firstName} ${user.lastName}`,
      imageUrl: user.imageUrl,
      emailAddress: user.emailAddresses[0]?.emailAddress
    });
  } catch (error) {
    console.error("Error fetching user:", error);
    return new NextResponse("Internal Error", { status: 500 });
  }
}

================
File: src/app/globals.css
================
@tailwind base;
@tailwind components;
@tailwind utilities;
 
@layer base {
  :root {
    --background: 0 0% 100%;
    --foreground: 222.2 84% 4.9%;

    --card: 0 0% 100%;
    --card-foreground: 222.2 84% 4.9%;
 
    --popover: 0 0% 100%;
    --popover-foreground: 222.2 84% 4.9%;
 
    --primary: 222.2 47.4% 11.2%;
    --primary-foreground: 210 40% 98%;
 
    --secondary: 210 40% 96.1%;
    --secondary-foreground: 222.2 47.4% 11.2%;
 
    --muted: 210 40% 96.1%;
    --muted-foreground: 215.4 16.3% 46.9%;
 
    --accent: 210 40% 96.1%;
    --accent-foreground: 222.2 47.4% 11.2%;
 
    --destructive: 0 84.2% 60.2%;
    --destructive-foreground: 210 40% 98%;

    --border: 214.3 31.8% 91.4%;
    --input: 214.3 31.8% 91.4%;
    --ring: 222.2 84% 4.9%;
 
    --radius: 0.5rem;
 
    --chart-1: 12 76% 61%;
 
    --chart-2: 173 58% 39%;
 
    --chart-3: 197 37% 24%;
 
    --chart-4: 43 74% 66%;
 
    --chart-5: 27 87% 67%;
  }
 
  .dark {
    --background: 222.2 84% 4.9%;
    --foreground: 210 40% 98%;
 
    --card: 222.2 84% 4.9%;
    --card-foreground: 210 40% 98%;
 
    --popover: 222.2 84% 4.9%;
    --popover-foreground: 210 40% 98%;
 
    --primary: 210 40% 98%;
    --primary-foreground: 222.2 47.4% 11.2%;
 
    --secondary: 217.2 32.6% 17.5%;
    --secondary-foreground: 210 40% 98%;
 
    --muted: 217.2 32.6% 17.5%;
    --muted-foreground: 215 20.2% 65.1%;
 
    --accent: 217.2 32.6% 17.5%;
    --accent-foreground: 210 40% 98%;
 
    --destructive: 0 62.8% 30.6%;
    --destructive-foreground: 210 40% 98%;
 
    --border: 217.2 32.6% 17.5%;
    --input: 217.2 32.6% 17.5%;
    --ring: 212.7 26.8% 83.9%;
    --chart-1: 220 70% 50%;
    --chart-2: 160 60% 45%;
    --chart-3: 30 80% 55%;
    --chart-4: 280 65% 60%;
    --chart-5: 340 75% 55%;
  }
}
 
@layer base {
  * {
    @apply border-border;
  }
  body {
    @apply bg-background text-foreground;
  }
}

================
File: src/app/layout.tsx
================
import { ClerkProvider } from '@clerk/nextjs'
import { Inter } from 'next/font/google'
import type { Metadata } from 'next'
import { ThemeProvider } from '@/components/providers/theme-provider'
import { Toaster } from '@/components/ui/toaster'
import './globals.css'

const inter = Inter({ subsets: ['latin'] })

export const metadata: Metadata = {
  title: 'Feest APP',
  description: 'Comprehensive event management platform',
}

export default function RootLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <ClerkProvider>
      <html lang="en" suppressHydrationWarning>
        <body className={inter.className}>
          <ThemeProvider
            attribute="class"
            defaultTheme="system"
            enableSystem
            disableTransitionOnChange
          >
            {children}
            <Toaster />
          </ThemeProvider>
        </body>
      </html>
    </ClerkProvider>
  )
}

================
File: src/app/page.tsx
================
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import { ArrowRight, Calendar, Users, BarChart3, Zap, CheckCircle, Clock } from "lucide-react";
import Link from "next/link";

export default function LandingPage() {
  return (
    <div className="flex min-h-screen flex-col">
      {/* Hero Section */}
      <div className="flex flex-col items-center justify-center space-y-8 px-4 py-24 text-center lg:py-32">
        <Badge className="mb-4" variant="secondary">
           Your events, managed perfectly
        </Badge>
        <h1 className="text-3xl font-bold tracking-tighter sm:text-5xl md:text-6xl lg:text-7xl">
          Event Management
          <span className="block bg-gradient-to-r from-primary to-primary/50 bg-clip-text text-transparent">
            Made Simple
          </span>
        </h1>
        <p className="mx-auto max-w-[700px] text-muted-foreground md:text-xl">
          Create, manage, and host remarkable events. From intimate gatherings to
          grand conferences, we've got you covered.
        </p>
        <div className="flex flex-col gap-4 min-[400px]:flex-row">
          <Link href="/sign-up">
            <Button size="lg" className="gap-2">
              Get Started <ArrowRight className="h-4 w-4" />
            </Button>
          </Link>
          <Link href="/sign-in">
            <Button size="lg" variant="outline">
              Sign In
            </Button>
          </Link>
        </div>
      </div>

      {/* Features Grid */}
      <div className="container mx-auto grid gap-8 px-4 py-16 md:grid-cols-2 lg:grid-cols-3">
        <div className="group relative overflow-hidden rounded-lg border bg-background p-6 shadow-md transition-all hover:-translate-y-1 hover:shadow-lg">
          <div className="absolute inset-0 bg-gradient-to-r from-primary/10 to-transparent opacity-0 transition-opacity group-hover:opacity-100" />
          <Calendar className="mb-4 h-8 w-8 text-primary" />
          <h3 className="mb-2 font-semibold">Smart Scheduling</h3>
          <p className="text-sm text-muted-foreground">
            Intelligent calendar management with conflict detection and timezone support.
          </p>
        </div>

        <div className="group relative overflow-hidden rounded-lg border bg-background p-6 shadow-md transition-all hover:-translate-y-1 hover:shadow-lg">
          <div className="absolute inset-0 bg-gradient-to-r from-primary/10 to-transparent opacity-0 transition-opacity group-hover:opacity-100" />
          <Users className="mb-4 h-8 w-8 text-primary" />
          <h3 className="mb-2 font-semibold">Attendee Management</h3>
          <p className="text-sm text-muted-foreground">
            Seamlessly manage guest lists, RSVPs, and check-ins with real-time updates.
          </p>
        </div>

        <div className="group relative overflow-hidden rounded-lg border bg-background p-6 shadow-md transition-all hover:-translate-y-1 hover:shadow-lg">
          <div className="absolute inset-0 bg-gradient-to-r from-primary/10 to-transparent opacity-0 transition-opacity group-hover:opacity-100" />
          <BarChart3 className="mb-4 h-8 w-8 text-primary" />
          <h3 className="mb-2 font-semibold">Insightful Analytics</h3>
          <p className="text-sm text-muted-foreground">
            Comprehensive analytics and reporting to track event performance.
          </p>
        </div>
      </div>

      {/* Stats Section
      <div className="border-t bg-muted/40">
        <div className="container mx-auto px-4 py-16">
          <div className="grid gap-8 md:grid-cols-3">
            <div className="text-center">
              <div className="text-4xl font-bold">10K+</div>
              <div className="mt-2 text-sm text-muted-foreground">Events Hosted</div>
            </div>
            <div className="text-center">
              <div className="text-4xl font-bold">50K+</div>
              <div className="mt-2 text-sm text-muted-foreground">Happy Users</div>
            </div>
            <div className="text-center">
              <div className="text-4xl font-bold">99%</div>
              <div className="mt-2 text-sm text-muted-foreground">Satisfaction Rate</div>
            </div>
          </div>
        </div>
      </div> */}

      {/* Feature Highlights */}
      <div className="container mx-auto px-4 py-16">
        <div className="mx-auto max-w-2xl text-center">
          <h2 className="text-3xl font-bold tracking-tight sm:text-4xl">
            Everything you need to run successful events
          </h2>
          <p className="mt-4 text-muted-foreground">
            Powerful features to help you manage events of any size
          </p>
        </div>

        <div className="mt-16 grid gap-8 md:grid-cols-2">
          <div className="flex items-start gap-4">
            <div className="rounded-lg bg-primary/10 p-2">
              <Zap className="h-6 w-6 text-primary" />
            </div>
            <div>
              <h3 className="font-semibold">Real-time Updates</h3>
              <p className="mt-1 text-sm text-muted-foreground">
                Stay informed with instant notifications and live event updates.
              </p>
            </div>
          </div>

          <div className="flex items-start gap-4">
            <div className="rounded-lg bg-primary/10 p-2">
              <CheckCircle className="h-6 w-6 text-primary" />
            </div>
            <div>
              <h3 className="font-semibold">Easy Check-ins</h3>
              <p className="mt-1 text-sm text-muted-foreground">
                Streamlined check-in process with QR codes and mobile support.
              </p>
            </div>
          </div>

          <div className="flex items-start gap-4">
            <div className="rounded-lg bg-primary/10 p-2">
              <Clock className="h-6 w-6 text-primary" />
            </div>
            <div>
              <h3 className="font-semibold">Time Management</h3>
              <p className="mt-1 text-sm text-muted-foreground">
                Schedule and coordinate multiple events with ease.
              </p>
            </div>
          </div>

          <div className="flex items-start gap-4">
            <div className="rounded-lg bg-primary/10 p-2">
              <Users className="h-6 w-6 text-primary" />
            </div>
            <div>
              <h3 className="font-semibold">Team Collaboration</h3>
              <p className="mt-1 text-sm text-muted-foreground">
                Work together with team members and coordinate responsibilities.
              </p>
            </div>
          </div>
        </div>
      </div>

      {/* CTA Section */}
      <div className="border-t">
        <div className="container mx-auto px-4 py-16">
          <div className="relative overflow-hidden rounded-3xl bg-gradient-to-r from-primary to-primary/80 px-6 py-20 text-center shadow-xl">
            <div className="relative z-10">
              <h2 className="mx-auto max-w-2xl text-3xl font-bold text-white sm:text-4xl">
                Ready to transform your events?
              </h2>
              <p className="mx-auto mt-4 max-w-xl text-lg text-white/90">
                Join thousands of event organizers who trust our platform.
              </p>
              <div className="mt-8 flex justify-center gap-4">
                <Link href="/sign-up">
                  <Button size="lg" variant="secondary" className="gap-2">
                    Get Started Now <ArrowRight className="h-4 w-4" />
                  </Button>
                </Link>
              </div>
            </div>
            {/* Decorative elements */}
            <div className="absolute left-1/2 top-0 h-[120%] w-[120%] -translate-x-1/2 -translate-y-[10%] rotate-12 bg-white/5" />
          </div>
        </div>
      </div>

      {/* Footer */}
      <footer className="mt-auto border-t">
        <div className="container mx-auto px-4 py-8">
          <div className="flex flex-col items-center justify-between gap-4 sm:flex-row">
            <div className="text-center sm:text-left">
              <p className="text-sm text-muted-foreground">
                 2024 Event Platform. All rights reserved.
              </p>
            </div>
            <div className="flex gap-4">
              <Link href="/privacy" className="text-sm text-muted-foreground hover:text-primary">
                Privacy Policy
              </Link>
              <Link href="/terms" className="text-sm text-muted-foreground hover:text-primary">
                Terms of Service
              </Link>
              <Link href="/contact" className="text-sm text-muted-foreground hover:text-primary">
                Contact Us
              </Link>
            </div>
          </div>
        </div>
      </footer>
    </div>
  );
}

================
File: src/components/activity/activity-feed.tsx
================
"use client";

import { useState, useEffect } from "react";
import { formatDistanceToNow } from "date-fns";
import { pusherClient } from "@/lib/pusher";
import { Activity, formatActivityMessage } from "@/lib/activity/notifications";
import { Avatar, AvatarFallback, AvatarImage } from "@/components/ui/avatar";
import { ScrollArea } from "@/components/ui/scroll-area";
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/components/ui/tooltip";

interface ActivityFeedProps {
  eventId?: string;
  userId?: string;
  limit?: number;
}

export function ActivityFeed({ eventId, userId, limit = 20 }: ActivityFeedProps) {
  const [activities, setActivities] = useState<Activity[]>([]);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    const fetchActivities = async () => {
      try {
        let response;
        if (eventId) {
          response = await fetch(`/api/events/${eventId}/activities?limit=${limit}`);
        } else if (userId) {
          response = await fetch(`/api/users/${userId}/activities?limit=${limit}`);
        }

        if (response?.ok) {
          const data = await response.json();
          setActivities(data);
        }
      } catch (error) {
        console.error("Error fetching activities:", error);
      } finally {
        setLoading(false);
      }
    };

    fetchActivities();
  }, [eventId, userId, limit]);

  useEffect(() => {
    if (!eventId && !userId) return;

    const channel = pusherClient.subscribe(
      eventId ? `event-${eventId}` : `user-${userId}`
    );

    channel.bind("new-activity", (data: Activity) => {
      setActivities((prev) => [data, ...prev].slice(0, limit));
    });

    return () => {
      channel.unbind_all();
      channel.unsubscribe();
    };
  }, [eventId, userId, limit]);

  if (loading) {
    return <div>Loading activities...</div>;
  }

  return (
    <ScrollArea className="h-[400px]">
      <div className="space-y-4 p-4">
        {activities.map((activity) => (
          <div
            key={activity.createdAt.toString()}
            className="flex items-start space-x-4"
          >
            <TooltipProvider>
              <Tooltip>
                <TooltipTrigger>
                  <Avatar>
                    <AvatarImage src={`https://avatar.vercel.sh/${activity.userId}`} />
                    <AvatarFallback>U</AvatarFallback>
                  </Avatar>
                </TooltipTrigger>
                <TooltipContent>
                  <p>User ID: {activity.userId}</p>
                </TooltipContent>
              </Tooltip>
            </TooltipProvider>

            <div className="flex-1 space-y-1">
              <p className="text-sm">
                <span className="font-medium">User </span>
                {formatActivityMessage(activity)}
              </p>
              {activity.metadata && Object.keys(activity.metadata).length > 0 && (
                <p className="text-xs text-muted-foreground">
                  {JSON.stringify(activity.metadata)}
                </p>
              )}
              <p className="text-xs text-muted-foreground">
                {formatDistanceToNow(new Date(activity.createdAt), {
                  addSuffix: true,
                })}
              </p>
            </div>
          </div>
        ))}
      </div>
    </ScrollArea>
  );
}

================
File: src/components/calendar/event-calendar.tsx
================
"use client";

import { useEffect, useState } from "react";
import {
  Calendar,
  Views,
  DateLocalizer,
  momentLocalizer,
} from "react-big-calendar";
import moment from "moment";
import "react-big-calendar/lib/css/react-big-calendar.css";
import { Card } from "@/components/ui/card";
import { useRouter } from "next/navigation";

const localizer = momentLocalizer(moment);

interface Event {
  id: string;
  title: string;
  start: Date;
  end: Date;
}

export function EventCalendar() {
  const [events, setEvents] = useState<Event[]>([]);
  const router = useRouter();

  useEffect(() => {
    const fetchEvents = async () => {
      try {
        const response = await fetch("/api/events");
        const data = await response.json();
        const formattedEvents = data.map((event: any) => ({
          id: event.id,
          title: event.title,
          start: new Date(event.startDate),
          end: new Date(event.endDate),
        }));
        setEvents(formattedEvents);
      } catch (error) {
        console.error("Failed to fetch events:", error);
      }
    };

    fetchEvents();
  }, []);

  const handleEventClick = (event: Event) => {
    router.push(`/events/${event.id}`);
  };

  return (
    <Card className="p-4">
      <Calendar
        localizer={localizer}
        events={events}
        startAccessor="start"
        endAccessor="end"
        style={{ height: "calc(100vh - 200px)" }}
        views={["month", "week", "day"]}
        onSelectEvent={handleEventClick}
        popup
      />
    </Card>
  );
}

================
File: src/components/dashboard/charts.tsx
================
// src/components/dashboard/charts.tsx
"use client";

import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import {
  LineChart,
  Line,
  BarChart,
  Bar,
  XAxis,
  YAxis,
  CartesianGrid,
  Tooltip,
  ResponsiveContainer,
  PieChart,
  Pie,
  Cell
} from 'recharts';

const COLORS = ['#0088FE', '#00C49F', '#FFBB28', '#FF8042'];

interface ChartData {
  attendanceData: {
    name: string;
    attendees: number;
    capacity: number;
  }[];
  registrationData: {
    name: string;
    registrations: number;
  }[];
  eventTypeData: {
    name: string;
    value: number;
  }[];
}

export function DashboardCharts() {
  // In a real app, this would come from an API
  const data: ChartData = {
    attendanceData: [
      { name: 'Jan', attendees: 85, capacity: 100 },
      { name: 'Feb', attendees: 92, capacity: 100 },
      { name: 'Mar', attendees: 88, capacity: 100 },
      { name: 'Apr', attendees: 95, capacity: 100 },
      { name: 'May', attendees: 90, capacity: 100 },
      { name: 'Jun', attendees: 94, capacity: 100 },
    ],
    registrationData: [
      { name: 'Week 1', registrations: 24 },
      { name: 'Week 2', registrations: 36 },
      { name: 'Week 3', registrations: 42 },
      { name: 'Week 4', registrations: 50 },
    ],
    eventTypeData: [
      { name: 'Conference', value: 35 },
      { name: 'Workshop', value: 25 },
      { name: 'Seminar', value: 20 },
      { name: 'Networking', value: 20 },
    ],
  };

  return (
    <Card className="col-span-4">
      <CardHeader>
        <CardTitle>Analytics Overview</CardTitle>
      </CardHeader>
      <CardContent>
        <Tabs defaultValue="attendance" className="space-y-4">
          <TabsList>
            <TabsTrigger value="attendance">Attendance</TabsTrigger>
            <TabsTrigger value="registrations">Registrations</TabsTrigger>
            <TabsTrigger value="types">Event Types</TabsTrigger>
          </TabsList>
          
          <TabsContent value="attendance" className="h-[300px]">
            <ResponsiveContainer width="100%" height="100%">
              <LineChart data={data.attendanceData}>
                <CartesianGrid strokeDasharray="3 3" />
                <XAxis dataKey="name" />
                <YAxis />
                <Tooltip />
                <Line 
                  type="monotone" 
                  dataKey="attendees" 
                  stroke="#8884d8" 
                  strokeWidth={2}
                />
                <Line 
                  type="monotone" 
                  dataKey="capacity" 
                  stroke="#82ca9d" 
                  strokeWidth={2}
                  strokeDasharray="5 5"
                />
              </LineChart>
            </ResponsiveContainer>
          </TabsContent>

          <TabsContent value="registrations" className="h-[300px]">
            <ResponsiveContainer width="100%" height="100%">
              <BarChart data={data.registrationData}>
                <CartesianGrid strokeDasharray="3 3" />
                <XAxis dataKey="name" />
                <YAxis />
                <Tooltip />
                <Bar 
                  dataKey="registrations" 
                  fill="#8884d8" 
                  radius={[4, 4, 0, 0]}
                />
              </BarChart>
            </ResponsiveContainer>
          </TabsContent>

          <TabsContent value="types" className="h-[300px]">
            <ResponsiveContainer width="100%" height="100%">
              <PieChart>
                <Pie
                  data={data.eventTypeData}
                  cx="50%"
                  cy="50%"
                  labelLine={false}
                  label={({ name, percent }) => `${name} (${(percent * 100).toFixed(0)}%)`}
                  outerRadius={100}
                  fill="#8884d8"
                  dataKey="value"
                >
                  {data.eventTypeData.map((_, index) => (
                    <Cell key={`cell-${index}`} fill={COLORS[index % COLORS.length]} />
                  ))}
                </Pie>
                <Tooltip />
              </PieChart>
            </ResponsiveContainer>
          </TabsContent>
        </Tabs>
      </CardContent>
    </Card>
  );
}

================
File: src/components/dashboard/event-stats.tsx
================
// src/components/dashboard/event-stats.tsx
"use client";

import { useEffect, useState } from "react";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { CalendarCheck2, Users, TrendingUp, Percent } from "lucide-react";

interface StatsProps {
  stats: {
    totalEvents: number;
    upcomingEvents: number;
    totalAttendees: number;
    averageAttendance: number;
  };
}

export function EventStats({ stats }: StatsProps) {
  const [error, setError] = useState<string | null>(null);

  if (error) {
    return (
      <div className="p-4 text-red-500">
        Error loading stats: {error}
      </div>
    );
  }

  return (
    <>
      <Card>
        <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
          <CardTitle className="text-sm font-medium">
            Total Events
          </CardTitle>
          <CalendarCheck2 className="h-4 w-4 text-muted-foreground" />
        </CardHeader>
        <CardContent>
          <div className="text-2xl font-bold">{stats.totalEvents}</div>
          <p className="text-xs text-muted-foreground">
            All your events
          </p>
        </CardContent>
      </Card>

      <Card>
        <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
          <CardTitle className="text-sm font-medium">
            Upcoming Events
          </CardTitle>
          <TrendingUp className="h-4 w-4 text-muted-foreground" />
        </CardHeader>
        <CardContent>
          <div className="text-2xl font-bold">{stats.upcomingEvents}</div>
          <p className="text-xs text-muted-foreground">
            Next 30 days
          </p>
        </CardContent>
      </Card>

      <Card>
        <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
          <CardTitle className="text-sm font-medium">
            Total Attendees
          </CardTitle>
          <Users className="h-4 w-4 text-muted-foreground" />
        </CardHeader>
        <CardContent>
          <div className="text-2xl font-bold">{stats.totalAttendees}</div>
          <p className="text-xs text-muted-foreground">
            Confirmed attendees
          </p>
        </CardContent>
      </Card>

      <Card>
        <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
          <CardTitle className="text-sm font-medium">
            Average Attendance
          </CardTitle>
          <Percent className="h-4 w-4 text-muted-foreground" />
        </CardHeader>
        <CardContent>
          <div className="text-2xl font-bold">
            {stats.averageAttendance}%
          </div>
          <p className="text-xs text-muted-foreground">
            Check-in rate
          </p>
        </CardContent>
      </Card>
    </>
  );
}

================
File: src/components/dashboard/recent-activity.tsx
================
// src/components/dashboard/recent-activity.tsx
"use client";

import { useEffect, useState } from "react";
import { ScrollArea } from "@/components/ui/scroll-area";
import { Avatar, AvatarFallback, AvatarImage } from "@/components/ui/avatar";
import { Badge } from "@/components/ui/badge";
import { formatDistanceToNow } from "date-fns";
import Link from "next/link";
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/components/ui/tooltip";
import { 
  Calendar, 
  UserCheck, 
  UserMinus, 
  MessageSquare, 
  Edit,
  ExternalLink,
  Settings,
  Mail
} from "lucide-react";

interface Activity {
  id: string;
  type: string;
  userId: string;
  eventId: string;
  metadata?: {
    guestId?: string;
    guestName?: string;
    eventTitle?: string;
    changes?: string[];
    messageId?: string;
    messageContent?: string;
  };
  createdAt: string;
  user?: {
    name: string;
    avatar?: string;
    email: string;
  };
  event?: {
    title: string;
  };
}

export function RecentActivity() {
  const [activities, setActivities] = useState<Activity[]>([]);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    fetchActivities();
  }, []);

  const fetchActivities = async () => {
    try {
      const response = await fetch('/api/activities?limit=20');
      if (!response.ok) throw new Error('Failed to fetch activities');
      const data = await response.json();
      
      // Fetch user details for each activity
      const enrichedActivities = await Promise.all(
        data.map(async (activity: Activity) => {
          try {
            const userResponse = await fetch(`/api/users/${activity.userId}`);
            if (userResponse.ok) {
              const userData = await userResponse.json();
              return {
                ...activity,
                user: {
                  name: userData.name || 'Unknown User',
                  avatar: userData.imageUrl,
                  email: userData.emailAddress
                }
              };
            }
          } catch (error) {
            console.error(`Error fetching user data for ${activity.userId}:`, error);
          }
          return activity;
        })
      );

      setActivities(enrichedActivities);
    } catch (error) {
      console.error("Error fetching activities:", error);
    } finally {
      setLoading(false);
    }
  };

  const getActivityIcon = (type: string) => {
    const icons = {
      'event.created': <Calendar className="h-4 w-4" />,
      'event.updated': <Edit className="h-4 w-4" />,
      'event.cancelled': <UserMinus className="h-4 w-4" />,
      'guest.invited': <Mail className="h-4 w-4" />,
      'guest.confirmed': <UserCheck className="h-4 w-4" />,
      'guest.declined': <UserMinus className="h-4 w-4" />,
      'guest.checked_in': <UserCheck className="h-4 w-4" />,
      'guest.removed': <UserMinus className="h-4 w-4" />,
      'message.sent': <MessageSquare className="h-4 w-4" />,
      'settings.updated': <Settings className="h-4 w-4" />,
    };
    return icons[type as keyof typeof icons] || <Calendar className="h-4 w-4" />;
  };

  const getActivityColor = (type: string) => {
    const colors = {
      'event.created': "bg-green-100 text-green-800",
      'event.updated': "bg-yellow-100 text-yellow-800",
      'event.cancelled': "bg-red-100 text-red-800",
      'guest.invited': "bg-blue-100 text-blue-800",
      'guest.confirmed': "bg-green-100 text-green-800",
      'guest.declined': "bg-red-100 text-red-800",
      'guest.checked_in': "bg-green-100 text-green-800",
      'guest.removed': "bg-red-100 text-red-800",
      'message.sent': "bg-purple-100 text-purple-800",
      'settings.updated': "bg-yellow-100 text-yellow-800",
    };
    return colors[type as keyof typeof colors] || "bg-gray-100 text-gray-800";
  };

  const formatActivityMessage = (activity: Activity) => {
    switch (activity.type) {
      case 'event.created':
        return `created event "${activity.metadata?.eventTitle}"`;
      case 'event.updated':
        return `updated event details (${activity.metadata?.changes?.join(', ')})`;
      case 'event.cancelled':
        return `cancelled event "${activity.metadata?.eventTitle}"`;
      case 'guest.invited':
        return `invited ${activity.metadata?.guestName} to the event`;
      case 'guest.confirmed':
        return `confirmed attendance for ${activity.metadata?.guestName}`;
      case 'guest.declined':
        return `declined attendance for ${activity.metadata?.guestName}`;
      case 'guest.checked_in':
        return `checked in ${activity.metadata?.guestName}`;
      case 'guest.removed':
        return `removed ${activity.metadata?.guestName} from the event`;
      case 'message.sent':
        return `sent a message: "${activity.metadata?.messageContent}"`;
      case 'settings.updated':
        return `updated event settings`;
      default:
        return 'performed an action';
    }
  };

  if (loading) {
    return (
      <div className="space-y-4">
        {[1, 2, 3].map((index) => (
          <div
            key={index}
            className="flex items-start space-x-4 animate-pulse"
          >
            <div className="h-10 w-10 rounded-full bg-gray-200" />
            <div className="space-y-2 flex-1">
              <div className="h-4 w-3/4 bg-gray-200 rounded" />
              <div className="h-3 w-1/2 bg-gray-200 rounded" />
            </div>
          </div>
        ))}
      </div>
    );
  }

  return (
    <ScrollArea className="h-[400px]">
      <div className="space-y-4 pr-4">
        {activities.map((activity) => (
          <div
            key={activity.id}
            className="flex items-start space-x-4 border-b pb-4 last:border-0"
          >
            <TooltipProvider>
              <Tooltip>
                <TooltipTrigger>
                  <Avatar>
                    <AvatarImage 
                      src={activity.user?.avatar || `https://api.dicebear.com/7.x/initials/svg?seed=${activity.userId}`} 
                    />
                    <AvatarFallback>
                      {activity.user?.name?.[0] || 'U'}
                    </AvatarFallback>
                  </Avatar>
                </TooltipTrigger>
                <TooltipContent>
                  <div>{activity.user?.name || 'User'}</div>
                  <div className="text-xs text-muted-foreground">
                    {activity.user?.email || activity.userId}
                  </div>
                </TooltipContent>
              </Tooltip>
            </TooltipProvider>
            
            <div className="flex-1 space-y-1">
              <div className="flex items-center gap-2">
                <Badge className={getActivityColor(activity.type)}>
                  <span className="flex items-center gap-1">
                    {getActivityIcon(activity.type)}
                    {activity.type.split('.')[0]}
                  </span>
                </Badge>
                <span className="text-xs text-muted-foreground">
                  {formatDistanceToNow(new Date(activity.createdAt), { addSuffix: true })}
                </span>
              </div>
              
              <div className="text-sm">
                <span className="font-medium">{activity.user?.name || 'User'} </span>
                {formatActivityMessage(activity)}
              </div>
            </div>

            {activity.eventId && (
              <Link
                href={`/events/${activity.eventId}`}
                className="shrink-0 hover:text-primary"
              >
                <ExternalLink className="h-4 w-4" />
              </Link>
            )}
          </div>
        ))}
      </div>
    </ScrollArea>
  );
}

================
File: src/components/dashboard/upcoming-events.tsx
================
"use client";

import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import { ScrollArea } from "@/components/ui/scroll-area";
import { Calendar, Clock, MapPin, Users } from "lucide-react";
import { format } from "date-fns";
import Link from "next/link";

interface Event {
  id: string;
  title: string;
  startDate: Date;
  location: {
    venue: string;
  };
  attendees: {
    confirmed: number;
    total: number;
  };
  status: "upcoming" | "ongoing" | "ended";
}

export function UpcomingEvents() {
  // In a real app, this would come from an API
  const events: Event[] = [
    {
      id: "1",
      title: "Tech Conference 2024",
      startDate: new Date("2024-07-15"),
      location: { venue: "Convention Center" },
      attendees: { confirmed: 120, total: 150 },
      status: "upcoming"
    },
    // Add more events...
  ];

  const getStatusColor = (status: string) => {
    const colors = {
      upcoming: "bg-blue-100 text-blue-800",
      ongoing: "bg-green-100 text-green-800",
      ended: "bg-gray-100 text-gray-800"
    };
    return colors[status as keyof typeof colors];
  };

  return (
    <Card>
      <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
        <CardTitle>Upcoming Events</CardTitle>
        <Link href="/events">
          <Button variant="outline" size="sm">View All</Button>
        </Link>
      </CardHeader>
      <CardContent>
        <ScrollArea className="h-[400px] pr-4">
          <div className="space-y-4">
            {events.map((event) => (
              <Link 
                key={event.id} 
                href={`/events/${event.id}`}
                className="block"
              >
                <div className="rounded-lg border p-3 hover:bg-accent transition-colors">
                  <div className="flex items-start justify-between">
                    <h3 className="font-medium">{event.title}</h3>
                    <Badge className={getStatusColor(event.status)}>
                      {event.status}
                    </Badge>
                  </div>
                  
                  <div className="mt-2 space-y-1">
                    <div className="flex items-center text-sm text-muted-foreground">
                      <Calendar className="mr-2 h-4 w-4" />
                      {format(event.startDate, "PPP")}
                    </div>
                    <div className="flex items-center text-sm text-muted-foreground">
                      <Clock className="mr-2 h-4 w-4" />
                      {format(event.startDate, "p")}
                    </div>
                    <div className="flex items-center text-sm text-muted-foreground">
                      <MapPin className="mr-2 h-4 w-4" />
                      {event.location.venue}
                    </div>
                    <div className="flex items-center text-sm text-muted-foreground">
                      <Users className="mr-2 h-4 w-4" />
                      {event.attendees.confirmed} / {event.attendees.total} attendees
                    </div>
                  </div>
                </div>
              </Link>
            ))}
          </div>
        </ScrollArea>
      </CardContent>
    </Card>
  );
}

================
File: src/components/events/check-in.tsx
================
"use client";

import { useState } from "react";
import { QRCodeSVG } from "qrcode.react";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogTrigger,
} from "@/components/ui/dialog";
import { useToast } from "@/hooks/use-toast";
import { 
  QrCode, 
  UserCheck,
  Search,
  UserX 
} from "lucide-react";

interface CheckInProps {
  eventId: string;
  onCheckedIn?: () => void;
}

export function CheckIn({ eventId, onCheckedIn }: CheckInProps) {
  const [searchQuery, setSearchQuery] = useState("");
  const [scanning, setScanning] = useState(false);
  const { toast } = useToast();
  const checkInUrl = `${window.location.origin}/events/${eventId}/check-in`;

  const handleCheckIn = async (guestId: string) => {
    try {
      const response = await fetch(`/api/events/${eventId}/check-in`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({ guestId }),
      });

      if (!response.ok) throw new Error("Check-in failed");

      const data = await response.json();
      toast({
        title: "Checked In Successfully",
        description: `${data.guest.name} has been checked in.`,
      });

      if (onCheckedIn) onCheckedIn();
    } catch (error) {
      toast({
        variant: "destructive",
        title: "Check-in Failed",
        description: "Unable to check in guest. Please try again.",
      });
    }
  };

  const searchGuests = async () => {
    try {
      const response = await fetch(
        `/api/events/${eventId}/guests/search?q=${encodeURIComponent(searchQuery)}`
      );
      if (!response.ok) throw new Error("Search failed");
      return await response.json();
    } catch (error) {
      console.error("Error searching guests:", error);
      return [];
    }
  };

  return (
    <div className="space-y-4">
      <div className="flex items-center justify-between">
        <div className="flex gap-2">
          <Input
            placeholder="Search guests..."
            value={searchQuery}
            onChange={(e) => setSearchQuery(e.target.value)}
            className="w-64"
          />
          <Button onClick={searchGuests}>
            <Search className="h-4 w-4 mr-2" />
            Search
          </Button>
        </div>

        <Dialog>
          <DialogTrigger asChild>
            <Button variant="outline">
              <QrCode className="h-4 w-4 mr-2" />
              Show QR Code
            </Button>
          </DialogTrigger>
          <DialogContent>
            <DialogHeader>
              <DialogTitle>Event Check-in QR Code</DialogTitle>
            </DialogHeader>
            <div className="flex justify-center p-4">
              <QRCodeSVG value={checkInUrl} size={256} />
            </div>
            <p className="text-center text-sm text-muted-foreground">
              Scan this QR code to check in to the event
            </p>
          </DialogContent>
        </Dialog>
      </div>

      {/* Guest search results and check-in UI would go here */}
    </div>
  );
}

================
File: src/components/events/event-card.tsx
================
// src/components/events/event-card.tsx
import {
  Card,
  CardContent,
  CardDescription,
  CardFooter,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import { Calendar, Clock, MapPin, Users } from "lucide-react";
import { format } from "date-fns";
import Link from "next/link";

interface EventCardProps {
  event: {
    id: string;
    title: string;
    description: string;
    startDate: Date;
    endDate: Date;
    location: {
      venue: string;
    };
    capacity: number;
    status: string;
  };
}

export function EventCard({ event }: EventCardProps) {
  return (
    <Card>
      <CardHeader>
        <div className="flex items-center justify-between">
          <CardTitle className="line-clamp-1">{event.title}</CardTitle>
          <Badge variant={event.status === "published" ? "default" : "secondary"}>
            {event.status}
          </Badge>
        </div>
        <CardDescription className="line-clamp-2">
          {event.description}
        </CardDescription>
      </CardHeader>
      <CardContent className="space-y-2">
        <div className="flex items-center space-x-2 text-sm">
          <Calendar className="h-4 w-4" />
          <span>{format(new Date(event.startDate), "PPP")}</span>
        </div>
        <div className="flex items-center space-x-2 text-sm">
          <Clock className="h-4 w-4" />
          <span>{format(new Date(event.startDate), "p")}</span>
        </div>
        <div className="flex items-center space-x-2 text-sm">
          <MapPin className="h-4 w-4" />
          <span>{event.location.venue}</span>
        </div>
        <div className="flex items-center space-x-2 text-sm">
          <Users className="h-4 w-4" />
          <span>{event.capacity} attendees</span>
        </div>
      </CardContent>
      <CardFooter className="flex justify-between">
        <Link href={`/events/${event.id}/edit`}>
          <Button variant="outline">Edit</Button>
        </Link>
        <Link href={`/events/${event.id}`}>
          <Button>View Details</Button>
        </Link>
      </CardFooter>
    </Card>
  );
}

================
File: src/components/events/event-chat.tsx
================
"use client";

import { useEffect, useRef, useState } from "react";
import { Avatar, AvatarFallback, AvatarImage } from "@/components/ui/avatar";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { ScrollArea } from "@/components/ui/scroll-area";
import { format } from "date-fns";
import { pusherClient } from "@/lib/pusher";
import { useUser } from "@clerk/nextjs";

interface Message {
  id: string;
  content: string;
  senderId: string;
  senderName: string;
  senderAvatar?: string;
  createdAt: string;
}

export function EventChat({ eventId }: { eventId: string }) {
  const [messages, setMessages] = useState<Message[]>([]);
  const [newMessage, setNewMessage] = useState("");
  const [isLoading, setIsLoading] = useState(false);
  const scrollRef = useRef<HTMLDivElement>(null);
  const { user } = useUser();

  useEffect(() => {
    fetchMessages();
    const channel = pusherClient.subscribe(`event-${eventId}`);
    
    channel.bind("new-message", (message: Message) => {
      setMessages((current) => [...current, message]);
      scrollToBottom();
    });

    return () => {
      pusherClient.unsubscribe(`event-${eventId}`);
    };
  }, [eventId]);

  const fetchMessages = async () => {
    try {
      const response = await fetch(`/api/events/${eventId}/chat`);
      const data = await response.json();
      setMessages(data);
      scrollToBottom();
    } catch (error) {
      console.error("Error fetching messages:", error);
    }
  };

  const scrollToBottom = () => {
    if (scrollRef.current) {
      scrollRef.current.scrollIntoView({ behavior: "smooth" });
    }
  };

  const sendMessage = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!newMessage.trim() || isLoading) return;

    setIsLoading(true);
    try {
      await fetch(`/api/events/${eventId}/chat`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          content: newMessage,
          senderName: user?.fullName,
          senderAvatar: user?.imageUrl,
        }),
      });
      setNewMessage("");
    } catch (error) {
      console.error("Error sending message:", error);
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <div className="flex flex-col h-[600px]">
      <ScrollArea className="flex-1 p-4">
        <div className="space-y-4">
          {messages.map((message) => (
            <div
              key={message.id}
              className={`flex items-start space-x-2 ${
                message.senderId === user?.id ? "justify-end" : ""
              }`}
            >
              {message.senderId !== user?.id && (
                <Avatar>
                  <AvatarImage src={message.senderAvatar} />
                  <AvatarFallback>
                    {message.senderName?.[0]?.toUpperCase()}
                  </AvatarFallback>
                </Avatar>
              )}
              <div
                className={`flex flex-col space-y-1 ${
                  message.senderId === user?.id ? "items-end" : ""
                }`}
              >
                <div
                  className={`px-4 py-2 rounded-lg ${
                    message.senderId === user?.id
                      ? "bg-primary text-primary-foreground"
                      : "bg-muted"
                  }`}
                >
                  <p>{message.content}</p>
                </div>
                <span className="text-xs text-muted-foreground">
                  {format(new Date(message.createdAt), "p")}
                </span>
              </div>
            </div>
          ))}
          <div ref={scrollRef} />
        </div>
      </ScrollArea>
      <form onSubmit={sendMessage} className="p-4 border-t">
        <div className="flex space-x-2">
          <Input
            value={newMessage}
            onChange={(e) => setNewMessage(e.target.value)}
            placeholder="Type your message..."
            disabled={isLoading}
          />
          <Button type="submit" disabled={isLoading}>
            Send
          </Button>
        </div>
      </form>
    </div>
  );
}

================
File: src/components/events/event-form.tsx
================
"use client";

import * as z from "zod";
import { zodResolver } from "@hookform/resolvers/zod";
import { useForm } from "react-hook-form";
import { Button } from "@/components/ui/button";
import {
  Form,
  FormControl,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
} from "@/components/ui/form";
import { Input } from "@/components/ui/input";
import { Textarea } from "@/components/ui/textarea";
import { Calendar } from "@/components/ui/calendar";
import {
  Popover,
  PopoverContent,
  PopoverTrigger,
} from "@/components/ui/popover";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { cn } from "@/lib/utils";
import { format } from "date-fns";
import { CalendarIcon } from "lucide-react";
import { useState } from "react";
import { useRouter } from "next/navigation";
import { useToast } from "@/hooks/use-toast";

const formSchema = z.object({
  title: z.string().min(2).max(100),
  description: z.string().min(10),
  startDate: z.date(),
  endDate: z.date(),
  venue: z.string().min(2),
  address: z.string().min(5),
  capacity: z.string().transform(Number),
  visibility: z.enum(["public", "private"]),
  recurring: z.enum(["none", "daily", "weekly", "monthly"]),
});

interface EventFormProps {
  event?: any;
  isEditing?: boolean;
}

export function EventForm({ event, isEditing = false }: EventFormProps) {
  const router = useRouter();
  const [isLoading, setIsLoading] = useState(false);
  const { toast } = useToast();

  const form = useForm<z.infer<typeof formSchema>>({
    resolver: zodResolver(formSchema),
    defaultValues: {
      title: event?.title || "",
      description: event?.description || "",
      venue: event?.location?.venue || "",
      address: event?.location?.address || "",
      capacity: event?.capacity || "0",
      visibility: event?.visibility || "private",
      recurring: event?.recurring?.pattern || "none",
      startDate: event?.startDate ? new Date(event.startDate) : undefined,
      endDate: event?.endDate ? new Date(event.endDate) : undefined,
    },
  });

  async function onSubmit(values: z.infer<typeof formSchema>) {
    try {
      setIsLoading(true);
      const url = isEditing ? `/api/events/${event.id}` : "/api/events";
      const method = isEditing ? "PATCH" : "POST";

      const response = await fetch(url, {
        method,
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify(values),
      });

      if (!response.ok) {
        throw new Error(isEditing ? "Failed to update event" : "Failed to create event");
      }

      const data = await response.json();
      router.push(`/events/${data.id}`);
      router.refresh();
    } catch (error) {
      console.error(error);
    } finally {
      setIsLoading(false);
    }
  }

  return (
    <Form {...form}>
      <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-8">
        <FormField
          control={form.control}
          name="title"
          render={({ field }) => (
            <FormItem>
              <FormLabel>Event Title</FormLabel>
              <FormControl>
                <Input placeholder="Tech Conference 2024" {...field} />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />

        <FormField
          control={form.control}
          name="description"
          render={({ field }) => (
            <FormItem>
              <FormLabel>Description</FormLabel>
              <FormControl>
                <Textarea
                  placeholder="Enter event description"
                  className="h-32"
                  {...field}
                />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />

        <div className="grid gap-6 md:grid-cols-2">
          <FormField
            control={form.control}
            name="startDate"
            render={({ field }) => (
              <FormItem className="flex flex-col">
                <FormLabel>Start Date</FormLabel>
                <Popover>
                  <PopoverTrigger asChild>
                    <FormControl>
                      <Button
                        variant="outline"
                        className={cn(
                          "w-full pl-3 text-left font-normal",
                          !field.value && "text-muted-foreground"
                        )}
                      >
                        {field.value ? (
                          format(field.value, "PPP")
                        ) : (
                          <span>Pick a date</span>
                        )}
                        <CalendarIcon className="ml-auto h-4 w-4 opacity-50" />
                      </Button>
                    </FormControl>
                  </PopoverTrigger>
                  <PopoverContent className="w-auto p-0" align="start">
                    <Calendar
                      mode="single"
                      selected={field.value}
                      onSelect={field.onChange}
                      disabled={(date) =>
                        date < new Date() || date < new Date("1900-01-01")
                      }
                      initialFocus
                    />
                  </PopoverContent>
                </Popover>
                <FormMessage />
              </FormItem>
            )}
          />

          <FormField
            control={form.control}
            name="endDate"
            render={({ field }) => (
              <FormItem className="flex flex-col">
                <FormLabel>End Date</FormLabel>
                <Popover>
                  <PopoverTrigger asChild>
                    <FormControl>
                      <Button
                        variant="outline"
                        className={cn(
                          "w-full pl-3 text-left font-normal",
                          !field.value && "text-muted-foreground"
                        )}
                      >
                        {field.value ? (
                          format(field.value, "PPP")
                        ) : (
                          <span>Pick a date</span>
                        )}
                        <CalendarIcon className="ml-auto h-4 w-4 opacity-50" />
                      </Button>
                    </FormControl>
                  </PopoverTrigger>
                  <PopoverContent className="w-auto p-0" align="start">
                    <Calendar
                      mode="single"
                      selected={field.value}
                      onSelect={field.onChange}
                      disabled={(date) =>
                        date < new Date() || date < new Date("1900-01-01")
                      }
                      initialFocus
                    />
                  </PopoverContent>
                </Popover>
                <FormMessage />
              </FormItem>
            )}
          />
        </div>

        <div className="grid gap-6 md:grid-cols-2">
          <FormField
            control={form.control}
            name="venue"
            render={({ field }) => (
              <FormItem>
                <FormLabel>Venue Name</FormLabel>
                <FormControl>
                  <Input placeholder="Convention Center" {...field} />
                </FormControl>
                <FormMessage />
              </FormItem>
            )}
          />

          <FormField
            control={form.control}
            name="address"
            render={({ field }) => (
              <FormItem>
                <FormLabel>Address</FormLabel>
                <FormControl>
                  <Input placeholder="123 Main St, City" {...field} />
                </FormControl>
                <FormMessage />
              </FormItem>
            )}
          />
        </div>

        <div className="grid gap-6 md:grid-cols-3">
          <FormField
            control={form.control}
            name="capacity"
            render={({ field }) => (
              <FormItem>
                <FormLabel>Capacity</FormLabel>
                <FormControl>
                  <Input
                    type="number"
                    placeholder="100"
                    {...field}
                  />
                </FormControl>
                <FormMessage />
              </FormItem>
            )}
          />

          <FormField
            control={form.control}
            name="visibility"
            render={({ field }) => (
              <FormItem>
                <FormLabel>Visibility</FormLabel>
                <Select
                  onValueChange={field.onChange}
                  defaultValue={field.value}
                >
                  <FormControl>
                    <SelectTrigger>
                      <SelectValue placeholder="Select visibility" />
                    </SelectTrigger>
                  </FormControl>
                  <SelectContent>
                    <SelectItem value="public">Public</SelectItem>
                    <SelectItem value="private">Private</SelectItem>
                  </SelectContent>
                </Select>
                <FormMessage />
              </FormItem>
            )}
          />

          <FormField
            control={form.control}
            name="recurring"
            render={({ field }) => (
              <FormItem>
                <FormLabel>Recurring</FormLabel>
                <Select
                  onValueChange={field.onChange}
                  defaultValue={field.value}
                >
                  <FormControl>
                    <SelectTrigger>
                      <SelectValue placeholder="Select pattern" />
                    </SelectTrigger>
                  </FormControl>
                  <SelectContent>
                    <SelectItem value="none">None</SelectItem>
                    <SelectItem value="daily">Daily</SelectItem>
                    <SelectItem value="weekly">Weekly</SelectItem>
                    <SelectItem value="monthly">Monthly</SelectItem>
                  </SelectContent>
                </Select>
                <FormMessage />
              </FormItem>
            )}
          />
        </div>

        <Button type="submit" className="w-full" disabled={isLoading}>
          {isLoading 
            ? (isEditing ? "Updating..." : "Creating...") 
            : (isEditing ? "Update Event" : "Create Event")
          }
        </Button>
      </form>
    </Form>
  );
}

================
File: src/components/events/guest-list.tsx
================
"use client";

import { useState, useEffect } from "react";
import { useUser } from "@clerk/nextjs";
import { Avatar, AvatarFallback, AvatarImage } from "@/components/ui/avatar";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogHeader,
  DialogTitle,
  DialogTrigger,
  DialogFooter,
} from "@/components/ui/dialog";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Textarea } from "@/components/ui/textarea";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { Skeleton } from "@/components/ui/skeleton";
import { useToast } from "@/hooks/use-toast";
import {
  MoreVertical,
  UserPlus,
  Mail,
  Check,
  X,
  Clock,
  Users,
  UserCog,
  Trash,
} from "lucide-react";
import { format } from "date-fns";

interface Guest {
  id: string;
  name: string;
  email: string;
  status: "invited" | "confirmed" | "declined" | "waitlist";
  role: "attendee" | "coHost" | "moderator";
  checkedIn: boolean;
  checkedInAt?: string;
  dietaryPreferences?: string[];
  plusOne?: {
    name: string;
    dietaryPreferences: string[];
  };
  invitedAt: string;
  responseDate?: string;
}

interface GuestListProps {
  eventId: string;
  isOrganizer?: boolean;
}

export function GuestList({ eventId, isOrganizer = false }: GuestListProps) {
  const [guests, setGuests] = useState<Guest[]>([]);
  const [loading, setLoading] = useState(true);
  const [filter, setFilter] = useState<string>("all");
  const [search, setSearch] = useState("");
  const [inviteDialogOpen, setInviteDialogOpen] = useState(false);
  const [guestDialogOpen, setGuestDialogOpen] = useState(false);
  const [selectedGuest, setSelectedGuest] = useState<Guest | null>(null);
  const { user } = useUser();
  const { toast } = useToast();

  // Form states for inviting guests
  const [inviteEmail, setInviteEmail] = useState("");
  const [inviteRole, setInviteRole] = useState("attendee");
  const [inviteMessage, setInviteMessage] = useState("");

  useEffect(() => {
    fetchGuests();
  }, [eventId]);

  const fetchGuests = async () => {
    try {
      const response = await fetch(`/api/events/${eventId}/guests`);
      if (!response.ok) throw new Error("Failed to fetch guests");
      const data = await response.json();
      setGuests(data);
    } catch (error) {
      console.error("Error fetching guests:", error);
      toast({
        variant: "destructive",
        title: "Error",
        description: "Failed to load guest list",
      });
    } finally {
      setLoading(false);
    }
  };

  const inviteGuest = async () => {
    try {
      const response = await fetch(`/api/events/${eventId}/guests`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          email: inviteEmail,
          role: inviteRole,
          message: inviteMessage,
        }),
      });

      if (!response.ok) throw new Error("Failed to invite guest");

      toast({
        title: "Success",
        description: "Invitation sent successfully",
      });

      setInviteDialogOpen(false);
      clearInviteForm();
      fetchGuests();
    } catch (error) {
      console.error("Error inviting guest:", error);
      toast({
        variant: "destructive",
        title: "Error",
        description: "Failed to send invitation",
      });
    }
  };

  const updateGuestStatus = async (guestId: string, newStatus: string) => {
    try {
      const response = await fetch(`/api/events/${eventId}/guests/${guestId}`, {
        method: "PATCH",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({ status: newStatus }),
      });

      if (!response.ok) throw new Error("Failed to update guest status");

      toast({
        title: "Success",
        description: "Guest status updated",
      });

      fetchGuests();
    } catch (error) {
      console.error("Error updating guest status:", error);
      toast({
        variant: "destructive",
        title: "Error",
        description: "Failed to update guest status",
      });
    }
  };

  const removeGuest = async (guestId: string) => {
    try {
      const response = await fetch(`/api/events/${eventId}/guests/${guestId}`, {
        method: "DELETE",
      });

      if (!response.ok) throw new Error("Failed to remove guest");

      toast({
        title: "Success",
        description: "Guest removed successfully",
      });

      fetchGuests();
    } catch (error) {
      console.error("Error removing guest:", error);
      toast({
        variant: "destructive",
        title: "Error",
        description: "Failed to remove guest",
      });
    }
  };

  const clearInviteForm = () => {
    setInviteEmail("");
    setInviteRole("attendee");
    setInviteMessage("");
  };

  const filteredGuests = guests.filter((guest) => {
    const matchesFilter =
      filter === "all" || guest.status === filter;
    const matchesSearch =
      guest.name.toLowerCase().includes(search.toLowerCase()) ||
      guest.email.toLowerCase().includes(search.toLowerCase());
    return matchesFilter && matchesSearch;
  });

  const getStatusColor = (status: string) => {
    const colors = {
      invited: "bg-blue-100 text-blue-800",
      confirmed: "bg-green-100 text-green-800",
      declined: "bg-red-100 text-red-800",
      waitlist: "bg-yellow-100 text-yellow-800",
    };
    return colors[status as keyof typeof colors] || "bg-gray-100 text-gray-800";
  };

  if (loading) {
    return <GuestListSkeleton />;
  }

  return (
    <div className="space-y-4">
      <div className="flex items-center justify-between">
        <div className="flex gap-2">
          <Input
            placeholder="Search guests..."
            value={search}
            onChange={(e) => setSearch(e.target.value)}
            className="w-64"
          />
          <Select value={filter} onValueChange={setFilter}>
            <SelectTrigger className="w-[180px]">
              <SelectValue placeholder="Filter by status" />
            </SelectTrigger>
            <SelectContent>
              <SelectItem value="all">All Guests</SelectItem>
              <SelectItem value="invited">Invited</SelectItem>
              <SelectItem value="confirmed">Confirmed</SelectItem>
              <SelectItem value="declined">Declined</SelectItem>
              <SelectItem value="waitlist">Waitlist</SelectItem>
            </SelectContent>
          </Select>
        </div>

        {isOrganizer && (
          <Dialog open={inviteDialogOpen} onOpenChange={setInviteDialogOpen}>
            <DialogTrigger asChild>
              <Button>
                <UserPlus className="mr-2 h-4 w-4" />
                Invite Guest
              </Button>
            </DialogTrigger>
            <DialogContent>
              <DialogHeader>
                <DialogTitle>Invite Guest</DialogTitle>
                <DialogDescription>
                  Send an invitation to join the event
                </DialogDescription>
              </DialogHeader>
              <div className="space-y-4 py-4">
                <div className="space-y-2">
                  <Label htmlFor="email">Email</Label>
                  <Input
                    id="email"
                    placeholder="Enter email address"
                    value={inviteEmail}
                    onChange={(e) => setInviteEmail(e.target.value)}
                  />
                </div>
                <div className="space-y-2">
                  <Label htmlFor="role">Role</Label>
                  <Select value={inviteRole} onValueChange={setInviteRole}>
                    <SelectTrigger>
                      <SelectValue placeholder="Select role" />
                    </SelectTrigger>
                    <SelectContent>
                      <SelectItem value="attendee">Attendee</SelectItem>
                      <SelectItem value="coHost">Co-Host</SelectItem>
                      <SelectItem value="moderator">Moderator</SelectItem>
                    </SelectContent>
                  </Select>
                </div>
                <div className="space-y-2">
                  <Label htmlFor="message">Personal Message (Optional)</Label>
                  <Textarea
                    id="message"
                    placeholder="Add a personal message..."
                    value={inviteMessage}
                    onChange={(e) => setInviteMessage(e.target.value)}
                  />
                </div>
              </div>
              <DialogFooter>
                <Button variant="outline" onClick={() => setInviteDialogOpen(false)}>
                  Cancel
                </Button>
                <Button onClick={inviteGuest}>Send Invitation</Button>
              </DialogFooter>
            </DialogContent>
          </Dialog>
        )}
      </div>

      <div className="rounded-md border">
        <Table>
          <TableHeader>
            <TableRow>
              <TableHead>Guest</TableHead>
              <TableHead>Status</TableHead>
              <TableHead>Role</TableHead>
              <TableHead>Invited</TableHead>
              <TableHead>Check-in</TableHead>
              <TableHead></TableHead>
            </TableRow>
          </TableHeader>
          <TableBody>
            {filteredGuests.map((guest) => (
              <TableRow key={guest.id}>
                <TableCell>
                  <div className="flex items-center space-x-3">
                    <Avatar>
                      <AvatarImage src={`https://api.dicebear.com/7.x/initials/svg?seed=${encodeURIComponent(guest.name)}`} />
                      <AvatarFallback>{guest.name.charAt(0)}</AvatarFallback>
                    </Avatar>
                    <div>
                      <div className="font-medium">{guest.name}</div>
                      <div className="text-sm text-muted-foreground">
                        {guest.email}
                      </div>
                    </div>
                  </div>
                </TableCell>
                <TableCell>
                  <Badge variant="secondary" className={getStatusColor(guest.status)}>
                    {guest.status}
                  </Badge>
                </TableCell>
                <TableCell>
                  <span className="capitalize">{guest.role}</span>
                </TableCell>
                <TableCell>
                  {format(new Date(guest.invitedAt), "MMM d, yyyy")}
                </TableCell>
                <TableCell>
                  {guest.checkedIn ? (
                    <div className="text-sm text-muted-foreground">
                      {format(new Date(guest.checkedInAt!), "MMM d, h:mm a")}
                    </div>
                  ) : (
                    <Badge variant="outline">Not Checked In</Badge>
                  )}
                </TableCell>
                <TableCell>
                  <DropdownMenu>
                    <DropdownMenuTrigger asChild>
                      <Button variant="ghost" size="icon">
                        <MoreVertical className="h-4 w-4" />
                      </Button>
                    </DropdownMenuTrigger>
                    <DropdownMenuContent align="end">
                      <DropdownMenuLabel>Actions</DropdownMenuLabel>
                      <DropdownMenuSeparator />
                      {isOrganizer && (
                        <>
                          <DropdownMenuItem 
                            onClick={() => updateGuestStatus(guest.id, "confirmed")}
                            disabled={guest.status === "confirmed"}
                          >
                            <Check className="mr-2 h-4 w-4" />
                            Confirm
                          </DropdownMenuItem>
                          <DropdownMenuItem
                            onClick={() => updateGuestStatus(guest.id, "waitlist")}
                            disabled={guest.status === "waitlist"}
                          >
                            <Clock className="mr-2 h-4 w-4" />
                            Move to Waitlist
                          </DropdownMenuItem>
                          <DropdownMenuItem>
                            <UserCog className="mr-2 h-4 w-4" />
                            Change Role
                          </DropdownMenuItem>
                          <DropdownMenuSeparator />
                        </>
                      )}
                      <DropdownMenuItem onClick={() => {
                        setSelectedGuest(guest);
                        setGuestDialogOpen(true);
                      }}>
                        <Users className="mr-2 h-4 w-4" />
                        View Details
                      </DropdownMenuItem>
                      <DropdownMenuItem onClick={() => {
                        window.location.href = `mailto:${guest.email}`;
                      }}>
                        <Mail className="mr-2 h-4 w-4" />
                        Send Email
                      </DropdownMenuItem>
                      {isOrganizer && (
                        <DropdownMenuItem
                          className="text-red-600"
                          onClick={() => removeGuest(guest.id)}
                        >
                          <Trash className="mr-2 h-4 w-4" />
                          Remove
                        </DropdownMenuItem>
                      )}
                    </DropdownMenuContent>
                  </DropdownMenu>
                </TableCell>
              </TableRow>
            ))}
            {filteredGuests.length === 0 && (
              <TableRow>
                <TableCell colSpan={6} className="text-center py-8">
                  <div className="flex flex-col items-center space-y-2">
                    <Users className="h-8 w-8 text-muted-foreground" />
                    <p className="text-muted-foreground">No guests found</p>
                    {search && (
                      <Button 
                        variant="link" 
                        onClick={() => setSearch("")}
                      >
                        Clear search
                      </Button>
                    )}
                  </div>
                </TableCell>
              </TableRow>
            )}
          </TableBody>
        </Table>
      </div>

      {/* Guest Details Dialog */}
      <Dialog open={guestDialogOpen} onOpenChange={setGuestDialogOpen}>
        <DialogContent className="sm:max-w-[500px]">
          <DialogHeader>
            <DialogTitle>Guest Details</DialogTitle>
          </DialogHeader>
          {selectedGuest && (
            <div className="space-y-4">
              <div className="flex items-center space-x-4">
                <Avatar className="h-16 w-16">
                  <AvatarImage 
                    src={`https://api.dicebear.com/7.x/initials/svg?seed=${
                      encodeURIComponent(selectedGuest.name)
                    }`} 
                  />
                  <AvatarFallback>{selectedGuest.name.charAt(0)}</AvatarFallback>
                </Avatar>
                <div>
                  <h3 className="text-lg font-medium">{selectedGuest.name}</h3>
                  <p className="text-sm text-muted-foreground">{selectedGuest.email}</p>
                </div>
              </div>

              <div className="grid grid-cols-2 gap-4">
                <div>
                  <Label>Status</Label>
                  <div className="mt-1">
                    <Badge variant="secondary" className={getStatusColor(selectedGuest.status)}>
                      {selectedGuest.status}
                    </Badge>
                  </div>
                </div>
                <div>
                  <Label>Role</Label>
                  <p className="mt-1 capitalize">{selectedGuest.role}</p>
                </div>
                <div>
                  <Label>Invited On</Label>
                  <p className="mt-1">
                    {format(new Date(selectedGuest.invitedAt), "PPP")}
                  </p>
                </div>
                <div>
                  <Label>Response Date</Label>
                  <p className="mt-1">
                    {selectedGuest.responseDate
                      ? format(new Date(selectedGuest.responseDate), "PPP")
                      : "No response yet"}
                  </p>
                </div>
              </div>

              {selectedGuest.dietaryPreferences && selectedGuest.dietaryPreferences.length > 0 && (
                <div>
                  <Label>Dietary Preferences</Label>
                  <div className="mt-1 flex flex-wrap gap-1">
                    {selectedGuest.dietaryPreferences.map((pref) => (
                      <Badge key={pref} variant="outline">
                        {pref}
                      </Badge>
                    ))}
                  </div>
                </div>
              )}

              {selectedGuest.plusOne && (
                <div>
                  <Label>Plus One</Label>
                  <div className="mt-1 space-y-2">
                    <p className="text-sm font-medium">{selectedGuest.plusOne.name}</p>
                    {selectedGuest.plusOne.dietaryPreferences?.length > 0 && (
                      <div className="flex flex-wrap gap-1">
                        {selectedGuest.plusOne.dietaryPreferences.map((pref) => (
                          <Badge key={pref} variant="outline" className="text-xs">
                            {pref}
                          </Badge>
                        ))}
                      </div>
                    )}
                  </div>
                </div>
              )}

              <div>
                <Label>Check-in Status</Label>
                <div className="mt-1">
                  {selectedGuest.checkedIn ? (
                    <div className="space-y-1">
                      <Badge variant="default">Checked In</Badge>
                      <p className="text-sm text-muted-foreground">
                        {format(new Date(selectedGuest.checkedInAt!), "PPP 'at' p")}
                      </p>
                    </div>
                  ) : (
                    <Badge variant="outline">Not Checked In</Badge>
                  )}
                </div>
              </div>
            </div>
          )}
          <DialogFooter>
            <Button variant="outline" onClick={() => setGuestDialogOpen(false)}>
              Close
            </Button>
            {isOrganizer && selectedGuest && !selectedGuest.checkedIn && (
              <Button 
                onClick={() => {
                  updateGuestStatus(selectedGuest.id, "confirmed");
                  setGuestDialogOpen(false);
                }}
                disabled={selectedGuest.status === "confirmed"}
              >
                <Check className="mr-2 h-4 w-4" />
                Confirm Guest
              </Button>
            )}
          </DialogFooter>
        </DialogContent>
      </Dialog>
    </div>
  );
}

function GuestListSkeleton() {
  return (
    <div className="space-y-4">
      <div className="flex items-center justify-between">
        <div className="flex gap-2">
          <Skeleton className="h-10 w-64" />
          <Skeleton className="h-10 w-[180px]" />
        </div>
        <Skeleton className="h-10 w-[120px]" />
      </div>

      <div className="rounded-md border">
        <Table>
          <TableHeader>
            <TableRow>
              <TableHead>Guest</TableHead>
              <TableHead>Status</TableHead>
              <TableHead>Role</TableHead>
              <TableHead>Invited</TableHead>
              <TableHead>Check-in</TableHead>
              <TableHead></TableHead>
            </TableRow>
          </TableHeader>
          <TableBody>
            {[1, 2, 3, 4].map((index) => (
              <TableRow key={index}>
                <TableCell>
                  <div className="flex items-center space-x-3">
                    <Skeleton className="h-10 w-10 rounded-full" />
                    <div className="space-y-1">
                      <Skeleton className="h-4 w-[150px]" />
                      <Skeleton className="h-3 w-[120px]" />
                    </div>
                  </div>
                </TableCell>
                <TableCell>
                  <Skeleton className="h-6 w-[80px]" />
                </TableCell>
                <TableCell>
                  <Skeleton className="h-4 w-[60px]" />
                </TableCell>
                <TableCell>
                  <Skeleton className="h-4 w-[100px]" />
                </TableCell>
                <TableCell>
                  <Skeleton className="h-6 w-[120px]" />
                </TableCell>
                <TableCell>
                  <Skeleton className="h-8 w-8" />
                </TableCell>
              </TableRow>
            ))}
          </TableBody>
        </Table>
      </div>
    </div>
  );
}

================
File: src/components/events/share-event.tsx
================
"use client";

import { useState } from "react";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { 
  Facebook, 
  Twitter, 
  Linkedin, 
  Mail, 
  Link as LinkIcon,
  Check,
  Copy,
  Share2
} from "lucide-react";
import { useToast } from "@/hooks/use-toast";
import {
  Card,
  CardContent,
  CardDescription,
  CardFooter,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { Textarea } from "@/components/ui/textarea";
import { Separator } from "@/components/ui/separator";

interface ShareEventProps {
  event: {
    id: string;
    title: string;
    description: string;
    startDate: string;
    location: {
      venue: string;
      address: string;
    };
  };
}

export function ShareEvent({ event }: ShareEventProps) {
  const [copied, setCopied] = useState(false);
  const [inviteEmails, setInviteEmails] = useState("");
  const [inviteMessage, setInviteMessage] = useState("");
  const { toast } = useToast();
  const eventUrl = `${window.location.origin}/events/${event.id}`;

  const copyToClipboard = async () => {
    try {
      await navigator.clipboard.writeText(eventUrl);
      setCopied(true);
      toast({
        description: "Link copied to clipboard",
        duration: 2000,
      });
      setTimeout(() => setCopied(false), 2000);
    } catch (err) {
      console.error("Failed to copy text: ", err);
      toast({
        variant: "destructive",
        description: "Failed to copy link",
      });
    }
  };

  const shareViaEmail = () => {
    const subject = encodeURIComponent(event.title);
    const body = encodeURIComponent(
      `Check out this event: ${event.title}\n\n${event.description}\n\nDate: ${new Date(event.startDate).toLocaleDateString()}\nLocation: ${event.location.venue}, ${event.location.address}\n\nView event details: ${eventUrl}`
    );
    window.open(`mailto:?subject=${subject}&body=${body}`);
  };

  const shareToSocialMedia = (platform: 'twitter' | 'facebook' | 'linkedin') => {
    const text = encodeURIComponent(`Check out this event: ${event.title}`);
    const url = encodeURIComponent(eventUrl);
    
    const links = {
      twitter: `https://twitter.com/intent/tweet?text=${text}&url=${url}`,
      facebook: `https://www.facebook.com/sharer/sharer.php?u=${url}`,
      linkedin: `https://www.linkedin.com/sharing/share-offsite/?url=${url}`
    };

    window.open(links[platform], '_blank', 'width=600,height=400');
  };

  const sendInvites = async () => {
    const emails = inviteEmails.split(',').map(email => email.trim()).filter(Boolean);
    
    if (emails.length === 0) {
      toast({
        variant: "destructive",
        description: "Please enter at least one email address",
      });
      return;
    }

    try {
      const response = await fetch(`/api/events/${event.id}/invite`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          emails,
          message: inviteMessage,
        }),
      });

      if (!response.ok) throw new Error('Failed to send invites');

      toast({
        description: "Invitations sent successfully",
      });
      
      // Clear the form
      setInviteEmails("");
      setInviteMessage("");
    } catch (error) {
      console.error('Error sending invites:', error);
      toast({
        variant: "destructive",
        description: "Failed to send invitations",
      });
    }
  };

  return (
    <Tabs defaultValue="share" className="w-full">
      <TabsList className="grid w-full grid-cols-2">
        <TabsTrigger value="share">Share</TabsTrigger>
        <TabsTrigger value="invite">Invite</TabsTrigger>
      </TabsList>

      <TabsContent value="share" className="space-y-4">
        <Card>
          <CardHeader>
            <CardTitle>Share Link</CardTitle>
            <CardDescription>
              Copy the event link or share directly to social media
            </CardDescription>
          </CardHeader>
          <CardContent className="space-y-4">
            <div className="flex space-x-2">
              <Input
                value={eventUrl}
                readOnly
                className="flex-1"
              />
              <Button 
                variant="outline" 
                size="icon"
                onClick={copyToClipboard}
              >
                {copied ? (
                  <Check className="h-4 w-4 text-green-500" />
                ) : (
                  <Copy className="h-4 w-4" />
                )}
              </Button>
            </div>
            
            <Separator className="my-4" />
            
            <div className="flex justify-between">
              <Button
                variant="outline"
                size="lg"
                className="flex-1 mx-1"
                onClick={() => shareToSocialMedia('twitter')}
              >
                <Twitter className="h-5 w-5 mr-2" />
                Twitter
              </Button>
              <Button
                variant="outline"
                size="lg"
                className="flex-1 mx-1"
                onClick={() => shareToSocialMedia('facebook')}
              >
                <Facebook className="h-5 w-5 mr-2" />
                Facebook
              </Button>
              <Button
                variant="outline"
                size="lg"
                className="flex-1 mx-1"
                onClick={() => shareToSocialMedia('linkedin')}
              >
                <Linkedin className="h-5 w-5 mr-2" />
                LinkedIn
              </Button>
              <Button
                variant="outline"
                size="lg"
                className="flex-1 mx-1"
                onClick={shareViaEmail}
              >
                <Mail className="h-5 w-5 mr-2" />
                Email
              </Button>
            </div>
          </CardContent>
        </Card>
      </TabsContent>

      <TabsContent value="invite" className="space-y-4">
        <Card>
          <CardHeader>
            <CardTitle>Invite People</CardTitle>
            <CardDescription>
              Send email invitations to your guests
            </CardDescription>
          </CardHeader>
          <CardContent className="space-y-4">
            <div className="space-y-2">
              <label className="text-sm font-medium">
                Email Addresses
              </label>
              <Input
                placeholder="Enter email addresses (comma-separated)"
                value={inviteEmails}
                onChange={(e) => setInviteEmails(e.target.value)}
              />
              <p className="text-sm text-muted-foreground">
                Separate multiple email addresses with commas
              </p>
            </div>
            
            <div className="space-y-2">
              <label className="text-sm font-medium">
                Personal Message (Optional)
              </label>
              <Textarea
                placeholder="Add a personal message to your invitation"
                value={inviteMessage}
                onChange={(e) => setInviteMessage(e.target.value)}
                className="h-32"
              />
            </div>
          </CardContent>
          <CardFooter>
            <Button 
              className="w-full"
              onClick={sendInvites}
            >
              <Mail className="h-4 w-4 mr-2" />
              Send Invitations
            </Button>
          </CardFooter>
        </Card>
      </TabsContent>
    </Tabs>
  );
}

================
File: src/components/events/venue-map.tsx
================
"use client";

import { useEffect, useState } from "react";
import { GoogleMap, Marker, LoadScript } from "@react-google-maps/api";

interface VenueMapProps {
  address: string;
  venue: string;
  onLocationSelected?: (location: { lat: number; lng: number }) => void;
  initialLocation?: { lat: number; lng: number };
  isEditable?: boolean;
}

export function VenueMap({
  address,
  venue,
  onLocationSelected,
  initialLocation,
  isEditable = false,
}: VenueMapProps) {
  const [location, setLocation] = useState(initialLocation);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    if (!initialLocation && address) {
      geocodeAddress();
    }
  }, [address]);

  const geocodeAddress = async () => {
    try {
      const response = await fetch(
        `https://maps.googleapis.com/maps/api/geocode/json?address=${encodeURIComponent(
          address
        )}&key=${process.env.NEXT_PUBLIC_GOOGLE_MAPS_API_KEY}`
      );
      const data = await response.json();
      if (data.results[0]) {
        const { lat, lng } = data.results[0].geometry.location;
        setLocation({ lat, lng });
        if (onLocationSelected) {
          onLocationSelected({ lat, lng });
        }
      }
    } catch (error) {
      console.error("Error geocoding address:", error);
    } finally {
      setLoading(false);
    }
  };

  const handleMapClick = (e: google.maps.MapMouseEvent) => {
    if (isEditable && onLocationSelected) {
      const lat = e.latLng?.lat();
      const lng = e.latLng?.lng();
      if (lat && lng) {
        setLocation({ lat, lng });
        onLocationSelected({ lat, lng });
      }
    }
  };

  if (loading || !location) return <div>Loading map...</div>;

  return (
    <LoadScript googleMapsApiKey={process.env.NEXT_PUBLIC_GOOGLE_MAPS_API_KEY!}>
      <GoogleMap
        mapContainerStyle={{ width: "100%", height: "400px" }}
        center={location}
        zoom={15}
        onClick={handleMapClick}
      >
        <Marker
          position={location}
          title={venue}
          draggable={isEditable}
          onDragEnd={(e) => {
            if (onLocationSelected && e.latLng) {
              const newLoc = {
                lat: e.latLng.lat(),
                lng: e.latLng.lng(),
              };
              setLocation(newLoc);
              onLocationSelected(newLoc);
            }
          }}
        />
      </GoogleMap>
    </LoadScript>
  );
}

================
File: src/components/export/export-button.tsx
================
"use client";

import { useState } from "react";
import { Button } from "@/components/ui/button";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import { Download, FileSpreadsheet, Files } from "lucide-react";
import { exportToExcel, exportToCSV } from "@/lib/export";

interface ExportButtonProps {
  data: any[];
  filename: string;
  type: "guests" | "events" | "analytics";
}

export function ExportButton({ data, filename, type }: ExportButtonProps) {
  const [loading, setLoading] = useState(false);

  const handleExport = async (format: "excel" | "csv") => {
    setLoading(true);
    try {
      if (format === "excel") {
        const columns = getColumnsForType(type);
        await exportToExcel(data, filename, [{ name: "Data", columns }]);
      } else {
        exportToCSV(data, filename);
      }
    } catch (error) {
      console.error("Export failed:", error);
    } finally {
      setLoading(false);
    }
  };

  const getColumnsForType = (type: string) => {
    const columnMappings = {
      guests: [
        { header: "Name", key: "name", width: 20 },
        { header: "Email", key: "email", width: 30 },
        { header: "Status", key: "status", width: 15 },
        { header: "Role", key: "role", width: 15 },
        { header: "Invited At", key: "invitedAt", width: 20 },
        { header: "Checked In", key: "checkedIn", width: 15 },
      ],
      events: [
        { header: "Title", key: "title", width: 30 },
        { header: "Date", key: "startDate", width: 20 },
        { header: "Location", key: "location.venue", width: 25 },
        { header: "Status", key: "status", width: 15 },
        { header: "Capacity", key: "capacity", width: 15 },
      ],
      analytics: [
        { header: "Metric", key: "metric", width: 25 },
        { header: "Value", key: "value", width: 20 },
        { header: "Date", key: "date", width: 20 },
      ],
    };

    return columnMappings[type as keyof typeof columnMappings] || [];
  };

  return (
    <DropdownMenu>
      <DropdownMenuTrigger asChild>
        <Button variant="outline" disabled={loading}>
          <Download className="mr-2 h-4 w-4" />
          Export
        </Button>
      </DropdownMenuTrigger>
      <DropdownMenuContent align="end">
        <DropdownMenuLabel>Choose Format</DropdownMenuLabel>
        <DropdownMenuSeparator />
        <DropdownMenuItem onClick={() => handleExport("excel")}>
          <FileSpreadsheet className="mr-2 h-4 w-4" />
          Export to Excel
        </DropdownMenuItem>
        <DropdownMenuItem onClick={() => handleExport("csv")}>
          <Files className="mr-2 h-4 w-4" />
          Export to CSV
        </DropdownMenuItem>
      </DropdownMenuContent>
    </DropdownMenu>
  );
}

================
File: src/components/filters/advanced-filter.tsx
================
"use client";

import { useState } from "react";
import { Button } from "@/components/ui/button";
import {
  Sheet,
  SheetContent,
  SheetDescription,
  SheetHeader,
  SheetTitle,
  SheetTrigger,
} from "@/components/ui/sheet";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Switch } from "@/components/ui/switch";
import { DatePicker } from "@/components/ui/date-picker";
import { Filter, SortAsc, SortDesc } from "lucide-react";

interface FilterConfig {
  field: string;
  operator: string;
  value: any;
}

interface SortConfig {
  field: string;
  direction: "asc" | "desc";
}

interface AdvancedFilterProps {
  onFilterChange: (filters: FilterConfig[]) => void;
  onSortChange: (sort: SortConfig[]) => void;
  fields: {
    name: string;
    type: "text" | "number" | "date" | "boolean" | "select";
    options?: string[];
  }[];
}

export function AdvancedFilter({
  onFilterChange,
  onSortChange,
  fields,
}: AdvancedFilterProps) {
  const [filters, setFilters] = useState<FilterConfig[]>([]);
  const [sorts, setSorts] = useState<SortConfig[]>([]);

  const addFilter = () => {
    const newFilter = {
      field: fields[0].name,
      operator: "equals",
      value: "",
    };
    setFilters([...filters, newFilter]);
  };

  const updateFilter = (index: number, updates: Partial<FilterConfig>) => {
    const newFilters = filters.map((filter, i) =>
      i === index ? { ...filter, ...updates } : filter
    );
    setFilters(newFilters);
    onFilterChange(newFilters);
  };

  const removeFilter = (index: number) => {
    const newFilters = filters.filter((_, i) => i !== index);
    setFilters(newFilters);
    onFilterChange(newFilters);
  };

  const addSort = () => {
    const newSort = {
      field: fields[0].name,
      direction: "asc" as const,
    };
    setSorts([...sorts, newSort]);
  };

  const updateSort = (index: number, updates: Partial<SortConfig>) => {
    const newSorts = sorts.map((sort, i) =>
      i === index ? { ...sort, ...updates } : sort
    );
    setSorts(newSorts);
    onSortChange(newSorts);
  };

  const removeSort = (index: number) => {
    const newSorts = sorts.filter((_, i) => i !== index);
    setSorts(newSorts);
    onSortChange(newSorts);
  };

  return (
    <Sheet>
      <SheetTrigger asChild>
        <Button variant="outline">
          <Filter className="mr-2 h-4 w-4" />
          Advanced Filters
        </Button>
      </SheetTrigger>
      <SheetContent className="w-[400px]">
        <SheetHeader>
          <SheetTitle>Advanced Filters</SheetTitle>
          <SheetDescription>
            Configure filters and sorting options
          </SheetDescription>
        </SheetHeader>

        <div className="py-4 space-y-4">
          <div className="space-y-4">
            <div className="flex items-center justify-between">
              <h3 className="font-medium">Filters</h3>
              <Button onClick={addFilter} variant="outline" size="sm">
                Add Filter
              </Button>
            </div>
            {filters.map((filter, index) => (
              <div key={index} className="space-y-2 p-2 border rounded-md">
                <Select
                  value={filter.field}
                  onValueChange={(value) =>
                    updateFilter(index, { field: value })
                  }
                >
                  <SelectTrigger>
                    <SelectValue placeholder="Select field" />
                  </SelectTrigger>
                  <SelectContent>
                    {fields.map((field) => (
                      <SelectItem key={field.name} value={field.name}>
                        {field.name}
                      </SelectItem>
                    ))}
                  </SelectContent>
                </Select>

                <Select
                  value={filter.operator}
                  onValueChange={(value) =>
                    updateFilter(index, { operator: value })
                  }
                >
                  <SelectTrigger>
                    <SelectValue placeholder="Select operator" />
                  </SelectTrigger>
                  <SelectContent>
                    <SelectItem value="equals">Equals</SelectItem>
                    <SelectItem value="contains">Contains</SelectItem>
                    <SelectItem value="greaterThan">Greater Than</SelectItem>
                    <SelectItem value="lessThan">Less Than</SelectItem>
                  </SelectContent>
                </Select>

                <Input
                  placeholder="Value"
                  value={filter.value}
                  onChange={(e) =>
                    updateFilter(index, { value: e.target.value })
                  }
                />

                <Button
                  variant="destructive"
                  size="sm"
                  onClick={() => removeFilter(index)}
                >
                  Remove
                </Button>
              </div>
            ))}
          </div>

          <div className="space-y-4">
            <div className="flex items-center justify-between">
              <h3 className="font-medium">Sorting</h3>
              <Button onClick={addSort} variant="outline" size="sm">
                Add Sort
              </Button>
            </div>
            {sorts.map((sort, index) => (
              <div key={index} className="space-y-2 p-2 border rounded-md">
                <Select
                  value={sort.field}
                  onValueChange={(value) =>
                    updateSort(index, { field: value })
                  }
                >
                  <SelectTrigger>
                    <SelectValue placeholder="Select field" />
                  </SelectTrigger>
                  <SelectContent>
                    {fields.map((field) => (
                      <SelectItem key={field.name} value={field.name}>
                        {field.name}
                      </SelectItem>
                    ))}
                  </SelectContent>
                </Select>

                <div className="flex items-center space-x-2">
                  <Button
                    variant="outline"
                    size="sm"
                    onClick={() =>
                      updateSort(index, {
                        direction: sort.direction === "asc" ? "desc" : "asc",
                      })
                    }
                  >
                    {sort.direction === "asc" ? (
                      <SortAsc className="h-4 w-4" />
                    ) : (
                      <SortDesc className="h-4 w-4" />
                    )}
                  </Button>
                  <Button
                    variant="destructive"
                    size="sm"
                    onClick={() => removeSort(index)}
                  >
                    Remove
                  </Button>
                </div>
              </div>
            ))}
          </div>
        </div>

        <div className="mt-4">
          <Button
            className="w-full"
            onClick={() => {
              onFilterChange(filters);
              onSortChange(sorts);
            }}
          >
            Apply Filters & Sorting
          </Button>
        </div>
      </SheetContent>
    </Sheet>
  );
}

================
File: src/components/layout/event-card.tsx
================
import {
    Card,
    CardContent,
    CardDescription,
    CardFooter,
    CardHeader,
    CardTitle,
  } from "@/components/ui/card";
  import { Badge } from "@/components/ui/badge";
  import { Button } from "@/components/ui/button";
  import { Calendar, Clock, MapPin, Users } from "lucide-react";
  import { format } from "date-fns";
  
  interface EventCardProps {
    event: {
      title: string;
      description: string;
      startDate: Date;
      endDate: Date;
      location: {
        venue: string;
      };
      capacity: number;
      status: string;
    };
  }
  
  export function EventCard({ event }: EventCardProps) {
    return (
      <Card>
        <CardHeader>
          <div className="flex items-center justify-between">
            <CardTitle className="line-clamp-1">{event.title}</CardTitle>
            <Badge variant={event.status === "published" ? "default" : "secondary"}>
              {event.status}
            </Badge>
          </div>
          <CardDescription className="line-clamp-2">
            {event.description}
          </CardDescription>
        </CardHeader>
        <CardContent className="space-y-2">
          <div className="flex items-center space-x-2 text-sm">
            <Calendar className="h-4 w-4" />
            <span>{format(new Date(event.startDate), "PPP")}</span>
          </div>
          <div className="flex items-center space-x-2 text-sm">
            <Clock className="h-4 w-4" />
            <span>{format(new Date(event.startDate), "p")}</span>
          </div>
          <div className="flex items-center space-x-2 text-sm">
            <MapPin className="h-4 w-4" />
            <span>{event.location.venue}</span>
          </div>
          <div className="flex items-center space-x-2 text-sm">
            <Users className="h-4 w-4" />
            <span>{event.capacity} attendees</span>
          </div>
        </CardContent>
        <CardFooter className="flex justify-between">
          <Button variant="outline">Edit</Button>
          <Button>View Details</Button>
        </CardFooter>
      </Card>
    );
  }

================
File: src/components/layout/main-nav.tsx
================
"use client";

import Link from "next/link";
import { usePathname } from "next/navigation";
import { cn } from "@/lib/utils";

export function MainNav() {
  const pathname = usePathname();

  const routes = [
    {
      href: "/dashboard",
      label: "Dashboard",
      active: pathname === "/dashboard",
    },
    {
      href: "/events",
      label: "Events",
      active: pathname === "/events",
    },
    {
      href: "/calendar",
      label: "Calendar",
      active: pathname === "/calendar",
    },
  ];

  return (
    <nav className="flex items-center space-x-4 lg:space-x-6">
      {routes.map((route) => (
        <Link
          key={route.href}
          href={route.href}
          className={cn(
            "text-sm font-medium transition-colors hover:text-primary",
            route.active ? "text-primary" : "text-muted-foreground"
          )}
        >
          {route.label}
        </Link>
      ))}
    </nav>
  );
}

================
File: src/components/layout/navbar.tsx
================
import { UserButton } from "@clerk/nextjs";
import { ModeToggle } from "../../components/mode-toggle";
import { MainNav } from "../../components/layout/main-nav";
import { Button } from "@/components/ui/button";
import Link from "next/link";
import { Plus } from "lucide-react";

export function Navbar() {
  return (
    <div className="border-b">
      <div className="flex h-16 items-center px-4">
        <div className="flex items-center space-x-4">
          <Link href="/" className="font-bold">
            Feest
          </Link>
          <MainNav />
        </div>
        <div className="ml-auto flex items-center space-x-4">
          <Button asChild variant="outline" size="sm">
            <Link href="/events/new">
              <Plus className="mr-2 h-4 w-4" />
              Create Event
            </Link>
          </Button>
          <ModeToggle />
          <UserButton />
        </div>
      </div>
    </div>
  );
}

================
File: src/components/providers/theme-provider.tsx
================
"use client"

import * as React from "react"
import { ThemeProvider as NextThemesProvider } from "next-themes"
import { type ThemeProviderProps } from "next-themes/dist/types"

export function ThemeProvider({ children, ...props }: ThemeProviderProps) {
  return <NextThemesProvider {...props}>{children}</NextThemesProvider>
}


================
File: src/components/mode-toggle.tsx
================
"use client"

import { Moon, Sun } from "lucide-react"
import { useTheme } from "next-themes"

import { Button } from "@/components/ui/button"
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu"

export function ModeToggle() {
  const { setTheme } = useTheme()

  return (
    <DropdownMenu>
      <DropdownMenuTrigger asChild>
        <Button variant="outline" size="icon">
          <Sun className="h-[1.2rem] w-[1.2rem] rotate-0 scale-100 transition-all dark:-rotate-90 dark:scale-0" />
          <Moon className="absolute h-[1.2rem] w-[1.2rem] rotate-90 scale-0 transition-all dark:rotate-0 dark:scale-100" />
          <span className="sr-only">Toggle theme</span>
        </Button>
      </DropdownMenuTrigger>
      <DropdownMenuContent align="end">
        <DropdownMenuItem onClick={() => setTheme("light")}>
          Light
        </DropdownMenuItem>
        <DropdownMenuItem onClick={() => setTheme("dark")}>
          Dark
        </DropdownMenuItem>
        <DropdownMenuItem onClick={() => setTheme("system")}>
          System
        </DropdownMenuItem>
      </DropdownMenuContent>
    </DropdownMenu>
  )
}

================
File: src/emails/event-invitation.tsx
================
// src/emails/event-invitation.tsx
import {
  Body,
  Button,
  Container,
  Head,
  Heading,
  Hr,
  Html,
  Preview,
  Section,
  Text,
} from "@react-email/components";
import * as React from "react";

interface EventInvitationProps {
  eventTitle: string;
  eventDate: string;
  eventTime: string;
  location: string;
  eventUrl: string;
  personalMessage?: string;
}

const EventInvitationEmail: React.FC<EventInvitationProps> = ({
  eventTitle,
  eventDate,
  eventTime,
  location,
  eventUrl,
  personalMessage,
}) => {
  const previewText = `You're invited to ${eventTitle}!`;

  return (
    <Html>
      <Head />
      <Preview>{previewText}</Preview>
      <Body style={main}>
        <Container style={container}>
          <Heading style={h1}>{eventTitle}</Heading>
          
          <Section style={section}>
            <Text style={text}>You've been invited to join this event!</Text>
            
            {personalMessage && (
              <>
                <Text style={messageBox}>{personalMessage}</Text>
                <Hr style={hr} />
              </>
            )}
            
            <Text style={detailsTitle}>Event Details:</Text>
            <Text style={details}>
               Date: {eventDate}<br />
               Time: {eventTime}<br />
               Location: {location}
            </Text>

            <Button
              href={eventUrl}
              style={button}
            >
              View Event Details
            </Button>
          </Section>
        </Container>
      </Body>
    </Html>
  );
};

// Styles
const main = {
  backgroundColor: "#f6f9fc",
  fontFamily: '-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Ubuntu,sans-serif',
};

const container = {
  backgroundColor: "#ffffff",
  margin: "0 auto",
  padding: "20px 0 48px",
  marginBottom: "64px",
};

const section = {
  padding: "0 48px",
};

const h1 = {
  color: "#333",
  fontSize: "24px",
  fontWeight: "bold",
  margin: "40px 0",
  padding: "0",
  textAlign: "center" as const,
};

const text = {
  color: "#333",
  fontSize: "16px",
  margin: "24px 0",
};

const messageBox = {
  backgroundColor: "#f9f9f9",
  border: "1px solid #ddd",
  borderRadius: "5px",
  color: "#555",
  fontSize: "16px",
  margin: "24px 0",
  padding: "16px",
};

const detailsTitle = {
  color: "#333",
  fontSize: "18px",
  fontWeight: "bold",
  margin: "24px 0 8px",
};

const details = {
  color: "#555",
  fontSize: "16px",
  lineHeight: "24px",
  margin: "0 0 24px",
};

const button = {
  backgroundColor: "#000",
  borderRadius: "5px",
  color: "#fff",
  display: "block",
  fontSize: "16px",
  fontWeight: "bold",
  textAlign: "center" as const,
  textDecoration: "none",
  padding: "12px 20px",
  margin: "32px auto",
};

const hr = {
  borderColor: "#e6ebf1",
  margin: "20px 0",
};

export default EventInvitationEmail;

================
File: src/hooks/use-toast.ts
================
"use client"

// Inspired by react-hot-toast library
import * as React from "react"

import type {
  ToastActionElement,
  ToastProps,
} from "@/components/ui/toast"

const TOAST_LIMIT = 1
const TOAST_REMOVE_DELAY = 1000000

type ToasterToast = ToastProps & {
  id: string
  title?: React.ReactNode
  description?: React.ReactNode
  action?: ToastActionElement
}

const actionTypes = {
  ADD_TOAST: "ADD_TOAST",
  UPDATE_TOAST: "UPDATE_TOAST",
  DISMISS_TOAST: "DISMISS_TOAST",
  REMOVE_TOAST: "REMOVE_TOAST",
} as const

let count = 0

function genId() {
  count = (count + 1) % Number.MAX_SAFE_INTEGER
  return count.toString()
}

type ActionType = typeof actionTypes

type Action =
  | {
      type: ActionType["ADD_TOAST"]
      toast: ToasterToast
    }
  | {
      type: ActionType["UPDATE_TOAST"]
      toast: Partial<ToasterToast>
    }
  | {
      type: ActionType["DISMISS_TOAST"]
      toastId?: ToasterToast["id"]
    }
  | {
      type: ActionType["REMOVE_TOAST"]
      toastId?: ToasterToast["id"]
    }

interface State {
  toasts: ToasterToast[]
}

const toastTimeouts = new Map<string, ReturnType<typeof setTimeout>>()

const addToRemoveQueue = (toastId: string) => {
  if (toastTimeouts.has(toastId)) {
    return
  }

  const timeout = setTimeout(() => {
    toastTimeouts.delete(toastId)
    dispatch({
      type: "REMOVE_TOAST",
      toastId: toastId,
    })
  }, TOAST_REMOVE_DELAY)

  toastTimeouts.set(toastId, timeout)
}

export const reducer = (state: State, action: Action): State => {
  switch (action.type) {
    case "ADD_TOAST":
      return {
        ...state,
        toasts: [action.toast, ...state.toasts].slice(0, TOAST_LIMIT),
      }

    case "UPDATE_TOAST":
      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === action.toast.id ? { ...t, ...action.toast } : t
        ),
      }

    case "DISMISS_TOAST": {
      const { toastId } = action

      // ! Side effects ! - This could be extracted into a dismissToast() action,
      // but I'll keep it here for simplicity
      if (toastId) {
        addToRemoveQueue(toastId)
      } else {
        state.toasts.forEach((toast) => {
          addToRemoveQueue(toast.id)
        })
      }

      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === toastId || toastId === undefined
            ? {
                ...t,
                open: false,
              }
            : t
        ),
      }
    }
    case "REMOVE_TOAST":
      if (action.toastId === undefined) {
        return {
          ...state,
          toasts: [],
        }
      }
      return {
        ...state,
        toasts: state.toasts.filter((t) => t.id !== action.toastId),
      }
  }
}

const listeners: Array<(state: State) => void> = []

let memoryState: State = { toasts: [] }

function dispatch(action: Action) {
  memoryState = reducer(memoryState, action)
  listeners.forEach((listener) => {
    listener(memoryState)
  })
}

type Toast = Omit<ToasterToast, "id">

function toast({ ...props }: Toast) {
  const id = genId()

  const update = (props: ToasterToast) =>
    dispatch({
      type: "UPDATE_TOAST",
      toast: { ...props, id },
    })
  const dismiss = () => dispatch({ type: "DISMISS_TOAST", toastId: id })

  dispatch({
    type: "ADD_TOAST",
    toast: {
      ...props,
      id,
      open: true,
      onOpenChange: (open) => {
        if (!open) dismiss()
      },
    },
  })

  return {
    id: id,
    dismiss,
    update,
  }
}

function useToast() {
  const [state, setState] = React.useState<State>(memoryState)

  React.useEffect(() => {
    listeners.push(setState)
    return () => {
      const index = listeners.indexOf(setState)
      if (index > -1) {
        listeners.splice(index, 1)
      }
    }
  }, [state])

  return {
    ...state,
    toast,
    dismiss: (toastId?: string) => dispatch({ type: "DISMISS_TOAST", toastId }),
  }
}

export { useToast, toast }

================
File: src/lib/activity/notifications.ts
================
import mongoose from 'mongoose';
import { pusherServer } from "@/lib/pusher";

// Define specific activity types as constants
export const ActivityTypes = {
  // Event activities
  EVENT_CREATED: 'event.created',
  EVENT_UPDATED: 'event.updated',
  EVENT_CANCELLED: 'event.cancelled',
  
  // Guest activities
  GUEST_INVITED: 'guest.invited',
  GUEST_UPDATED: 'guest.updated',
  GUEST_REGISTERED: 'guest.registered',
  GUEST_CANCELLED: 'guest.cancelled',
  GUEST_CHECKED_IN: 'guest.checked_in',
  GUEST_REMOVED: 'guest.removed',
  
  // Communication activities
  COMMENT_ADDED: 'comment.added',
  MESSAGE_SENT: 'message.sent',
} as const;

// Create type from constants
export type ActivityType = typeof ActivityTypes[keyof typeof ActivityTypes];

// Activity interface
export interface Activity {
  type: ActivityType;
  userId: string;
  eventId: string;
  metadata?: Record<string, any>;
  createdAt: Date;
}

// Create Mongoose Schema for activities
const activitySchema = new mongoose.Schema({
  type: {
    type: String,
    required: true,
    enum: Object.values(ActivityTypes)
  },
  userId: {
    type: String,
    required: true,
  },
  eventId: {
    type: String,
    required: true,
  },
  metadata: {
    type: Map,
    of: mongoose.Schema.Types.Mixed,
    default: {},
  },
  createdAt: {
    type: Date,
    default: Date.now,
  },
}, {
  timestamps: true,
});

// Create the model
const Activity = mongoose.models.Activity || mongoose.model('Activity', activitySchema);

export async function createActivity({
  type,
  userId,
  eventId,
  metadata = {}
}: Omit<Activity, 'createdAt'>) {
  try {
    // Create activity in database
    const activity = await Activity.create({
      type,
      userId,
      eventId,
      metadata,
    });

    // Trigger real-time update via Pusher
    await pusherServer.trigger(
      `event-${eventId}`,
      'new-activity',
      {
        type,
        userId,
        metadata,
        createdAt: activity.createdAt,
      }
    );

    // Also trigger user-specific activity
    await pusherServer.trigger(
      `user-${userId}`,
      'new-activity',
      {
        type,
        eventId,
        metadata,
        createdAt: activity.createdAt,
      }
    );

    return activity;
  } catch (error) {
    console.error('Error creating activity:', error);
    throw error;
  }
}

// Helper function to format activity messages
export function formatActivityMessage(activity: Activity): string {
  const messages: Record<ActivityType, string> = {
    [ActivityTypes.EVENT_CREATED]: "created a new event",
    [ActivityTypes.EVENT_UPDATED]: "updated event details",
    [ActivityTypes.EVENT_CANCELLED]: "cancelled the event",
    [ActivityTypes.GUEST_INVITED]: "invited a new guest",
    [ActivityTypes.GUEST_UPDATED]: "updated guest details",
    [ActivityTypes.GUEST_REGISTERED]: "registered for the event",
    [ActivityTypes.GUEST_CANCELLED]: "cancelled their registration",
    [ActivityTypes.GUEST_CHECKED_IN]: "checked in to the event",
    [ActivityTypes.GUEST_REMOVED]: "removed a guest",
    [ActivityTypes.COMMENT_ADDED]: "added a comment",
    [ActivityTypes.MESSAGE_SENT]: "sent a message",
  };

  return messages[activity.type] || "performed an action";
}

// Export activity types for use in other files
export { Activity as ActivityModel };

================
File: src/lib/db/models/activity.ts
================
// src/lib/db/models/activity.ts
import mongoose, { Schema, Document, Types } from "mongoose";

export interface IActivity extends Document {
  type: string;
  userId: string;
  eventId: string;
  metadata?: Record<string, any>;
  createdAt: Date;
  updatedAt: Date;
}

const ActivitySchema = new Schema({
  type: {
    type: String,
    required: true,
    enum: [
      'event.created',
      'event.updated',
      'event.cancelled',
      'event.deleted',
      'guest.invited',
      'guest.confirmed',
      'guest.declined',
      'guest.checked_in',
      'guest.removed',
      'message.sent',
      'cohost.added',
      'cohost.removed',
      'settings.updated',
      'export.generated'
    ]
  },
  userId: {
    type: String,
    required: true,
    index: true
  },
  eventId: {
    type: String,
    required: true,
    index: true
  },
  metadata: {
    type: Schema.Types.Mixed,
    default: {}
  }
}, {
  timestamps: true,
  toJSON: {
    virtuals: true,
    transform: function(doc, ret) {
      ret.id = ret._id;
      delete ret._id;
      delete ret.__v;
      return ret;
    }
  }
});

// Compound indexes for efficient querying
ActivitySchema.index({ eventId: 1, createdAt: -1 });
ActivitySchema.index({ userId: 1, createdAt: -1 });
ActivitySchema.index({ type: 1, eventId: 1 });

// Add text index for search functionality
ActivitySchema.index({
  'metadata.guestName': 'text',
  'metadata.changes': 'text'
});

// Middleware to validate metadata based on activity type
ActivitySchema.pre('save', function(next) {
  const activity = this as IActivity;
  
  // Validate metadata based on activity type
  switch (activity.type) {
    case 'event.updated':
      if (!activity.metadata?.changes) {
        return next(new Error('Event update activity requires changes in metadata'));
      }
      break;
      
    case 'guest.invited':
    case 'guest.confirmed':
    case 'guest.declined':
    case 'guest.checked_in':
    case 'guest.removed':
      if (!activity.metadata?.guestId) {
        return next(new Error('Guest-related activity requires guestId in metadata'));
      }
      break;
      
    case 'message.sent':
      if (!activity.metadata?.messageId) {
        return next(new Error('Message activity requires messageId in metadata'));
      }
      break;
  }
  
  next();
});

// Static methods
ActivitySchema.statics = {
  /**
   * Get recent activities for an event
   */
  async getRecentEventActivities(eventId: string, limit = 20) {
    return this.find({ eventId })
      .sort({ createdAt: -1 })
      .limit(limit)
      .exec();
  },

  /**
   * Get recent activities for a user
   */
  async getUserActivities(userId: string, limit = 20) {
    return this.find({ userId })
      .sort({ createdAt: -1 })
      .limit(limit)
      .exec();
  },

  /**
   * Get activities by type
   */
  async getActivitiesByType(type: string, eventId?: string) {
    const query = eventId ? { type, eventId } : { type };
    return this.find(query)
      .sort({ createdAt: -1 })
      .exec();
  },

  /**
   * Search activities
   */
  async searchActivities(searchTerm: string, eventId?: string) {
    const query = eventId 
      ? { eventId, $text: { $search: searchTerm } }
      : { $text: { $search: searchTerm } };
      
    return this.find(query)
      .sort({ score: { $meta: "textScore" } })
      .exec();
  }
};

// Instance methods
ActivitySchema.methods = {
  /**
   * Format activity message
   */
  formatMessage() {
    const messages: Record<string, string> = {
      'event.created': 'created a new event',
      'event.updated': 'updated event details',
      'event.cancelled': 'cancelled the event',
      'event.deleted': 'deleted the event',
      'guest.invited': 'invited a new guest',
      'guest.confirmed': 'confirmed attendance',
      'guest.declined': 'declined attendance',
      'guest.checked_in': 'checked in to the event',
      'guest.removed': 'removed a guest',
      'message.sent': 'sent a message',
      'cohost.added': 'added a co-host',
      'cohost.removed': 'removed a co-host',
      'settings.updated': 'updated event settings',
      'export.generated': 'generated an export'
    };

    return messages[this.type] || 'performed an action';
  }
};

// Create model
const Activity = mongoose.models.Activity || mongoose.model<IActivity>('Activity', ActivitySchema);

export { Activity };

================
File: src/lib/db/models/event.ts
================
// src/lib/db/models/event.ts
import mongoose, { Schema, Document } from "mongoose";

export interface IEvent extends Document {
  title: string;
  description: string;
  startDate: Date;
  endDate: Date;
  location: {
    venue: string;
    address: string;
    coordinates?: {
      lat: number;
      lng: number;
    };
  };
  capacity: number;
  status: "draft" | "published" | "cancelled";
  visibility: "public" | "private";
  organizerId: string;
  coHosts: string[];
  recurring?: {
    pattern: "daily" | "weekly" | "monthly";
    interval: number;
    endDate: Date;
  };
}

const EventSchema = new Schema({
  title: { type: String, required: true },
  description: { type: String, required: true },
  startDate: { type: Date, required: true },
  endDate: { type: Date, required: true },
  location: {
    venue: { type: String, required: true },
    address: { type: String, required: true },
    coordinates: {
      lat: Number,
      lng: Number
    }
  },
  capacity: { type: Number, required: true },
  status: {
    type: String,
    enum: ["draft", "published", "cancelled"],
    default: "draft"
  },
  visibility: {
    type: String,
    enum: ["public", "private"],
    default: "private"
  },
  organizerId: { type: String, required: true },
  coHosts: [{ type: String }],
  recurring: {
    pattern: {
      type: String,
      enum: ["daily", "weekly", "monthly"]
    },
    interval: Number,
    endDate: Date
  }
}, {
  timestamps: true,
  toJSON: {
    virtuals: true,
    transform: function(doc, ret) {
      ret.id = ret._id.toString();
      delete ret._id;
      delete ret.__v;
      return ret;
    }
  }
});

const Event = mongoose.models.Event || mongoose.model<IEvent>("Event", EventSchema);

export { Event };

================
File: src/lib/db/models/guest.ts
================
import mongoose from 'mongoose';

const guestSchema = new mongoose.Schema({
  eventId: { 
    type: String, 
    required: true 
  },
  userId: { 
    type: String, 
    required: true 
  },
  name: { 
    type: String, 
    required: true 
  },
  email: { 
    type: String, 
    required: true 
  },
  status: { 
    type: String, 
    enum: ['invited', 'confirmed', 'declined', 'waitlist'],
    default: 'invited' 
  },
  role: {
    type: String,
    enum: ['attendee', 'coHost', 'moderator'],
    default: 'attendee'
  },
  dietaryPreferences: [String],
  plusOne: {
    name: String,
    dietaryPreferences: [String]
  },
  checkedIn: {
    type: Boolean,
    default: false
  },
  checkedInAt: Date,
  invitedBy: String,
  invitedAt: {
    type: Date,
    default: Date.now
  },
  responseDate: Date,
  notes: String
}, {
  timestamps: true
});

// Add compound index to prevent duplicate registrations
guestSchema.index({ eventId: 1, userId: 1 }, { unique: true });

export const Guest = mongoose.models.Guest || mongoose.model('Guest', guestSchema);

================
File: src/lib/db/models/message.ts
================
import mongoose from 'mongoose';

const messageSchema = new mongoose.Schema({
  eventId: {
    type: String,
    required: true
  },
  senderId: {
    type: String,
    required: true
  },
  senderName: {
    type: String,
    required: true
  },
  senderAvatar: String,
  content: {
    type: String,
    required: true
  },
  type: {
    type: String,
    enum: ['text', 'announcement', 'system'],
    default: 'text'
  },
  replyTo: {
    messageId: String,
    content: String
  },
  attachments: [{
    name: String,
    url: String,
    type: String
  }],
  readBy: [{
    userId: String,
    readAt: Date
  }]
}, {
  timestamps: true
});

messageSchema.index({ eventId: 1, createdAt: -1 });

export const Message = mongoose.models.Message || mongoose.model('Message', messageSchema);

================
File: src/lib/db/connection.ts
================
import mongoose from 'mongoose';

const MONGODB_URI = process.env.DATABASE_URL as string;

if (!MONGODB_URI) {
  throw new Error('Please define the DATABASE_URL environment variable inside .env');
}

interface MongooseCache {
  conn: typeof mongoose | null;
  promise: Promise<typeof mongoose> | null;
}

// Declare the type for the global mongoose property
declare global {
  var mongoose: MongooseCache | undefined;
}

let cached = global.mongoose || { conn: null, promise: null };

if (!global.mongoose) {
  global.mongoose = cached;
}

async function dbConnect() {
  if (cached.conn) {
    return cached.conn;
  }

  if (!cached.promise) {
    const opts = {
      bufferCommands: false,
    };

    cached.promise = mongoose.connect(MONGODB_URI, opts).then((mongoose) => {
      return mongoose;
    });
  }

  try {
    cached.conn = await cached.promise;
  } catch (e) {
    cached.promise = null;
    throw e;
  }

  return cached.conn;
}

export default dbConnect;

================
File: src/lib/email/notifications.ts
================
// src/lib/email/notifications.ts
import { Resend } from 'resend';
import EventInvitation  from '@/emails/event-invitation';
import { render } from '@react-email/render';
import React from 'react';

const resend = new Resend(process.env.RESEND_API_KEY);

export interface InvitationParams {
    recipientEmail: string;
    eventTitle: string;
    eventDate: string;
    eventTime: string;
    location: string;
    eventUrl: string;
    personalMessage?: string;
}

export async function sendEventInvitation({
    recipientEmail,
    eventTitle,
    eventDate,
    eventTime,
    location,
    eventUrl,
    personalMessage,
  }: InvitationParams) {
    try {
      // Create the email component
      const emailComponent = React.createElement(EventInvitation, {
        eventTitle,
        eventDate,
        eventTime,
        location,
        eventUrl,
        personalMessage,
      });
  
      // Render the email
      const emailHtml = render(emailComponent);
  
      const { data, error } = await resend.emails.send({
        from: 'Event Platform <events@yourdomain.com>',
        to: recipientEmail,
        subject: `You're invited to ${eventTitle}!`,
        html: (await emailHtml).toString(),
      });
  
      if (error) {
        console.error('Error sending invitation email:', error);
        throw new Error('Failed to send invitation email');
      }
  
      return data;
    } catch (error) {
      console.error('Error in sendEventInvitation:', error);
      throw error;
    }
  }

// Utility function to format date and time
export function formatDateTime(date: Date) {
  const formattedDate = date.toLocaleDateString('en-US', {
    weekday: 'long',
    year: 'numeric',
    month: 'long',
    day: 'numeric',
  });

  const formattedTime = date.toLocaleTimeString('en-US', {
    hour: 'numeric',
    minute: '2-digit',
    hour12: true,
  });

  return { formattedDate, formattedTime };
}

// Updated interfaces for other email functions
interface ReminderParams {
  recipientEmail: string;
  eventId: string;
  eventTitle: string;
  startDate: Date;
  location: string;
}

interface UpdateParams {
  recipientEmail: string;
  eventId: string;
  eventTitle: string;
  changes: string[];
}

export async function sendEventReminder({
  recipientEmail,
  eventId,
  eventTitle,
  startDate,
  location,
}: ReminderParams) {
  const { formattedDate, formattedTime } = formatDateTime(startDate);
  const eventUrl = `${process.env.NEXT_PUBLIC_APP_URL}/events/${eventId}`;

  try {
    const emailHtml = `
      <h1>Reminder: ${eventTitle} is coming up!</h1>
      <p>This is a reminder that you have an upcoming event:</p>
      <ul>
        <li>Event: ${eventTitle}</li>
        <li>Date: ${formattedDate}</li>
        <li>Time: ${formattedTime}</li>
        <li>Location: ${location}</li>
      </ul>
      <p>View event details: <a href="${eventUrl}">${eventUrl}</a></p>
    `;

    const { data, error } = await resend.emails.send({
      from: 'Event Platform <events@yourdomain.com>',
      to: recipientEmail,
      subject: `Reminder: ${eventTitle}`,
      html: emailHtml,
    });

    if (error) throw error;
    return data;
  } catch (error) {
    console.error('Error in sendEventReminder:', error);
    throw error;
  }
}

export async function sendEventUpdate({
  recipientEmail,
  eventId,
  eventTitle,
  changes,
}: UpdateParams) {
  const eventUrl = `${process.env.NEXT_PUBLIC_APP_URL}/events/${eventId}`;

  try {
    const emailHtml = `
      <h1>Event Update: ${eventTitle}</h1>
      <p>The following changes have been made to the event:</p>
      <ul>
        ${changes.map(change => `<li>${change}</li>`).join('')}
      </ul>
      <p>View updated event details: <a href="${eventUrl}">${eventUrl}</a></p>
    `;

    const { data, error } = await resend.emails.send({
      from: 'Event Platform <events@yourdomain.com>',
      to: recipientEmail,
      subject: `Event Update: ${eventTitle}`,
      html: emailHtml,
    });

    if (error) throw error;
    return data;
  } catch (error) {
    console.error('Error in sendEventUpdate:', error);
    throw error;
  }
}

================
File: src/lib/export/index.ts
================
import ExcelJS from 'exceljs';
import { saveAs } from 'file-saver';
import Papa from 'papaparse';

export async function exportToExcel(data: any[], filename: string, sheets: { name: string; columns: any[] }[]) {
  const workbook = new ExcelJS.Workbook();

  sheets.forEach(({ name, columns }) => {
    const worksheet = workbook.addWorksheet(name);
    worksheet.columns = columns;
    worksheet.addRows(data);
  });

  const buffer = await workbook.xlsx.writeBuffer();
  const blob = new Blob([buffer], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
  saveAs(blob, `${filename}.xlsx`);
}

export function exportToCSV(data: any[], filename: string) {
  const csv = Papa.unparse(data);
  const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
  saveAs(blob, `${filename}.csv`);
}

================
File: src/lib/auth.ts
================
import { auth } from "@clerk/nextjs/server";
import { redirect } from "next/navigation";

export const initialProfile = async () => {
  const { userId } = await auth();

  if (!userId) {
    redirect("/sign-in");
  }

  return userId;
};

================
File: src/lib/google-calendar.ts
================
import { google } from 'googleapis';
import { OAuth2Client } from 'google-auth-library';

const oauth2Client = new OAuth2Client(
  process.env.GOOGLE_CLIENT_ID,
  process.env.GOOGLE_CLIENT_SECRET,
  process.env.GOOGLE_REDIRECT_URI
);

export async function addToGoogleCalendar(event: any, accessToken: string) {
  try {
    oauth2Client.setCredentials({ access_token: accessToken });
    const calendar = google.calendar({ version: 'v3', auth: oauth2Client });

    const calendarEvent = {
      summary: event.title,
      description: event.description,
      start: {
        dateTime: event.startDate,
        timeZone: 'UTC',
      },
      end: {
        dateTime: event.endDate,
        timeZone: 'UTC',
      },
      location: `${event.location.venue}, ${event.location.address}`,
      attendees: event.guests.map((guest: any) => ({
        email: guest.email,
      })),
      reminders: {
        useDefault: false,
        overrides: [
          { method: 'email', minutes: 24 * 60 },
          { method: 'popup', minutes: 30 },
        ],
      },
    };

    const response = await calendar.events.insert({
      calendarId: 'primary',
      requestBody: calendarEvent,
      sendUpdates: 'all',
    });

    return response.data;
  } catch (error) {
    console.error('Error adding event to Google Calendar:', error);
    throw error;
  }
}

================
File: src/lib/pusher.ts
================
import PusherServer from "pusher";
import PusherClient from "pusher-js";

export const pusherServer = new PusherServer({
  appId: process.env.PUSHER_APP_ID!,
  key: process.env.NEXT_PUBLIC_PUSHER_KEY!,
  secret: process.env.PUSHER_SECRET!,
  cluster: "eu",
  useTLS: true,
});

export const pusherClient = new PusherClient(
  process.env.NEXT_PUBLIC_PUSHER_KEY!,
  {
    cluster: "eu",
  }
);

================
File: src/lib/utils.ts
================
import { type ClassValue, clsx } from "clsx";
import { twMerge } from "tailwind-merge";

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs));
}

export function serializeEvent(event: any) {
  if (!event) return null;
  
  const eventObj = event.toObject ? event.toObject() : event;
  
  return {
    id: eventObj._id.toString(),
    title: eventObj.title,
    description: eventObj.description,
    startDate: new Date(eventObj.startDate).toISOString(),
    endDate: new Date(eventObj.endDate).toISOString(),
    location: {
      venue: eventObj.location?.venue || '',
      address: eventObj.location?.address || '',
      coordinates: eventObj.location?.coordinates || null,
    },
    capacity: eventObj.capacity,
    status: eventObj.status,
    visibility: eventObj.visibility,
    organizerId: eventObj.organizerId,
    coHosts: eventObj.coHosts || [],
    recurring: eventObj.recurring || null,
    createdAt: new Date(eventObj.createdAt).toISOString(),
    updatedAt: new Date(eventObj.updatedAt).toISOString(),
    attendees: {
      confirmed: 0,
      waitlist: 0,
    },
  };
}

================
File: src/types/event.ts
================
interface Event {
    id: string;
    title: string;
    description: string;
    startDate: Date;
    endDate: Date;
    location: {
      address: string;
      coordinates: {
        lat: number;
        lng: number;
      };
      venue: string;
    };
    capacity: number;
    status: 'draft' | 'published' | 'cancelled';
    visibility: 'public' | 'private';
    organizerId: string;
    coHosts: string[];
    moderators: string[];
    recurring?: {
      pattern: 'daily' | 'weekly' | 'monthly';
      interval: number;
      endDate: Date;
    };
    createdAt: Date;
    updatedAt: Date;
  }

================
File: src/middleware.ts
================
import { clerkMiddleware, createRouteMatcher } from '@clerk/nextjs/server'

const isProtectedRoute = createRouteMatcher(['/dashboard(.*)', '/forum(.*)'])

export default clerkMiddleware(async (auth, req) => {
  const { userId, redirectToSignIn } = await auth()

  if (!userId && isProtectedRoute(req)) {
    // Add custom logic to run before redirecting

    const returnUrl = new URL(req.url).pathname;
    
    return redirectToSignIn({
      returnBackUrl: returnUrl,
    });
  }

  const isAuthRoute = req.url.includes('/sign-in') || req.url.includes('/sign-up');
  if (userId && isAuthRoute) {
    const dashboardUrl = new URL('/dashboard', req.url);
    return Response.redirect(dashboardUrl);
  }
})

export const config = {
  matcher: [
    // Skip Next.js internals and all static files, unless found in search params
    '/((?!_next|[^?]*\\.(?:html?|css|js(?!on)|jpe?g|webp|png|gif|svg|ttf|woff2?|ico|csv|docx?|xlsx?|zip|webmanifest)).*)',
    // Always run for API routes
    '/(api|trpc)(.*)',
  ],
}

================
File: .gitignore
================
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.js
.yarn/install-state.gz

# testing
/coverage

# next.js
/.next/
/out/

# production
/build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# local env files
.env*.local

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts

================
File: components.json
================
{
  "$schema": "https://ui.shadcn.com/schema.json",
  "style": "default",
  "rsc": true,
  "tsx": true,
  "tailwind": {
    "config": "tailwind.config.ts",
    "css": "src/app/globals.css",
    "baseColor": "slate",
    "cssVariables": true,
    "prefix": ""
  },
  "aliases": {
    "components": "@/components",
    "utils": "@/lib/utils",
    "ui": "@/components/ui",
    "lib": "@/lib",
    "hooks": "@/hooks"
  }
}

================
File: next.config.mjs
================
// next.config.js
/** @type {import('next').NextConfig} */
const nextConfig = {
    images: {
      domains: ['res.cloudinary.com', 'uploadthing.com'],
    },
    env: {
      NEXT_PUBLIC_API_URL: process.env.NEXT_PUBLIC_API_URL,
    },
    webpack: (config) => {
      config.externals.push({
        "utf-8-validate": "commonjs utf-8-validate",
        bufferutil: "commonjs bufferutil"
      });
      return config;
    },
  }
  
export default nextConfig

================
File: package.json
================
{
  "name": "feest-2",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint"
  },
  "dependencies": {
    "@clerk/clerk-sdk-node": "^5.0.54",
    "@clerk/nextjs": "^6.0.2",
    "@hookform/resolvers": "^3.9.1",
    "@radix-ui/react-avatar": "^1.1.1",
    "@radix-ui/react-dialog": "^1.1.2",
    "@radix-ui/react-dropdown-menu": "^2.1.2",
    "@radix-ui/react-label": "^2.1.0",
    "@radix-ui/react-popover": "^1.1.2",
    "@radix-ui/react-scroll-area": "^1.2.0",
    "@radix-ui/react-select": "^2.1.2",
    "@radix-ui/react-separator": "^1.1.0",
    "@radix-ui/react-slot": "^1.1.0",
    "@radix-ui/react-switch": "^1.1.1",
    "@radix-ui/react-tabs": "^1.1.1",
    "@radix-ui/react-toast": "^1.2.2",
    "@radix-ui/react-tooltip": "^1.1.3",
    "@react-email/components": "^0.0.25",
    "@react-google-maps/api": "^2.20.3",
    "@uploadthing/react": "^7.1.0",
    "axios": "^1.7.7",
    "class-variance-authority": "^0.7.0",
    "clsx": "^2.1.1",
    "csv-writer": "^1.6.0",
    "date-fns": "^2.30.0",
    "exceljs": "^4.4.0",
    "file-saver": "^2.0.5",
    "google-auth-library": "^9.14.2",
    "googleapis": "^144.0.0",
    "lucide-react": "^0.454.0",
    "moment": "^2.30.1",
    "mongoose": "^8.7.3",
    "next": "14.2.16",
    "next-themes": "^0.3.0",
    "papaparse": "^5.4.1",
    "pusher": "^5.2.0",
    "pusher-js": "^8.4.0-rc2",
    "qrcode.react": "^4.1.0",
    "react": "^18",
    "react-big-calendar": "^1.15.0",
    "react-day-picker": "^8.10.1",
    "react-dom": "^18",
    "react-hook-form": "^7.53.1",
    "recharts": "^2.13.2",
    "resend": "^4.0.1-alpha.0",
    "socket.io-client": "^4.8.1",
    "tailwind-merge": "^2.5.4",
    "tailwindcss-animate": "^1.0.7",
    "uploadthing": "^7.2.0",
    "zod": "^3.23.8"
  },
  "devDependencies": {
    "@types/file-saver": "^2.0.7",
    "@types/node": "^20.17.4",
    "@types/papaparse": "^5.3.15",
    "@types/react": "^18.3.12",
    "@types/react-big-calendar": "^1.15.0",
    "@types/react-dom": "^18.3.1",
    "postcss": "^8",
    "prettier": "^3.3.3",
    "prettier-plugin-tailwindcss": "^0.6.8",
    "tailwindcss": "^3.4.1",
    "typescript": "^5"
  }
}

================
File: postcss.config.mjs
================
/** @type {import('postcss-load-config').Config} */
const config = {
  plugins: {
    tailwindcss: {},
  },
};

export default config;

================
File: tailwind.config.ts
================
import type { Config } from "tailwindcss";

const config: Config = {
    darkMode: ["class"],
    content: [
    "./src/pages/**/*.{js,ts,jsx,tsx,mdx}",
    "./src/components/**/*.{js,ts,jsx,tsx,mdx}",
    "./src/app/**/*.{js,ts,jsx,tsx,mdx}",
  ],
  theme: {
  	extend: {
  		colors: {
  			background: 'hsl(var(--background))',
  			foreground: 'hsl(var(--foreground))',
  			card: {
  				DEFAULT: 'hsl(var(--card))',
  				foreground: 'hsl(var(--card-foreground))'
  			},
  			popover: {
  				DEFAULT: 'hsl(var(--popover))',
  				foreground: 'hsl(var(--popover-foreground))'
  			},
  			primary: {
  				DEFAULT: 'hsl(var(--primary))',
  				foreground: 'hsl(var(--primary-foreground))'
  			},
  			secondary: {
  				DEFAULT: 'hsl(var(--secondary))',
  				foreground: 'hsl(var(--secondary-foreground))'
  			},
  			muted: {
  				DEFAULT: 'hsl(var(--muted))',
  				foreground: 'hsl(var(--muted-foreground))'
  			},
  			accent: {
  				DEFAULT: 'hsl(var(--accent))',
  				foreground: 'hsl(var(--accent-foreground))'
  			},
  			destructive: {
  				DEFAULT: 'hsl(var(--destructive))',
  				foreground: 'hsl(var(--destructive-foreground))'
  			},
  			border: 'hsl(var(--border))',
  			input: 'hsl(var(--input))',
  			ring: 'hsl(var(--ring))',
  			chart: {
  				'1': 'hsl(var(--chart-1))',
  				'2': 'hsl(var(--chart-2))',
  				'3': 'hsl(var(--chart-3))',
  				'4': 'hsl(var(--chart-4))',
  				'5': 'hsl(var(--chart-5))'
  			}
  		},
  		borderRadius: {
  			lg: 'var(--radius)',
  			md: 'calc(var(--radius) - 2px)',
  			sm: 'calc(var(--radius) - 4px)'
  		}
  	}
  },
  plugins: [require("tailwindcss-animate")],
};
export default config;

================
File: tsconfig.json
================
{
  "compilerOptions": {
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}
